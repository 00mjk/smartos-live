/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2017, Joyent, Inc.
 *
 */

/*
 * Queue is a wrapper around a vasync queue with a few added features:
 *
 * - Ability to pause, fast-forward, and resume the queue
 * - Optional deduplication for queued tasks with the same string identifier
 * - Optional timeout for jobs taking too long
 * - Tasks (functions) get a custom logger with unique job identifier
 * - Timing stats for job create (enqueue), start, and finish.
 *
 * Every task pushed to the queue must contain at least a function to run, and
 * a string identifier (called description).
 *
 * Example
 *
 * var q = new Queue({
 *     log: log,     // [required] bunyan logger
 *     workers: 1,   // [required] number of concurrent workers
 *     dedup: true,  // [optional] discard enqueued tasks with same description
 *     paused: true, // [optional] start paused, defauts to false
 *
 * });
 *
 * q.enqueue({
 *     // used for logging, and deduplication if enabled
 *     description: 'sysevent seen for zone foo',
 *
 *     // kill the task if it takes more than 30 seconds, default is no timeout
 *     timeout: 30 * 1000,
 *
 *     // the function to run - cb doesn't expect any arguments
 *     func: function (extras, cb) {
 *         // this logger contains the job object, which has the jobs UUID,
 *         // description, and more.  This is a childlog of the logger passed
 *         // in during queue creation.
 *         extras.log('doing something');
 *
 *         somethingAsync(function () {
 *             cb(); // let the queue know this task is over
 *         });
 *     }
 * });
 *
 * q.enqueue({
 *     description: 'sysevent seen for zone bar',
 *     func: function (extras, cb) { cb(); }
 * });
 *
 * .enqueue() also returns a value: true if the task was queued or false if it
 * was discarded by deduplication.  For example:
 *
 * ret = q.enqueue({
 *     description: 'foo',
 *     func: function (extras, cb) { cb(); }
 * });
 * // ret => true, no task with this name is enqueued
 *
 * ret = q.enqueue({
 *     description: 'foo',
 *     func: function (extras, cb) { cb(); }
 * });
 * // ret => false, a task with this name is enqueued so this task is discarded
 *
 * There are now 3 tasks on the queue but it is currently paused, we can uncork
 * it with:
 *
 * q.resume();
 *
 * Finally, Queue supports fast-forwarding the queue.  When a task is enqueued,
 * the current timestamp is stored for it (called "create" time).  When you
 * call .fastForward(), you pass in a JavaScript Date object, and all items
 * created on or before that Date will be ran through the queue, and the
 * callback will fire when all tasks are completed.
 *
 * For Example (queue must be paused or an error is thrown)
 *
 * var one_minute_ago = new Date(Date.now() - (60 * 1000));
 * var opts = {
 *     timeout: 60 * 1000  [optional] timeout to error out fast-forward
 * q.fastForward(one_minute_ago, opts, function (err) {
 *     // `err` can only be set if opts.timeout was specified and exceeded.
 *     // In this event, the tasks are still running when this callback is
 *     // fired, but the queue is still technically paused.
 *
 *     // Otherwise, this means the enqueued tasks created exactly or more than
 *     // a minute ago are now complete.
 * });
 *
 */

var assert = require('/usr/node/node_modules/assert-plus');
var libuuid = require('/usr/node/node_modules/uuid');
var vasync = require('/usr/vm/node_modules/vasync');

module.exports.Queue = Queue;

function Queue(opts) {
    var self = this;

    opts = opts || {};
    assert.object(opts, 'opts');
    assert(opts.log, 'opts.log');
    assert.number(opts.workers, 'opts.workers');
    assert.optionalBool(opts.dedup, 'opts.dedup');
    assert.optionalBool(opts.paused, 'opts.paused');

    // paused
    self.paused = !!opts.paused;
    self.paused_date = self.paused ? new Date() : null;

    // max workers
    self.workers = parseInt(opts.workers, 10);

    // logger
    self.log = opts.log;

    // should dedup
    self.dedup = opts.dedup;

    // jobs waiting to run (pushed when paused)
    self.paused_queue = [];

    // vasync queue
    self.queue = vasync.queue(function (job, cb) {
        // when a job is starting, we record the date and create a unique id
        // for it (for logging purposes)
        job.id = libuuid.create();
        job.started_at = new Date();

        // "extras" is passed to the user function when it is called
        var childlog = self.log.child({job: job});
        var extras = {
            log: childlog
        };

        // create a timer for this job - this will effectively crash the
        // process if a task takes too long
        var timeout;
        if (job.timeout) {
            timeout = setTimeout(function () {
                var err = new Error('timeout exceeded');
                childlog.fatal({err: err, timeout: job.timeout},
                    'job took longer than %dms', job.timeout);
                throw err;
            }, job.timeout);
        }

        childlog.debug('starting job');
        job.func(extras, function () {
            job.finished_at = new Date();
            var delta = job.finished_at - job.started_at;

            childlog.debug({delta: delta}, 'finished job in %dms', delta);

            // clear the timeout
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }

            cb();
        });
    }, self.workers);
};

/*
 * Push a task to the queue.  If we are currently paused the task will be
 * stored in the "paused_queue" array, to be pushed onto the vasync queue
 * at a later time as either part of a .resume() or .fastForward().  If
 * we are not paused, the task is pushed directly onto the vasync queue.
 *
 * A task must have a function set, as well as a string description.  If the
 * description of a task being pushed matches the description of a task
 * already queued to run, and opts.dedup was set in the queues constructor,
 * the task is discarded.
 *
 * Returns:
 *   true    the task was enqueued, either while paused or running
 *   false   the task wes discarded as a dup (only happens when opts.dedup)
 */
Queue.prototype.enqueue = function (opts, cb) {
    var self = this;
    var found;

    assert.object(opts, 'opts');
    assert.func(opts.func, 'opts.func');
    assert.string(opts.description, 'opts.description');
    assert.optionalNumber(opts.timeout, 'opts.timeout');

    opts.created_at = new Date();

    if (self.paused) {
        if (!self.dedup) {
            self.log.debug({opts: opts}, 'pushed to paused queue');
            self.paused_queue.push({opts: opts, cb: cb});
            return true;
        }

        found = self.paused_queue.some(function (o) {
            return o.opts.description === opts.description;
        });

        if (found) {
            self.log.debug({opts: opts}, 'duplicate job found - discarding');
            return false;
        }

        self.log.debug({opts: opts},
            'no duplicate job found - pushing to paused queue');
        self.paused_queue.push({opts: opts, cb: cb});
        return true;
    } else {
        if (!self.dedup) {
            self.log.debug({opts: opts}, 'pushed to vasync queue');
            self.queue.push(opts, cb);
            return true;
        }

        found = self.queue.queued.some(function (o) {
            return o.task.description === opts.description;
        });

        if (found) {
            self.log.debug({opts: opts}, 'duplicate job found - discarding');
            return false;
        }

        self.log.debug({opts: opts},
            'no duplicate job found - pushing to vasync queue');
        self.queue.push(opts, cb);
        return true;
    }
};

/*
 * Pause the queue
 *
 * This will stop pushing new tasks (via .enque()) to the vasync queue, and
 * wait for it to finish processing its current tasks (via the 'drain' event
 * being emitted).  An optional timeout may be specified to callback with an
 * error if it takes too long to stop the queue.
 */
Queue.prototype.pause = function (opts, cb) {
    var self = this;

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }

    assert(!self.paused, 'queue is already paused!');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.func(cb, 'cb');

    self.paused = true;
    self.paused_date = new Date();

    // short-circuit logic if no job is currently running
    if (self.queue.npending === 0) {
        self.log.debug('queue paused');
        cb();
        return;
    }

    // job(s) running - wait for finish
    var timeout;
    if (opts.timeout) {
        timeout = setTimeout(function () {
            var err = new Error('pause timeout exceeded');
            self.log.fatal({err: err, timeout: opts.timeout},
                'pause took longer than %dms', opts.timeout);
            self.queue.removeListener('drain', ondrain);
            self.resume();
            cb(err);
        }, opts.timeout);
    }

    self.queue.once('drain', ondrain);

    // vasync queue has drained, we can pause
    function ondrain() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        cb();
    }
};

/*
 * Resume the queue.
 *
 * This will take all of the elements of the paused_queue and push them into
 * the vasync queue.
 */
Queue.prototype.resume = function () {
    var self = this;

    assert(self.paused, 'queue is not paused!');

    self.paused = false;
    self.paused_date = null;
    self.log.debug('queue resumed - enqueueing %d tasks',
        self.paused_queue.length);

    self.paused_queue.forEach(function (o) {
        self.queue.push(o.opts, o.cb);
    });
    self.paused_queue.length = 0;
};

/*
 * Fast Forward the queue to a given date.
 *
 * The queue must be paused for this to work.  Given a date object as the first
 * argument, this function will process every item in the queue that was queued
 * before the date given.
 */
Queue.prototype.fastForward = function (time, opts, cb) {
    var self = this;

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }

    assert(self.paused, 'queue must be paused to fast-forward');
    assert.date(time, 'time');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.func(cb, 'cb');

    // loop all queued tasks and dispatch them if they were created before the
    // fast-forward date
    var task;
    var i = 0;
    while ((task = self.paused_queue.shift())) {
        if (task.opts.created_at <= time) {
            i++;
            self.queue.push(task.opts, task.cb);
        } else {
            self.paused_queue.unshift(task);
            break;
        }
    }
    self.log.debug('fast-forward pushed %d tasks into queue', i);

    // just callback immediately if no tasks were pushed
    if (i === 0) {
        cb();
        return;
    }

    // job(s) running - wait for finish
    var timeout;
    if (opts.timeout) {
        timeout = setTimeout(function () {
            var err = new Error('fast-forward timeout exceeded');
            self.log.error({err: err, timeout: opts.timeout},
                'fast-forward took longer than %dms', opts.timeout);
            self.queue.removeListener('drain', ondrain);
            cb(err);
        }, opts.timeout);
    }

    self.queue.once('drain', ondrain);

    function ondrain() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        cb();
    }
};

/*
 * Return the queue status as an object.
 *
 * This is useful for stringifying and outputting as part of an HTTP request
 * for a web service, or running this and storing in memory before a process
 * crash.
 */
Queue.prototype.dump = function () {
    var self = this;

    var now = new Date();

    var state = {
        paused: self.paused,
        vasync_queue: {
            concurrency: self.queue.concurrency,
            npending: self.queue.npending,
            nqueued: self.queue.length(),
            pending: {},
            queued: []
        }
    };

    Object.keys(self.queue.pending).forEach(function (id) {
        var task = self.queue.pending[id].task;
        var o = {
            description: task.description,
            created_at: task.created_at,
            started_at: task.started_at,
            created_ago: relative(now - task.created_at),
            started_ago: relative(now - task.started_at),
            start_latency: relative(task.started_at - task.created_at)

        };
        state.vasync_queue.pending[task.id] = o;
    });

    self.queue.queued.forEach(function (q) {
        var task = q.task;
        var o = {
            description: task.description,
            created_at: task.created_at,
            created_ago: relative(now - task.created_at)
        };
        state.vasync_queue.queued.push(o);
    });

    if (self.paused) {
        state.paused_at = self.paused_date;
        state.paused_ago = relative(self.paused_date);
        state.paused_nqueued = self.paused_queue.length;
        state.paused_queue = self.paused_queue;
    }

    return state;
};

function relative(ms) {
    if (ms instanceof Date)
        ms = new Date() - ms;

    var times = [
        ms / 1000 / 60 / 60 / 24, // days
        ms / 1000 / 60 / 60,      // hours
        ms / 1000 / 60,           // minutes
        ms / 1000,                // seconds
        ms                        // ms
    ];
    var names = ['d', 'h', 'm', 's', 'ms'];

    for (var i = 0; i < names.length; i++) {
        var time = Math.floor(times[i]);
        if (time > 0)
            return time + names[i];
    }
    return '0ms';
}
