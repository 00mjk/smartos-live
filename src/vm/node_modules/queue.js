/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2016, Joyent, Inc.
 *
 */

var assert = require('/usr/node/node_modules/assert-plus');
var libuuid = require('/usr/node/node_modules/uuid');

var vasync = require('vasync');

var DEFAULT_JOB_TIMEOUT = 5 * 60 * 1000; // 5 minutes

var Queue = module.exports = function (opts) {
    var self = this;

    opts = opts || {};
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.workers, 'opts.workers');
    assert(opts.log, 'opts.log');

    // paused
    self.paused = (opts.paused === undefined) ? false : opts.paused;
    self.paused_date = self.paused ? new Date() : null;

    // max workers
    self.workers = opts.workers || 1;

    // logger
    self.log = opts.log;

    // callbacks to fire when the queue is paused
    self.pause_callbacks = {};

    // jobs waiting to run (pushed when paused)
    self.paused_queue = [];

    // vasync queue
    self.queue = vasync.queue(function (job, cb) {
        job.started_at = new Date();
        job.id = libuuid.create();
        job.timeout = job.timeout || DEFAULT_JOB_TIMEOUT;

        var childlog = self.log.child({job: job});
        var extras = {
            log: childlog
        };

        // create a timer for this job
        var timeout = setTimeout(function () {
            var err = new Error('timeout exceeded');
            childlog.fatal({err: err, timeout: job.timeout},
                'job took longer than %dms', job.timeout);
            throw err;
        }, job.timeout);

        childlog.debug('starting job');
        job.func(extras, function () {
            job.finished_at = new Date();
            var delta = job.finished_at - job.started_at;

            childlog.debug({delta: delta}, 'finished job in %dms', delta);

            // clear the timeout
            clearTimeout(timeout);
            timeout = null;

            cb();
        });
    }, self.workers);
};

Queue.prototype.enqueue = function (opts, cb) {
    var self = this;

    assert.object(opts, 'opts');
    assert.func(opts.func, 'opts.func');
    assert.string(opts.description, 'opts.description');
    assert.optionalNumber(opts.timeout, 'opts.timeout');

    opts.created_at = new Date();

    if (self.paused) {
        self.paused_queue.push({opts: opts, cb: cb});
    } else {
        self.pushTask(opts, cb);
    }
};

// private
Queue.prototype.pushTask = function (opts, cb) {
    var self = this;

    self.queue.push(opts, function() {
        // call the paused callbacks if this is the last job being run
        if (self.queue.concurrency === 0 && self.npending === 0) {
            self.paused = true;
            self.paused_date = new Date();
            self.log.debug('queue paused');

            Object.keys(self.pause_callbacks).forEach(function (id) {
                var o = self.pause_callbacks[id];
                self.log.debug({id: id}, 'firing pause callback for %s', id);
                clearTimeout(o.timeout);
                o.cb();
                delete self.pause_callbacks[id];
            });
        }

        // call the user-specified callback if supplied
        if (cb)
            cb();
    });
};

Queue.prototype.pause = function (opts, cb) {
    var self = this;

    assert(!self.paused, 'queue is already paused!');
    assert.object(opts, 'opts');
    assert.number(opts.timeout, 'opts.timeout');
    assert.func(cb, 'cb');

    self.paused = true;
    self.paused_date = new Date();

    // short-circuit logic if no job is currently running
    if (self.queue.npending === 0) {
        self.log.debug('queue paused');
        cb();
        return;
    }

    // job(s) running - wait for finish
    var timeout = setTimeout(function () {
        var err = new Error('pause timeout exceeded');
        self.log.fatal({err: err, timeout: opts.timeout},
            'pause took longer than %dms', opts.timeout);
        self.queue.removeListener('drain', ondrain);
        self.queue.resume();
        cb(err);
    }, opts.timeout);

    self.queue.once('drain', ondrain);

    // vasync queue has drained, we can pause
    function ondrain() {
        clearTimeout(timeout);
        cb();
    }
};

Queue.prototype.resume = function () {
    var self = this;

    assert(self.paused, 'queue is not paused!');

    self.paused = false;
    self.paused_date = null;
    self.log.debug('queue resumed - enqueueing %d tasks', self.paused_queue.length);

    self.paused_queue.forEach(function (o) {
        self.pushTask(o.opts, o.cb);
    });
    self.paused_queue.length = 0;
};

Queue.prototype.fastForward = function (time, opts, cb) {
    var self = this;

    assert(self.paused, 'queue must be paused to fast-forward');
    assert.date(time, 'time');
    assert.object(opts, 'opts');
    assert.number(opts.timeout, 'opts.timeout');
    assert.func(cb, 'cb');

    // loop all queued tasks and dispatch them if they were
    // created before the fast-forward date
    var task;
    var i = 0;
    while ((task = self.paused_queue.shift())) {
        if (task.opts.created_at < time) {
            i++;
            self.pushTask(task.opts, task.cb);
        } else {
            self.paused_queue.unshift(task);
            break;
        }
    }
    self.log.debug('fast-forward pushed %d tasks into queue', i);

    // just callback immediately if no tasks were pushed
    if (i === 0) {
        cb();
        return;
    }

    // job(s) running - wait for finish
    var timeout = setTimeout(function () {
        var err = new Error('fast-forward timeout exceeded');
        self.log.fatal({err: err, timeout: opts.timeout},
            'fast-forward took longer than %dms', opts.timeout);
        self.queue.removeListener('drain', ondrain);
        self.queue.resume();
        cb(err);
    }, opts.timeout);


    self.queue.once('drain', ondrain);

    function ondrain() {
        clearTimeout(timeout);
        cb();
    }
};

Queue.prototype.dump = function () {
    var self = this;

    var now = new Date();

    var state = {
        paused: self.paused,
        vasync_queue: {
            concurrency: self.queue.concurrency,
            npending: self.queue.npending,
            nqueued: self.queue.length(),
            pending: {},
            queued: []
        }
    };

    Object.keys(self.queue.pending).forEach(function (id) {
        var task = self.queue.pending[id].task;
        var o = {
            description: task.description,
            created_at: task.created_at,
            started_at: task.started_at,
            created_ago: relative(now - task.created_at),
            started_ago: relative(now - task.started_at),
            start_latency: relative(task.started_at - task.created_at)

        };
        state.vasync_queue.pending[task.id] = o;
    });

    self.queue.queued.forEach(function (q) {
        var task = q.task;
        var o = {
            description: task.description,
            created_at: task.created_at,
            created_ago: relative(now - task.created_at)
        };
        state.vasync_queue.queued.push(o);
    });

    if (self.paused) {
        state.paused_at = self.paused_date;
        state.paused_ago = relative(self.paused_date);
        state.paused_nqueued = self.paused_queue.length;
        state.paused_queue = self.paused_queue;
    }

    return state;
};

function relative(ms) {
    if (ms instanceof Date)
        ms = new Date() - ms;
    assert.ok(ms >= 0, 'date in the future');

    var times = [
        ms / 1000 / 60 / 60 / 24, // days
        ms / 1000 / 60 / 60,      // hours
        ms / 1000 / 60,           // minutes
        ms / 1000,                // seconds
        ms                        // ms
    ];
    var names = ['d', 'h', 'm', 's', 'ms'];

    for (var i = 0; i < names.length; i++) {
        var time = Math.floor(times[i]);
        if (time > 0)
            return time + names[i];
    }
    return '0ms';
}
var then = new Date();
setTimeout(function () {
    console.log(relative(then));

}, 500);
