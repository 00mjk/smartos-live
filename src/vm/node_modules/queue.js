/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2016, Joyent, Inc.
 *
 */

var assert = require('/usr/node/node_modules/assert-plus');
var libuuid = require('/usr/node/node_modules/uuid');

var DEFAULT_JOB_TIMEOUT = 5 * 60 * 1000; // 5 minutes

var Queue = module.exports = function (opts) {
    var self = this;

    if (!opts) {
        opts = {};
    }

    // total job counter across all channels
    self.working = 0;

    // the total number of concurrent jobs across all channels
    self.max_jobs = (opts.max_jobs === undefined) ? 2 : opts.max_jobs;

    // the backlog of jobs when max_jobs limit is reached
    self.backlog = [];

    // jobs are queued in channels
    self.channels = {};

    // the number of concurrent jobs per channel
    self.workers = (opts.workers === undefined) ? 1 : opts.workers;

    // lock to prevent workers from running
    self.paused = (opts.paused === undefined) ? false : opts.paused;

    // callbacks once we have confirmed pause
    self.pause_callbacks = {};

    // pause callback timers
    self.pause_timers = {};

    // a timestamp
    self.stop_at = undefined;

    // callbacks once we have confirmed fast forwarded
    self.ff_callbacks = {};

    // fast forward callback timers
    self.ff_timers = {};

    // logger
    self.log = opts.log;
    assert(self.log, 'logger must be passed as opts.log');

    self.work = function (id) {
        var channel;
        var childlog;
        var extras;
        var job;
        var jobcopy = {};
        var timeout;
        var timer;

        if (id === undefined) {
            id = 'global';
        }

        // queue is paused and we're not fast-forwarding
        if (self.paused === true && self.stop_at === undefined) {
            return;
        }

        // make sure we have a channel with that id
        if (!self.channels.hasOwnProperty(id)) {
            return;
        }

        // get the channel
        channel = self.channels[id];

        // no jobs to work
        if (channel.jobs.length === 0) {
            return;
        }

        // max concurrency
        if (channel.working === self.workers) {
            return;
        }

        job = channel.jobs.shift();

        // we've fast-forwarded
        if (self.stop_at !== undefined) {
            if (job.created_at > self.stop_at) {
                // add the job back
                channel.jobs.unshift(job);
                return;
            }
        }

        // increment the working count
        self.working++;
        channel.working++;

        // add the job into the running set
        channel.running[job.id] = job;

        // set the started_at timestamp
        job.started_at = new Date();

        // create a unique ID for the job
        job.uuid = libuuid.create();

        // copy the job object for the child object
        Object.keys(job).forEach(function (key) {
            if (['log'].indexOf(key) >= 0)
                return;
            jobcopy[key] = job[key];
        });
        childlog = job.log.child({job: jobcopy});

        // create a timer for this job
        timer = job.timeout || DEFAULT_JOB_TIMEOUT;
        timeout = setTimeout(function () {
            var err = new Error('timeout exceeded');
            childlog.fatal({err: err, timeout: timer},
                'job took longer than %dms', timer);
            throw err;
        }, timer);

        childlog.debug('starting job');

        extras = {
            log: childlog
        };
        job.func(extras, function () {
            var delta;

            // the job finished
            job.finished_at = new Date();
            delta = job.finished_at - job.started_at;
            childlog.debug({delta: delta}, 'finished job in %dms', delta);

            // clear the timeout
            clearTimeout(timeout);
            timeout = null;

            // decrement the working count
            self.working--;
            channel.working--;

            // pull the job out of the working set
            delete (channel.running)[job.id];

            // run the original callback, passing along the arguments
            job.callback.apply(null, arguments);

            // if there's anything in the backlog, pop one off and requeue
            if (self.backlog.length > 0) {
                self.enqueue(self.backlog.shift());
            }

            // checkPaused if nothing is working
            if (channel.working === 0) {
                self.checkPaused();
            }

            // checkFastForwarded if nothing is working
            if (channel.working === 0) {
                self.checkFastForwarded();
            }

            // remove the channel if there's nothing left to do,
            // or work the next job in the list
            if (channel.jobs.length === 0) {
                delete (self.channels)[id];
            } else {
                process.nextTick(function () {
                    self.work(id);
                });
            }

        });
    };

    self.checkPaused = function () {
        var id;

        if (self.paused !== true) {
            return;
        }

        for (id in self.channels) {
            if (self.channels[id].working > 0) {
                // something is still working
                return;
            }
        }

        for (id in self.pause_callbacks) {
            // fire the callback
            self.pause_callbacks[id]();

            // clear the timeout and clean entries
            clearTimeout(self.pause_timers[id]);
            delete (self.pause_callbacks)[id];
            delete (self.pause_timers)[id];
        }
    };

    self.checkFastForwarded = function () {
        var id;
        var i;

        if (self.stop_at === undefined) {
            return;
        }

        for (id in self.channels) {
            if (self.channels[id].working > 0) {
                // something is still working
                return;
            }

            for (i = 0; i < self.channels[id].jobs.length; i++) {
                if (self.channels[id].jobs[i].created_at < self.stop_at) {
                    // something still needs to work
                    return;
                }
            }
        }

        for (id in self.ff_callbacks) {
            // fire the callback
            self.ff_callbacks[id]();

            // clear the timeout and clean entries
            clearTimeout(self.ff_timers[id]);
            delete (self.ff_callbacks)[id];
            delete (self.ff_timers)[id];
        }
    };

    self.generateId = function () {
        var i;
        var rand;
        var charCode;
        var str = "";

        for(i=0; i<10; i++){
            rand = Math.floor( Math.random() * 62 );
            charCode = rand+= rand>9? (rand<36?55:61) : 48;
            str += String.fromCharCode( charCode );
        }

        return (str);
    };

    self.timeAgo = function (timestamp) {
        var now = Date.now();
        var then = Date.parse(timestamp);
        var duration = now - then;
        var ms_in_hour = 3600000;
        var ms_in_minute = 60000;
        var ms_in_second = 1000;
        var summary = '';
        var hours;
        var minutes;
        var seconds;
        var hour_label;
        var minute_label;
        var second_label;

        hours = Math.floor(duration / ms_in_hour);
        duration = duration - (hours * ms_in_hour);
        minutes = Math.floor(duration / ms_in_minute);
        duration = duration - (minutes * ms_in_minute);
        seconds = Math.floor(duration / ms_in_second);

        if (hours > 1) {
            hour_label = 'hours';
        } else {
            hour_label = 'hour';
        }

        if (minutes > 1) {
            minute_label = 'minutes';
        } else {
            minute_label = 'minute';
        }

        if (seconds > 1) {
            second_label = 'seconds';
        } else {
            second_label = 'second';
        }

        if (hours > 0) {
            summary += hours + ' ' + hour_label;
        }

        if (minutes > 0 && seconds > 0) {
            if (hours > 0) {
                summary += ' ';
            }
            summary += minutes + ' ' + minute_label;
            summary += ' and ' + seconds + ' ' + second_label;
        } else if (minutes > 0) {
            if (hours > 0) {
                summary += 'and ';
            }
            summary += minutes + ' ' + minute_label;
        } else if (seconds > 0) {
            if (hours > 0) {
                summary += 'and ';
            }
            summary += seconds + ' ' + second_label;
        }

        if (hours === 0 && minutes === 0 && seconds === 0) {
            summary = duration + ' milliseconds';
        }

        summary += ' ago';

        return (summary);
    };

    return (self);
};

Queue.prototype.enqueue = function (opts, cb) {
    var self = this;
    var channel;
    var job;

    assert.object(opts, 'opts');
    opts.id = opts.id || 'global';

    assert.string(opts.id, 'opts.id');
    assert.func(opts.func, 'opts.func');
    assert.string(opts.description, 'opts.description');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.optionalObject(opts.log, 'opts.log');

    cb = cb || opts.callback || function () {};
    assert.func(cb, 'cb must be a function');

    job = {
        id: opts.id,
        description: opts.description,
        func: opts.func,
        callback: cb,
        created_at: (new Date()).toISOString(),
        started_at: null,
        finished_at: null,
        timeout: opts.timeout,
        log: opts.log || self.log
    };

    // backlog if we're over the global limit
    if (self.working >= self.max_jobs) {
        self.backlog.push(job);
        return;
    }

    // create the channel if it doesn't exist
    if (!self.channels.hasOwnProperty(opts.id)) {
        self.channels[opts.id] = {
            jobs: [],
            running: {},
            working: 0,
            incr: 0
        };
    }

    channel = self.channels[opts.id];
    channel.incr++;

    job.id = channel.incr;

    channel.jobs.push(job);

    process.nextTick(function () {
        self.work(opts.id);
    });
};

Queue.prototype.pause = function (options, callback) {
    var self = this;
    var id;
    self.paused = true;

    if (options === undefined) {
        options = {};
    }

    if (typeof (options) === 'function') {
        callback = options;
        options = {};
    }

    if (callback) {
        id = self.generateId();
        self.pause_callbacks[id] = callback;

        if (options.hasOwnProperty('timeout')) {
            self.pause_timers[id] = setTimeout(function () {
                callback(new Error('timeout duration exceeded'));
                delete (self.pause_callbacks)[id];
                delete (self.pause_timers)[id];
            }, options.timeout);
        }
    }

    self.checkPaused();
};

Queue.prototype.resume = function () {
    var self = this;
    self.paused = false;

    self.stop_at = undefined;
    self.pause_callbacks = [];
    self.ff_callbacks = [];

    Object.keys(self.channels).forEach(function (id) {
        self.work(id);
    });
};

Queue.prototype.fastForward = function (timestamp, options, callback) {
    var self = this;
    var id;

    if (self.paused !== true) {
        callback(new Error('cannot fastForward a queue that is not paused'));
        return;
    }

    self.stop_at = timestamp;

    if (options === undefined) {
        options = {};
    }

    if (typeof (options) === 'function') {
        callback = options;
        options = {};
    }

    if (callback) {
        id = self.generateId();
        self.ff_callbacks[id] = callback;

        if (options.hasOwnProperty('timeout')) {
            self.ff_timers[id] = setTimeout(function () {
                callback(new Error('timeout duration exceeded'));
                delete (self.ff_callbacks)[id];
                delete (self.ff_timers)[id];
            }, options.timeout);
        }
    }
    self.checkFastForwarded();
};

/*
 * Creates snapshot to represent the internal state of the queue at this
 * exact moment in time. The resulting data structure can be serialized
 * for external introspective analysis.
 */
Queue.prototype.dump = function () {
    var self = this;
    var channels = [];
    var backlog = [];
    var snapshot;

    Object.keys(self.channels).forEach(function (channel) {
        var running = [];
        var waiting = [];

        Object.keys(self.channels[channel].running).forEach(function (id) {
            var job = self.channels[channel].running[id];
            running.push({
                description: job.description,
                created: job.created_at,
                started: job.started_at,
                created_human: self.timeAgo(job.created_at),
                started_human: self.timeAgo(job.started_at)
            });
        });

        self.channels[channel].jobs.forEach(function (job) {
            waiting.push({
                description: job.description,
                created: job.created_at,
                created_human: self.timeAgo(job.created_at)
            });
        });

        channels.push({
            id: channel,
            working: self.channels[channel].working,
            running: running,
            waiting: waiting
        });
    });

    self.backlog.forEach(function (job) {
        backlog.push({
            id: job.id,
            description: job.description,
            created: job.created_at,
            created_human: self.timeAgo(job.created_at)
        });
    });

    snapshot = {
        paused: self.paused,
        working: self.working,
        max_jobs: self.max_jobs,
        channels: channels,
        backlog: backlog
    };

    return (snapshot);
};
