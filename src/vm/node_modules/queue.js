/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2016, Joyent, Inc.
 *
 */

var assert = require('/usr/node/node_modules/assert-plus');
var libuuid = require('/usr/node/node_modules/uuid');

var vasync = require('vasync');

var DEFAULT_JOB_TIMEOUT = 5 * 60 * 1000; // 5 minutes

var Queue = module.exports = function (opts) {
    var self = this;

    opts = opts || {};
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.workers, 'opts.workers');
    assert(opts.log, 'opts.log');

    // paused
    self.paused = (opts.paused === undefined) ? false : opts.paused;

    // max workers
    self.workers = opts.workers || 1;

    // logger
    self.log = opts.log;

    // callbacks to fire when the queue is paused
    self.pause_callbacks = {};

    // jobs waiting to run (pushed when paused)
    self.queued = [];

    // vasync queue
    self.queue = vasync.queue(function (opts, cb) {
        var job = {
            started_at: new Date(),
            id: libuuid.create()
        };

        assert.object(opts, 'opts');
        assert.date(opts.created_at, 'opts.created_at');
        assert.func(opts.func, 'opts.func');
        assert.string(opts.description, 'opts.description');
        assert.optionalNumber(opts.timeout, 'opts.timeout');

        job.created_at = opts.created_at;
        job.func = opts.func;
        job.description = opts.description;
        job.timeout = opts.timeout || DEFAULT_JOB_TIMEOUT;

        var childlog = self.log.child({job: job});
        var extras = {
            log: childlog
        };

        // create a timer for this job
        var timeout = setTimeout(function () {
            var err = new Error('timeout exceeded');
            childlog.fatal({err: err, timeout: job.timeout},
                'job took longer than %dms', job.timeout);
            throw err;
        }, job.timeout);

        childlog.debug('starting job');
        job.func(extras, function () {
            job.finished_at = new Date();
            var delta = job.finished_at - job.started_at;

            childlog.debug({delta: delta}, 'finished job in %dms', delta);

            // clear the timeout
            clearTimeout(timeout);
            timeout = null;

            cb();
        });
    }, self.workers);
};

Queue.prototype.enqueue = function (opts, cb) {
    var self = this;

    opts.created_at = new Date();

    if (self.paused) {
        self.queued.push({opts: opts, cb: cb});
    } else {
        self.pushTask(opts, cb);
    }
};

// private
Queue.prototype.pushTask = function (opts, cb) {
    var self = this;

    self.queue.push(opts, function() {
        // call the paused callbacks if this is the last job being run
        if (self.queue.concurrency === 0 && self.npending === 0) {
            self.paused = true;
            self.log.debug('queue paused');

            Object.keys(self.pause_callbacks).forEach(function (id) {
                var o = self.pause_callbacks[id];
                self.log.debug({id: id}, 'firing pause callback for %s', id);
                clearTimeout(o.timeout);
                o.cb();
                delete self.pause_callbacks[id];
            });
        }

        // call the user-specified callback if supplied
        if (cb)
            cb();
    });
};

Queue.prototype.pause = function (opts, cb) {
    var self = this;

    assert(!self.paused, 'queue is already paused!');
    assert.object(opts, 'opts');
    assert.number(opts.timeout, 'opts.timeout');
    assert.func(cb, 'cb');

    self.paused = true;

    // short-circuit logic if no job is currently running
    if (self.queue.npending === 0) {
        self.log.debug('queue paused');
        cb();
        return;
    }

    // job(s) running - wait for finish
    var timeout = setTimeout(function () {
        var err = new Error('pause timeout exceeded');
        self.log.fatal({err: err, timeout: opts.timeout},
            'pause took longer than %dms', opts.timeout);
        self.queue.removeListener('drain', ondrain);
        self.queue.resume();
        cb(err);
    }, opts.timeout);

    self.queue.once('drain', ondrain);

    // vasync queue has drained, we can pause
    function ondrain() {
        clearTimeout(timeout);
        cb();
    }
};

Queue.prototype.resume = function () {
    var self = this;

    assert(self.paused, 'queue is not paused!');

    self.paused = false;
    self.log.debug('queue resumed - enqueueing %d tasks', self.queued.length);

    self.queued.forEach(function (o) {
        self.pushTask(o.opts, o.cb);
    });
    self.queued.length = 0;
};

Queue.prototype.fastForward = function (time, opts, cb) {
    var self = this;

    assert(self.paused, 'queue must be paused to fast-forward');
    assert.date(time, 'time');
    assert.object(opts, 'opts');
    assert.number(opts.timeout, 'opts.timeout');
    assert.func(cb, 'cb');

    // loop all queued tasks and dispatch them if they were
    // created before the fast-forward date
    var task;
    var i = 0;
    while ((task = self.queued.shift())) {
        if (task.opts.created_at < time) {
            i++;
            self.pushTask(task.opts, task.cb);
        } else {
            self.queued.unshift(task);
            break;
        }
    }
    self.log.debug('fast-forward pushed %d tasks into queue', i);

    // just callback immediately if no tasks were pushed
    if (i === 0) {
        cb();
        return;
    }

    // job(s) running - wait for finish
    var timeout = setTimeout(function () {
        var err = new Error('fast-forward timeout exceeded');
        self.log.fatal({err: err, timeout: opts.timeout},
            'fast-forward took longer than %dms', opts.timeout);
        self.queue.removeListener('drain', ondrain);
        self.queue.resume();
        cb(err);
    }, opts.timeout);


    self.queue.once('drain', ondrain);

    function ondrain() {
        clearTimeout(timeout);
        cb();
    }
};

Queue.prototype.dump = function () {
    return this.queue;
};
