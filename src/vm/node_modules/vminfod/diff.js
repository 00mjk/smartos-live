/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2015, Joyent, Inc.
 *
 */

function diff(a, b) {
    if (a === b) {
        return ([]);
    } else if (Array.isArray(a) && Array.isArray(b)) {
        return arrayDiff(a, b);
    } else {
        return objDiff(a, b);
    }
}

function objDiff(a, b, opts) {
    var changes = [];

    opts = opts || {};
    var prefix = opts.prefix || [];

    if (a === b)
        return ([]);

    Object.keys(a).forEach(function (key) {
        var p = prefix.slice(0);
        p.push(key);
        var prettyPath = toDotNotation(p);

        // if the key is not in b, it was removed
        if (!hap(b, key)) {
            changes.push({
                prettyPath: prettyPath,
                path: p,
                action: 'removed',
                from: a[key]
            });
            return;
        }

        // if they are the same value we don't do anything
        if (a[key] === b[key])
            return;

        if (typeof (a[key]) === 'object'
            && typeof (b[key]) === 'object') {

            var nest_opts = {
                prefix: p
            };
            var nest_changes;

            if (Array.isArray(a[key]) && Array.isArray(b[key])) {
                nest_changes = arrayDiff(a[key], b[key], nest_opts);
            } else {
                nest_changes = objDiff(a[key], b[key], nest_opts);
            }

            nest_changes.forEach(function (change) {
                changes.push(change);
            });
        } else {
            changes.push({
                prettyPath: prettyPath,
                path: p,
                action: 'changed',
                from: a[key],
                to: b[key]
            });
        }
    });

    Object.keys(b).forEach(function (key) {
        if (hap(a, key))
            return;

        var p = prefix.slice(0);
        p.push(key);
        var prettyPath = toDotNotation(p);

        changes.push({
            prettyPath: prettyPath,
            path: p,
            action: 'added',
            to: b[key]
        });
    });

    return (changes);
}

function arrayDiff(a, b, opts) {
    var changes = [];

    opts = opts || {};
    var prefix = opts.prefix || [];

    if (a === b)
        return ([]);


    a.forEach(function (_, i) {
        var p = prefix.slice(0);
        p.push(i);

        var prettyPath = toDotNotation(p);

        if (b[i] === undefined) {
            changes.push({
                prettyPath: prettyPath,
                path: p,
                action: 'removed',
                from: a[i]
            });
            return;
        }
        if (a[i] === b[i])
            return;

        if (typeof (a[i]) === 'object'
            && typeof (b[i]) === 'object') {

            var nest_opts = {
                prefix: p
            };
            var nest_changes;

            if (Array.isArray(a[i]) && Array.isArray(b[i])) {
                nest_changes = arrayDiff(a[i], b[i], nest_opts);
            } else {
                nest_changes = objDiff(a[i], b[i], nest_opts);
            }

            nest_changes.forEach(function (change) {
                changes.push(change);
            });
        } else {
            changes.push({
                prettyPath: prettyPath,
                path: p,
                action: 'changed',
                from: a[i],
                to: b[i]
            });
        }
    });

    b.forEach(function (_, i) {
        if (a[i] !== undefined)
            return;

        var p = prefix.slice(0);
        p.push(i);
        var prettyPath = toDotNotation(p);

        changes.push({
            prettyPath: prettyPath,
            path: p,
            action: 'added',
            to: b[i]
        });
    });

    return (changes);
}

/*
 * Convert a "path" (given as an array) to a pretty-formatted dot-notation
 * string. This is soley meant for producing a human-readable path in the
 * "changes" array given from any object or array diff.  Examples
 *
 * > toDotNotation(['disks', 0, 'name'])
 * => 'disks.0.name'
 * > toDotNotation(['nics', '192.168.1.1', 'name'])
 * => 'nics[192.168.1.1].name'
 *
 */
function toDotNotation(arr) {
    var s = '';
    arr.forEach(function (elem) {
        elem = '' + elem;
        if (elem.match(/[\.\[\]]/)) {
            elem = elem.replace(/([\[\]])/g, '\\$1');
            s += '[' + elem + ']';
            return;
        }

        if (s.length > 0)
            s += '.';
        s += elem;
    });
    return s;
}

/*
 * safe hasOwnProperty
 */
function hap(o, p) {
    return ({}).hasOwnProperty.call(o, p);
}

module.exports = {
    diff: diff,
    objDiff: objDiff,
    arrayDiff: arrayDiff
};

if (require.main === module) {
    var read = require('fs').readFileSync;
    var _a = JSON.parse(read(process.argv[2]));
    var _b = JSON.parse(read(process.argv[3]));

    console.log(JSON.stringify(diff(_a, _b), null, 2));
}
