/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2017, Joyent, Inc.
 *
 * "diff" 2 JavaScript objects
 *
 * var a = {
 *     foo: true,
 *     num: 1
 * };
 * var b = {
 *     bar: true,
 *     num: 2
 * };
 * var changes = diff(a, b);
 * console.log(changes);
 * [
 *   {
 *     "prettyPath": "foo",
 *     "path": ["foo"],
 *     "action": "removed",
 *     "from": true
 *   },
 *   {
 *     "prettyPath": "num",
 *     "path": ["num"],
 *     "action": "changed",
 *     "from": 1,
 *     "to": 2
 *   },
 *   {
 *     "prettyPath": "bar",
 *     "path": ["bar"],
 *     "action": "added",
 *     "to": true
 *   }
 * ]
 *
 * On top of this basic functionality, this function also supports comparing
 * objects for modifications based on an "identifierKey" supplied in a map.
 *
 * Consider the following two objects.
 *
 * var a = {
 *     disks: [
 *         {
 *             name: "foo",
 *             size: 10
 *         }
 *     ]
 * };
 * var b = {
 *     disks: [
 *         {
 *             name: "foo",
 *             size: 20
 *         }
 *     ]
 * };
 *
 * Looking at these objects, we can see that the "disks" array has a single
 * object with both a name and size - only the size has changed from 10 to 20.
 * Running these objects through diff() without a map yields:
 *
 * var changes = diff(a, b);
 * console.log(changes);
 * [
 *   {
 *     "prettyPath": "disks.*",
 *     "path": [
 *       "disks",
 *       null
 *     ],
 *     "action": "removed",
 *     "from": {
 *       "name": "foo",
 *       "size": 10
 *     }
 *   },
 *   {
 *     "prettyPath": "disks.*",
 *     "path": [
 *       "disks",
 *       null
 *     ],
 *     "action": "added",
 *     "to": {
 *       "name": "foo",
 *       "size": 20
 *     }
 *   }
 * ]
 *
 * Note that `null` in the `path` array means any element of the array, as
 * this module doesn't concern itself with the indices of an array or array
 * sort order.
 *
 * diff() reports that an entire object was removed from the "disks" array
 * and replaced with a new object.  If we know ahead of time that a key
 * (like "disks") is guaranteed to be an array of objects, we can give diff()
 * a "map" where we can specify that "disks" -> "name"... meaning "disks"
 * is an array of objects where "name" is a key that represents a unique
 * identifier for the object.  This way, we can determine if an object
 * was removed completely, or just modified in place.
 *
 * var map = {
 *     disks: 'name'
 * };
 * var changes = diff(a, b, {map: map});
 * console.log(changes);
 * [
 *   {
 *     "prettyPath": "disks.*.size",
 *     "path": [
 *       "disks",
 *       null,
 *       "size"
 *     ],
 *     "action": "changed",
 *     "from": 10,
 *     "to": 20,
 *     "ident": "foo"
 *   }
 * ]
 *
 * With the map supplied, only one change is reported (the size).  The "ident"
 * key shows the value of the identifierKey for the object modified (in this
 * case, the value of the disks "name" attribute).
 *
 * The keys given in the "map" object are only applied to the base object
 * given, meaning an initial object like this won't use the map.
 *
 * var a = {
 *     "root": {
 *         "disks": [
 *             {
 *                 "name": "foo"
 *             }
 *         ]
 *     }
 * };
 *
 * As the base key considered by the map in this example is "root".
 *
 */

var assert = require('/usr/node/node_modules/assert-plus');

function diff(a, b, opts) {
    if (theSameValue(a, b)) {
        return [];
    } else if (Array.isArray(a) && Array.isArray(b)) {
        return arrayDiff.apply(this, arguments);
    } else {
        return objDiff.apply(this, arguments);
    }
}

function objDiff(a, b, opts) {
    opts = opts || {};
    opts.map = opts.map || {};

    var prefix = opts.prefix || [];
    var changes = [];

    if (theSameValue(a, b))
        return [];

    // loop all keys in on the a (from) side
    Object.keys(a).forEach(function (key) {
        var p = prefix.slice(0);
        p.push(key);
        var prettyPath = toDotNotation(p);

        // if the key is not in b, it was removed
        if (!hap(b, key)) {
            changes.push({
                prettyPath: prettyPath,
                path: p,
                action: 'removed',
                from: a[key]
            });
            return;
        }

        // if they are the same value we don't do anything
        if (theSameValue(a[key], b[key]))
            return;

        // if neither are objects, then the value has changed
        if (typeof (a[key]) !== 'object'
            || typeof (b[key]) !== 'object') {

            changes.push({
                prettyPath: prettyPath,
                path: p,
                action: 'changed',
                from: a[key],
                to: b[key]
            });

            return;
        }

        // both values are objects (maybe Array), compare recursively
        var nest_opts = {};
        Object.keys(opts).forEach(function (k) {
            nest_opts[k] = opts[k];
        });
        nest_opts.prefix = p;

        diff(a[key], b[key], nest_opts, key).forEach(function (change) {
            changes.push(change);
        });
    });

    // loop all keys in the b (to) side to find any additions
    Object.keys(b).forEach(function (key) {
        if (hap(a, key))
            return;

        var p = prefix.slice(0);
        p.push(key);
        var prettyPath = toDotNotation(p);

        changes.push({
            prettyPath: prettyPath,
            path: p,
            action: 'added',
            to: b[key]
        });
    });

    return changes;
}

function arrayDiff(a, b, opts, key) {
    opts = opts || {};
    opts.map = opts.map || {};

    var changes = [];

    var prefix = (opts.prefix || []).slice(0);
    prefix.push(null);
    var prettyPath = toDotNotation(prefix);

    // check if we should use the "map" for this array
    var identifierKey;
    if (key && prefix.length === 2 && hap(opts.map, key))
        identifierKey = opts.map[key];

    // serialize everything in a and b to compare directly as strings
    var aSerialized = a.map(function (o) {
        return JSON.stringify(o);
    });
    var bSerialized = b.map(function (o) {
        return JSON.stringify(o);
    });

    // all values in a not found in b have been possibly removed
    var possiblyRemoved = [];
    aSerialized.forEach(function (o, i) {
        if (bSerialized.indexOf(o) >= 0)
            return;

        possiblyRemoved.push(i);
    });

    // all values in b not found in a have been possibly added
    var possiblyAdded = [];
    bSerialized.forEach(function (o, j) {
        if (aSerialized.indexOf(o) >= 0)
            return;

        possiblyAdded.push(j);
    });

    // if an identifierKey is found - meaning the arrays we are looking at
    // were found inside an object with a given "key" (4th arg), we treat
    // every element inside the array as an object, and look for an
    // "identifier" object to compare
    var modified = [];
    if (identifierKey) {
        possiblyRemoved = possiblyRemoved.filter(function (i) {
            var oi = a[i];
            assert.object(oi, 'must be an object: ' + JSON.stringify(oi));
            var found = false;

            possiblyAdded = possiblyAdded.filter(function (j) {
                var oj = b[j];
                assert.object(oi, 'must be an object');
                if (found)
                    return true;

                if (oi[identifierKey] === oj[identifierKey]) {
                    found = true;

                    // to be processed recursively below
                    modified.push({
                        a: oi,
                        b: oj,
                        ident: oi[identifierKey]
                    });
                    return false;
                }

                return true;
            });

            return !found;
        });
    }

    // add the changes to the changes array to be returned
    possiblyRemoved.forEach(function (i) {
        changes.push({
            prettyPath: prettyPath,
            path: prefix,
            action: 'removed',
            from: a[i]
        });
    });
    modified.forEach(function (mod) {
        // the members of this array are guaranteed to be objects
        var _changes = objDiff(mod.a, mod.b, {prefix: prefix});
        _changes.forEach(function (change) {
            change.ident = mod.ident;
            changes.push(change);
        });
    });
    possiblyAdded.forEach(function (j) {
        changes.push({
            prettyPath: prettyPath,
            path: prefix,
            action: 'added',
            to: b[j]
        });
    });

    return changes;
}

/*
 * Check if 2 primitive values are tha same
 */
function theSameValue(a, b) {
    if (a === b)
        return true;

    if (a instanceof Date && b instanceof Date)
        return theSameValue(a.getTime(), b.getTime());

    return false;
}

/*
 * Convert a "path" (given as an array) to a pretty-formatted dot-notation
 * string. This is soley meant for producing a human-readable path in the
 * "changes" array given from any object or array diff.  Examples
 *
 * > toDotNotation(['disks', 0, 'name'])
 * => 'disks.0.name'
 *
 * > toDotNotation(['disks', null, 'name']);
 * => 'disks.*.name'
 *
 * > toDotNotation(['nics', '192.168.1.1', 'name'])
 * => 'nics[192.168.1.1].name'
 *
 */
function toDotNotation(arr) {
    var s = '';
    arr.forEach(function (elem) {
        if (elem === null)
            elem = '*';
        elem = '' + elem;

        if (elem.match(/[\.\[\]]/)) {
            elem = elem.replace(/([\[\]])/g, '\\$1');
            s += '[' + elem + ']';
            return;
        }

        if (s.length > 0)
            s += '.';
        s += elem;
    });
    return s;
}

/*
 * safe hasOwnProperty
 */
function hap(o, p) {
    return ({}).hasOwnProperty.call(o, p);
}

module.exports = diff;

function main() {
    var read = require('fs').readFileSync;
    var a = JSON.parse(read(process.argv[2]));
    var b = JSON.parse(read(process.argv[3]));

    var opts;
    if (process.argv[4])
        opts = JSON.parse(read(process.argv[4]));
    var key = process.argv[5];

    var changes = diff(a, b, opts, key);
    console.log(JSON.stringify(changes, null, 2));
}

if (require.main === module)
    main();
