/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2017, Joyent, Inc.
 *
 * "diff" 2 JavaScript objects
 *
 * var a = {
 *     foo: true,
 *     num: 1
 * };
 * var b = {
 *     bar: true,
 *     num: 2
 * };
 * var changes = diff(a, b);
 * console.log(changes);
 * [
 *   {
 *     "prettyPath": "foo",
 *     "path": ["foo"],
 *     "action": "removed",
 *     "from": true
 *   },
 *   {
 *     "prettyPath": "num",
 *     "path": ["num"],
 *     "action": "changed",
 *     "from": 1,
 *     "to": 2
 *   },
 *   {
 *     "prettyPath": "bar",
 *     "path": ["bar"],
 *     "action": "added",
 *     "to": true
 *   }
 * ]
 *
 */

var assert = require('/usr/node/node_modules/assert-plus.js');

function diff(a, b, opts) {
    if (theSameValue(a, b)) {
        return [];
    } else if (Array.isArray(a) && Array.isArray(b)) {
        return arrayDiff.apply(this, arguments);
    } else {
        return objDiff.apply(this, arguments);
    }
}

function objDiff(a, b, opts) {
    opts = opts || {};
    opts.map = opts.map || {};

    var prefix = opts.prefix || [];
    var changes = [];

    if (theSameValue(a, b))
        return [];

    // loop all keys in on the a (from) side
    Object.keys(a).forEach(function (key) {
        var p = prefix.slice(0);
        p.push(key);
        var prettyPath = toDotNotation(p);

        // if the key is not in b, it was removed
        if (!hap(b, key)) {
            changes.push({
                prettyPath: prettyPath,
                path: p,
                action: 'removed',
                from: a[key]
            });
            return;
        }

        // if they are the same value we don't do anything
        if (theSameValue(a[key], b[key]))
            return;

        // if neither are objects, then the value has changed
        if (typeof (a[key]) !== 'object'
            || typeof (b[key]) !== 'object') {

            changes.push({
                prettyPath: prettyPath,
                path: p,
                action: 'changed',
                from: a[key],
                to: b[key]
            });

            return;
        }

        // both values are objects (maybe Array), compare recursively
        var nest_opts = {};
        Object.keys(opts).forEach(function (k) {
            nest_opts[k] = opts[k];
        });
        nest_opts.prefix = p;

        // let diff() figure out what diff function to use
        diff(a[key], b[key], nest_opts, key).forEach(function (change) {
            changes.push(change);
        });
    });

    // loop all keys in the b (to) side to find any additions
    Object.keys(b).forEach(function (key) {
        if (hap(a, key))
            return;

        var p = prefix.slice(0);
        p.push(key);
        var prettyPath = toDotNotation(p);

        changes.push({
            prettyPath: prettyPath,
            path: p,
            action: 'added',
            to: b[key]
        });
    });

    return changes;
}

function arrayDiff(a, b, opts, key) {
    opts = opts || {};
    opts.map = opts.map || {};

    var changes = [];

    var prefix = (opts.prefix || []).slice(0);
    prefix.push(null);
    var prettyPath = toDotNotation(prefix);

    var identifierKey;
    if (key && prefix.length === 2 && hap(opts.map, key))
        identifierKey = opts.map[key];

    // serialize everything in a and b to compare directly
    var aSerialized = a.map(function (o) {
        return JSON.stringify(o);
    });
    var bSerialized = b.map(function (o) {
        return JSON.stringify(o);
    });

    // all valuse in a not found in b have been possibly removed
    var possiblyRemoved = [];
    aSerialized.forEach(function (o, i) {
        if (bSerialized.indexOf(o) >= 0)
            return;

        possiblyRemoved.push(i);
    });

    // all valuse in b not found in a have been possibly added
    var possiblyAdded = [];
    bSerialized.forEach(function (o, j) {
        if (aSerialized.indexOf(o) >= 0)
            return;

        possiblyAdded.push(j);
    });

    // if an identifierKey is found - meaning the arrays we are looking at
    // were found inside an object with a given "key" (4th arg), we treat
    // every element inside the array as an object, and look for an
    // "identifier" object to compare
    var modified = [];
    if (identifierKey) {
        possiblyRemoved = possiblyRemoved.filter(function (i) {
            var oi = a[i];
            assert.object(oi, 'must be an object: ' + JSON.stringify(oi));
            var found = false;

            possiblyAdded = possiblyAdded.filter(function (j) {
                var oj = b[j];
                assert.object(oi, 'must be an object');
                if (found)
                    return true;

                if (oi[identifierKey] === oj[identifierKey]) {
                    found = true;
                    modified.push([oi, oj]);
                    return false;
                }

                return true;
            });

            return !found;
        });
    }

    // add the changes to the changes array to be returned
    possiblyRemoved.forEach(function (i) {
        changes.push({
            prettyPath: prettyPath,
            path: prefix,
            action: 'removed',
            from: a[i]
        });
    });
    modified.forEach(function (mod) {
        // the members of this array are guaranteed to be objects
        var _changes = objDiff(mod[0], mod[1], {prefix: prefix});
        changes = changes.concat(_changes);
    });
    possiblyAdded.forEach(function (j) {
        changes.push({
            prettyPath: prettyPath,
            path: prefix,
            action: 'added',
            to: b[j]
        });
    });

    return changes;
}

/*
 * Check if 2 primitive values are tha same
 */
function theSameValue(a, b) {
    if (a === b)
        return true;

    if (a instanceof Date && b instanceof Date)
        return theSameValue(a.getTime(), b.getTime());

    return false;
}

/*
 * Convert a "path" (given as an array) to a pretty-formatted dot-notation
 * string. This is soley meant for producing a human-readable path in the
 * "changes" array given from any object or array diff.  Examples
 *
 * > toDotNotation(['disks', 0, 'name'])
 * => 'disks.0.name'
 * > toDotNotation(['nics', '192.168.1.1', 'name'])
 * => 'nics[192.168.1.1].name'
 *
 */
function toDotNotation(arr) {
    var s = '';
    arr.forEach(function (elem) {
        if (elem === null)
            elem = '*';
        elem = '' + elem;

        if (elem.match(/[\.\[\]]/)) {
            elem = elem.replace(/([\[\]])/g, '\\$1');
            s += '[' + elem + ']';
            return;
        }

        if (s.length > 0)
            s += '.';
        s += elem;
    });
    return s;
}

/*
 * safe hasOwnProperty
 */
function hap(o, p) {
    return ({}).hasOwnProperty.call(o, p);
}

module.exports = diff;

function main() {
    var read = require('fs').readFileSync;
    var a = JSON.parse(read(process.argv[2]));
    var b = JSON.parse(read(process.argv[3]));

    var opts;
    if (process.argv[4])
        opts = JSON.parse(read(process.argv[4]));
    var key = process.argv[5];

    var changes = diff(a, b, opts, key);
    console.log(JSON.stringify(changes, null, 2));
}

if (require.main === module)
    main();
