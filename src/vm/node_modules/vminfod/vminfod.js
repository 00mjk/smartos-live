/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2017 Joyent, Inc.
 *
 */

/*
 * The primary function of this module is to mantain an up-to-date copy of:
 *
 *   1) the complete vmobj list
 *   2) a vmload cache object.
 *
 * The vmload cache object will be maintained internally by this daemon while
 * the vmobj list can be consumed from the HTTP interface:
 *
 *   - The complete vm list can be consumed at GET /vms
 *   - A single vm can be consumed at GET /vms/UUID
 *
 * To use the daemon, you should do something like:
 *
 *  var vminfod = new Vminfod({log: log});
 *  vminfod.start([callback]);
 *  vminfod.stop([callback]);
 *  vminfod.on(<event type>, callback(data));
 *
 * Where the event types can be:
 *
 *  ready - emitted when vminfo has initialized after start()
 *  end - emitted when vminfo has shutdown after stop()
 *  create - emitted when a new vm is created
 *  modify - emitted when an existing vm is modified
 *  delete - emitted when an existing vm is deleted
 *
 * on 'ready' the callback will be called, passing the list of vmobjs as the
 * first and only argument.
 *
 * on 'end' the callback will be called, without any arguments
 *
 * on 'create' the callback will be called, passing the newly created vmobj as
 * the first and only argument.
 *
 * on 'modify' the callback will be called, passing the updated vmobj as the
 * first argument, and a list of changes as the second argument.
 *
 * on 'delete' the callback will be called, passing the zonename of the vmobj
 * as the first and only argument.
 *
 * Note: The main consumer of this module will be the daemon
 * /usr/vm/sbin/vminfod, found under the SMF service
 * system-smartdc-vminfod:default.
 *
 * To query this daemon as a client however, use the vminfod/client.js library.
 *
 * As a client, Events can be consumed through the webservice at GET /events.
 * The client connection will be held open until the client explicitly closes
 * the socket. Events will be streamed to the client in http chunks as
 * newline-separated-JSON where each event will be a JSON object. When
 * unwrapped, the 'type' attribute will indicate the event type. All relevant
 * data to the event will be included in the JSON object.
 *
 * How this daemon works:
 *
 *   The tl;dr overview is that this module will listen for events within 3
 *   broad categories: zone state, zone config files, and zfs datasets.
 *   When an event is fired, we will delete portions of the cache object that
 *   are relevant to the event, then ask vmload to fill in the holes with
 *   getZoneData, which we can then update the vmobjs that were affected
 *   by the change, and lastly inform any subscribed consumers of the specific
 *   changes to the vmobj data.
 *
 *   This module is not necessarily concerned with the details of a vmobj -
 *   meaning, the structure of the vmobj, where the data is derived, and how
 *   the data is transformed are not the concern of this module. This module
 *   will delegate that responsibility to the vmload modules. This module is
 *   concerned with knowing when pieces of the cache object are likely
 *   out-of-date, how to re-populate those pieces, and which vmobjs will be
 *   affected by the change.
 *
 *   The one execption to this rule is the vmobj.last_modified key.  This key
 *   is updated to the current timestamp whenever any other field in the vmobj
 *   has changed.  Also, any change to 'last_modified" will be done silently,
 *   and not be reported on the /events stream.  This way, the 'last_modified'
 *   property of any vm will always be set and will reflect the last time
 *   vminfod has seen any modifications to the vm.
 *
 *   There a 3 broad event categories that are monitored via 2 event sources to
 *   determine if a change has happened on a machine that *may* result in the
 *   creation, modification, or deletion of a vm.
 *
 *     1. Sysevents (using sysevent-stream.js)
 *
 *       A. zpool-watcher.js: watches ZFS sysevents for dataset modifications
 *       B. zone-watcher.js: watches zone sysevents for zone modifications
 *
 *     2. File System Events (via event ports using fswatcher.js)
 *     Each VM has 5 files that are watched for modifications
 *
 *       1. /etc/zones/<uuid>.xml
 *       2. /zones/<uuid>/lastexited
 *       3. /zones/<uuid>/config/tags.json
 *       4. /zones/<uuid>/config/routes.json
 *       5. /zones/<uuid>/config/metadata.json
 *
 *   At a routine interval, we will also force-refresh the cache and regenerate
 *   the vmobj sets to ensure data integrity. When the refresh interval is
 *   fired, we will first pause the event queue, then request a new cache
 *   object. Once we have received a new cache object, we will "fastForward"
 *   the queue to the current time, performing all modifications to our current
 *   cache, as well as the new cache object received from the full load.  This
 *   way, any events seen while the cacehe was being fully loaded from the
 *   system will be accounted for in both objects (to eliminate any sort of
 *   race). We will replace the current cache object with the new one if the
 *   two cache objects are different.
 *
 *   Only if the two objects are different, we will iterate through all vmobjs
 *   and generate a new vmobj from the new cache and report any deltas along the
 *   way. Finally, after all vmobjs have been updated, we will resume the queue.
 *
 *   A new vmobj is created when a zone event is received for a uuid that we're
 *   not currently watching, which will then register observers for relevant
 *   config files.
 *
 *   A vmobj is removed when the watched /etc/zones/<uuid>.xml receives the
 *   DELETE event. At this point, we will also remove all watchers that were
 *   setup for that vmobj.
 *
 */

var EventEmitter = require('events').EventEmitter;
var http = require('http');
var path = require('path');
var url = require('url');
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var diff = require('/usr/vm/node_modules/diff');
var getDatasets = require('/usr/vm/node_modules/vmload/vmload-datasets').
    getDatasets;
var getZoneRecords = require('/usr/vm/node_modules/vmload/vmload-zoneadm').
    getZoneRecords;
var hrtime = require('/usr/vm/node_modules/hrtime');
var libuuid = require('/usr/node/node_modules/uuid');
var vasync = require('/usr/vm/node_modules/vasync');
var vmload = require('/usr/vm/node_modules/vmload');

var FsWatcher = require('/usr/vm/node_modules/fswatcher').FsWatcher;
var Queue = require('/usr/vm/node_modules//queue').Queue;
var RingBuffer = require('/usr/vm/node_modules/bunyan').RingBuffer;
var ZoneWatcher = require('./zonewatcher').ZoneWatcher;
var ZpoolWatcher = require('./zpoolwatcher').ZpoolWatcher;

/*
 * Files in /zones/<uuid>/config to watch
 */
var CONFIG_FILES = [
    'metadata.json',
    'routes.json',
    'tags.json'
];

/*
 * The keys of this map (ie. "disks" and "nics") are keys to a VM's JSON
 * payload that are:
 * 1: Guaranteed to be arrays of objects (this is asserted and will throw
 * if not true)
 *
 * The values (ie. "path" and "mac" respectively) are keys inside tho objects
 * inside the array that are used as the unique identifiers.  This helps
 * diff.js determine what kind of changes are made to an object.
 */
var DIFF_MAP = {
    disks: 'path',
    nics: 'mac'
};

/*
 * Default job timeout for the queue.  Each task enqueued will have 1 minute
 * from the time it starts to finish processing.  On average, most tasks
 * take less than 1 second - this is just a kill switch for a hanging task.
 */
var QUEUE_TASK_TIMEOUT = 1 * 60 * 1000;

/*
 * Default number of records to store for refresh errors and log messages.
 */
var DEFAULT_REFRESH_RECORDS = 5;

/*
 * Default zpool for zones
 */
var ZONES_ZPOOL = 'zones';

module.exports = Vminfod;
function Vminfod(options) {
    var self = this;

    // global state/status - these are used primarily for debugging purposes
    // and should be modified with the setState/setStatus functions
    self.state = 'stopped';
    self.status = 'initialized';

    // consumers of the '/events' stream
    self.events_listeners = {};

    /*
     * Structures to hold the raw data.
     *
     * The _tmp variants are used while the queue is paused and a full system
     * refresh is being performed.  The full system refresh data will be stored
     * in these variables, and then compared to the live data at the end of the
     * refresh.  We store these globally so they can be modified during the
     * queue fastForward portion of the "reset".
     */
    self.vm_data = {};
    self.vm_data_tmp = undefined;
    self.zone_vm_data = {};
    self.zone_vm_data_tmp = {};

    // the actual vmobjs held in memory
    self.vmobjs = {};

    // structures to hold the pre-serialized data - these are managed by the
    // serialize* functions
    self.vm_data_json = {};
    self.vmobjs_json = {};

    // configurable options
    self.log = options.log;
    assert(self.log, 'must provide a logger');
    assert.optionalNumber(options.port, 'options.port');
    assert.optionalArrayOfString(options.ips, 'options.ips');
    assert.optionalNumber(options.refresh_interval, 'options.refresh_interval');

    // set default ips and port
    self.ips = options.ips || ['127.0.0.1'];
    self.port = options.port || 9090;

    // set default refresh interval for the periodic_timer
    self.refresh_interval = options.refresh_interval || (5 * 60 * 1000);

    /*
     * Keep a log of every time self.reset() finds differences from what is on
     * the system and what is in vminfod.
     */
    self.refresh_log = new RingBuffer({limit: DEFAULT_REFRESH_RECORDS});

    /*
     * Sometimes, self.reset() can fail but we don't necessarily want to kill
     * the process. Instead, store the errors in a log and expose them over
     * /status.
     */
    self.refresh_errors = new RingBuffer({limit: DEFAULT_REFRESH_RECORDS});

    /*
     * We need to create intermediate event listeners between self and
     * clients subscribed to /events so we only have to JSON.stringify
     * once per event, instead of once per client per event.
     */
    self.on('create', function (vmobj) {
        var data;
        var json;

        data = {
            type: 'create',
            date: new Date(),
            zonename: vmobj.zonename,
            uuid: vmobj.uuid,
            vm: vmobj
        };

        self.log.info({ev: data}, 'emitting "create" event, %d VMs total',
            Object.keys(self.vmobjs).length);

        json = JSON.stringify(data);

        self.emit('create-json', json);
    });

    self.on('modify', function (vmobj, changes) {
        var data;
        var json;

        data = {
            type: 'modify',
            date: new Date(),
            zonename: vmobj.zonename,
            uuid: vmobj.uuid,
            vm: vmobj,
            changes: changes
        };

        self.log.info({ev: data}, 'emitting "modify" event, %d VMs total',
            Object.keys(self.vmobjs).length);

        json = JSON.stringify(data);

        self.emit('modify-json', json);
    });

    self.on('delete', function (vmobj) {
        var data;
        var json;

        data = {
            type: 'delete',
            date: new Date(),
            zonename: vmobj.zonename,
            uuid: vmobj.uuid
        };

        self.log.info({ev: data}, 'emitting "delete" event, %d VMs total',
            Object.keys(self.vmobjs).length);

        json = JSON.stringify(data);

        self.emit('delete-json', json);
    });
}
util.inherits(Vminfod, EventEmitter);

/*
 * Set the internal state value
 *
 * This, and setStatus below, are useful for tracking what vminfod is currently
 * processing (or at least, what it shoud be).  These internal variables can
 * be accessed over the GET /status interface, and each variable transition
 * can be seen in the log file.
 */
Vminfod.prototype.setState = function (/* args */) {
    var self = this;

    var state = util.format.apply(this, arguments);

    self.log.debug({
        oldstate: self.state,
        newstate: state
    }, 'state changed from "%s" to "%s"', self.state, state);

    self.state = state;
};

/*
 * Set the internal status value, see setState for more information
 */
Vminfod.prototype.setStatus = function (/* args */) {
    var self = this;

    var status = util.format.apply(this, arguments);

    self.log.debug({
        oldstatus: self.status,
        newstatus: status
    }, 'status changed from "%s" to "%s"', self.status, status);

    self.status = status;
};

/*
 * start vminfod
 */
Vminfod.prototype.start = function (callback) {
    var self = this;

    var started = process.hrtime();
    self.log.info('vminfod starting');

    vasync.pipeline({funcs: [
        // update state
        function (_, cb) {
            self.setState('booting');
            cb();
        },
        // init queue
        function (_, cb) {
            self.setStatus('initializing event queue');
            var opts = {
                workers: 1,
                paused: true,
                dedup: true,
                log: self.log
            };
            self.event_queue = new Queue(opts);
            cb();
        },
        // start global watchers
        function (_, cb) {
            self.setStatus('starting global watchers');
            self.startWatchers(cb);
        },
        // start vm watchers
        function (_, cb) {
            self.setStatus('starting vm watchers');
            self.startVmWatchers(cb);
        },
        // set vm_data
        function (_, cb) {
            self.setStatus('setting initial cache data');
            self.setVmData(cb);
        },
        // set vmobjs data
        function (_, cb) {
            self.setStatus('setting initial vmobjs data');
            self.setVmobjs(cb);
        },
        // resume queue
        function (_, cb) {
            self.setStatus('resuming the event queue');
            self.event_queue.resume();
            cb();
        },
        // start http server
        function (_, cb) {
            self.setStatus('starting http server');
            self.startHTTPHandlers(cb);
        },
        // start refresh timers
        function (_, cb) {
            self.setStatus('starting refresh timers');
            self.startTimers(cb);
        }
    ]}, function (err) {
        var delta = process.hrtime(started);
        var prettyDelta = hrtime.prettyHrtime(delta);

        if (err) {
            self.log.error('failed to complete boot sequence');
            throw err;
        }

        self.setState('running');
        self.setStatus('working');
        self.log.info('boot sequence complete, took %s', prettyDelta);
        self.emit('ready', self.vmobjs);

        if (callback) {
            callback();
        }
    });
};

/*
 * setVmobjs() sets the initial vmobjs data
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will request vmobjs from vmload.getVmobjs, using the cache
 * object set in vm_cache. The result will then be converted from an array
 * into a hash where the key is the vm uuid and the value is the vmobj.
 *
 * called by .start()
 *
 */
Vminfod.prototype.setVmobjs = function setVmobjs(callback) {
    var self = this;

    var opts = {
        cache: self.vm_data,
        log: self.log,
        keepalive: true,
        loadManually: true
    };
    vmload.getVmobjs(function (_, cb) {
        cb(null, true);
    }, opts, function (err, results) {
        var i = 0;

        if (err) {
            self.log.error({err: err}, 'failed to vmload.getVmobjs: %s',
                err.message);
            callback(err);
            return;
        }

        self.vmobjs = {};
        results.forEach(function (vmobj) {
            i++;
            self.vmobjs[vmobj.zonename] = vmobj;
        });

        self.log.debug('setVmobjs %d VMs found', i);
        callback();
    });
};

/*
 * setVmData() sets the initial vm_data
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will request a cache object from _loadVmData and set
 * vm_data
 *
 */
Vminfod.prototype.setVmData = function setVmData(callback) {
    var self = this;

    self._loadVmData(function (err, cache) {
        if (err) {
            self.log.error('failed to set initial vm_data');
            callback(err);
            return;
        }
        self.log.debug('setting initial vm_data: %j', cache);
        self.vm_data = cache;
        callback();
    });
};

/*
 * Start any and all periodic timers needed by vminfod
 *
 * called by .start()
 */
Vminfod.prototype.startTimers = function startTimers(callback) {
    var self = this;

    assert(!self.periodic_timeout, 'timers already started');

    function make_timer(cb) {
        self.periodic_timeout = setTimeout(function () {
            self.log.info('preparing to refresh data');

            self.reset(function (err) {
                if (err) {
                    self.refresh_errors.write({
                        err: err,
                        time: process.hrtime()
                    });
                    self.log.error({err: err}, 'failed to refresh data');
                }
                make_timer();
            });
        }, self.refresh_interval);

        if (cb) {
            cb();
        }
    }

    make_timer(callback);
};

/*
 * startWatchers() starts global watchers
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will:
 *   1) Create a FsWatcher object
 *   2) Watch for changes to /tmp/.sysinfo.json
 *   3) Create a ZoneWatcher
 *   4) Create a ZpoolWatcher
 */
Vminfod.prototype.startWatchers = function startWatchers(callback) {
    var self = this;

    vasync.pipeline({funcs: [
        function (_, cb) {
            self.fsw = new FsWatcher({log: self.log, dedup: true});

            self.fsw.on('event', function (obj) {
                self.handleFsEvent(obj);
            });

            self.fsw.once('ready', function (obj) {
                self.log.debug('filesystem watcher ready');
                cb();
            });

            self.fsw.start();
        }, function (_, cb) {
            self.fsw.watch('/tmp/.sysinfo.json', cb);
        }, function (_, cb) {
            self.zonew = new ZoneWatcher({log: self.log});

            self.zonew.on('event', function (obj) {
                self.handleZoneEvent(obj);
            });

            self.zonew.once('ready', function () {
                self.log.debug('zone watcher ready');
                cb();
            });
        }, function (_, cb) {
            self.zpoolw = new ZpoolWatcher({log: self.log});

            self.zpoolw.on('event', function (obj) {
                self.handleZpoolEvent(obj);
            });

            self.zpoolw.once('ready', function () {
                self.log.debug('zpool watcher ready');
                cb();
            });
        }
    ]}, function () {
        self.log.info('global watchers ready');
        callback();
    });
};

/*
 * startVmWatchers() starts the watchers for a VM
 *
 * Arguments:
 *   'zonename' - a specific vm zonename to start watchers on
 *   'callback' - will be called with (err)
 *
 *   'zonename' argument is optional, and when omitted will start watchers
 *   for all vms.
 */
Vminfod.prototype.startVmWatchers =
    function startVmWatchers(zonename, callback) {

    var self = this;

    if (typeof (zonename) === 'function') {
        callback = zonename;
        zonename = undefined;
    }

    // start watchers for a single VM
    if (zonename) {
        addVMFsWatches(zonename, callback);
        return;
    }

    // start watchers for all VMs - since this function is ran before
    // any cached data is gathered, we must gather the list of vms manually
    var records;
    vasync.pipeline({funcs: [
        // load zone records
        function (_, cb) {
            var opts = {
                log: self.log
            };
            getZoneRecords(null, opts, function (err, _records) {
                if (err) {
                    self.log.debug({err: err}, 'failed to load zone records');
                    cb(err);
                    return;
                }

                records = _records;
                cb();
            });
        },
        // start watchers
        function (_, cb) {
            vasync.forEachPipeline({
                func: function (uuid, cb2) {
                    addVMFsWatches(records[uuid].zonename, cb2);
                },
                inputs: Object.keys(records)
            }, function (err, results) {
                cb(err);
            });
        }
    ]}, function (err) {
        if (err) {
            self.log.error({err: err}, 'failed to start vm watchers');
            callback(err);
            return;
        }

        callback();
    });


    /*
     * create fs watches for a given zone
     */
    function addVMFsWatches(zone, cb) {
        var files = [
            util.format('/etc/zones/%s.xml', zone),
            util.format('/zones/%s/lastexited', zone)
        ];
        CONFIG_FILES.forEach(function (f) {
            files.push(util.format('/zones/%s/config/%s', zone, f));
        });

        self.log.debug({files: files}, 'adding vm fs watchers for %s',
            zone);

        vasync.forEachPipeline({
            func: function (f, cb2) {
                self.fsw.watch(f, cb2);
            },
            inputs: files
        }, function (err, results) {
            self.log.debug({err: err},
                'finished adding vm fs watchers for %s', zone);
            cb(err);
        });
    }
};


/*
 * Start the HTTP interface
 *
 * called by .start()
 */
Vminfod.prototype.startHTTPHandlers = function startHTTPHandlers(callback) {
    var self = this;

    vasync.forEachPipeline({
        inputs: self.ips,
        func: function (ip, cb) {
            http.createServer(handler).listen(self.port, ip, function () {
                self.log.debug('listening on http://%s:%d', ip, self.port);
                cb();
            });
        }
    }, callback);

    // http handler
    function handler(req, res) {
        var args;
        var c;
        var url_parts;

        url_parts = url.parse(req.url, true);
        c = path.normalize(url_parts.pathname).split('/');
        c.shift();

        args = url_parts.query || {};
        self.log.info({req: req}, 'HTTP request');

        if (req.method !== 'GET') {
            // Bad request
            res.writeHead(400, {'Content-Type': 'application/json'});
            res.end();
        } else {
            handleGet(c, args, req, res);
        }
    }

    // handler specifically for GET requests
    function handleGet(c, args, req, res) {
        var ret;
        var obj;
        var uuid;

        switch (c[0]) {
        case 'ping':
            ret = {
                ping: 'pong'
            };
            res.writeHead(200, {'Content-Type': 'application/json'});
            res.end(JSON.stringify(ret), 'utf-8');
            break;
        case 'status':
            ret = {
                pid: process.pid,
                uptime: process.uptime(),
                memory: process.memoryUsage(),
                state: self.state,
                status: self.status,
                numVms: Object.keys(self.vmobjs).length,
                curDate: new Date(),
                curTime: hrtime.hrtimeToString(process.hrtime()),
                queue: self.event_queue.dump(),
                refresh_errors:
                    formatRefreshErrors(self.refresh_errors.records),
                events_listeners: formatEventsListeners(self.events_listeners)
            };
            if (args.full) {
                ret.refresh_log = formatRefreshLog(self.refresh_log.records);
                ret.fswatcher = self.fsw.dump();
            }
            res.writeHead(200, {'Content-Type': 'application/json'});
            res.end(JSON.stringify(ret), 'utf-8');
            break;
        case 'vms':
            var zonename = c[1];

            if (zonename) {
                // requesting a vmobj with zonename
                if (!self.vmobjs.hasOwnProperty(zonename)) {
                    res.writeHead(404, {'Content-Type': 'application/json'});
                    res.write('VM Not Found: ' + zonename);
                    res.end();
                } else {
                    res.writeHead(200, {'Content-Type': 'application/json'});
                    res.end(self.serializeVm(zonename), 'utf-8');
                }
                break;
            }

            // requesting the vmobj list
            res.writeHead(200, {'Content-Type': 'application/json'});
            res.end(self.serializeVms(), 'utf-8');
            break;
        case 'events':
            uuid = libuuid.create();
            obj = {
                // currently vminfod listens on localhost only so
                // the ip addresses are always the same
                // ip: request.connection.remoteAddress,
                userAgent: req.headers['user-agent'],
                createdDate: new Date(),
                createdTime: process.hrtime()
            };
            self.log.debug({uuid: uuid, obj: obj},
                'new /events listener created');

            res.writeHead(200, {'Content-Type': 'application/json'});

            var on_create = function (json) {
                res.write(json + '\n');
            };
            var on_modify = function (json) {
                res.write(json + '\n');
            };
            var on_delete = function (json) {
                res.write(json + '\n');
            };
            var on_close = function () {
                res.end();
                cleanup();
            };

            function cleanup() {
                self.log.debug({uuid: uuid, obj: obj},
                    '/events listener removed');
                self.removeListener('create-json', on_create);
                self.removeListener('modify-json', on_modify);
                self.removeListener('delete-json', on_delete);
                self.removeListener('close', on_close);
                delete self.events_listeners[uuid];
            }

            self.on('create-json', on_create);
            self.on('modify-json', on_modify);
            self.on('delete-json', on_delete);
            self.on('close', on_close);
            self.events_listeners[uuid] = obj;

            res.on('close', cleanup);

            // let this client stay open forever
            res.connection.setTimeout(0);

            // let the client know it is subscribed
            res.write(JSON.stringify({
                type: 'ready',
                date: obj.createdDate,
                uuid: uuid,
                vms: self.serializeVms()
            }) + '\n');
            break;
        default:
            res.writeHead(404, {'Content-Type': 'application/json'});
            res.write('Unsupported URL Path');
            res.end();
            break;
        }
    }
};

/*
 * Stop the vminfod daemon
 */
Vminfod.prototype.stop = function stop(callback) {
    var self = this;

    self.zonew.stop();
    self.zpoolw.stop();

    if (self.periodic_timer) {
        clearTimeout(self.periodic_timer);
        self.periodic_timer = null;
    }

    self.fsw.stop(function fswStopped() {
        self.emit('end');

        if (callback) {
            callback();
        }
    });
};


/*
 * stopVmWatchers() stops the watchers for a VM
 *
 * Arguments:
 *   'zonename' - a specific vm zonename to stop watchers on
 *   'callback' - will be called with (err)
 *
 *   'zonename' argument is optional, and when omitted will stop watchers
 *   for all vms.
 */
Vminfod.prototype.stopVmWatchers = function stopVmWatchers(zonename, callback) {
    var self = this;

    if (typeof (zonename) === 'function') {
        callback = zonename;
        zonename = undefined;
    }

    // stop watchers for a single VM
    if (zonename) {
        removeVMFsWatches(zonename, callback);
        return;
    }

    // stop watchers for all VMs
    vasync.forEachPipeline({
        func: removeVMFsWatches,
        inputs: Object.keys(self.vmobjs)
    }, function (err, results) {
        callback(err);
    });

    /*
     * remove fs watches for a given zone
     */
    function removeVMFsWatches(zone, cb) {
        var files = [
            util.format('/etc/zones/%s.xml', zone),
            util.format('/zones/%s/lastexited', zone)
        ];
        CONFIG_FILES.forEach(function (f) {
            files.push(util.format('/zones/%s/config/%s', zone, f));
        });

        self.log.debug({files: files}, 'removing vm fs watchers for %s',
            zone);

        vasync.forEachPipeline({
            func: function (f, cb2) {
                self.fsw.unwatch(f, cb2);
            },
            inputs: files
        }, function (err, results) {
            self.log.debug({err: err},
                'finished removing vm fs watchers for %s', zone);
            cb(err);
        });
    }
};

/*
 * Return a JSON serialized string for a given vm.  This will return
 * a cached object, or generate the contents and cache the result.
 *
 * Returns undefined if the vm is not found
 */
Vminfod.prototype.serializeVm = function serializeVm(zonename) {
    var self = this;

    if (!self.vmobjs_json.hasOwnProperty(zonename)) {
        self.vmobjs_json[zonename] = JSON.stringify(self.vmobjs[zonename]);
    }

    return self.vmobjs_json[zonename];
};

/*
 * Return a JSON serialized string for all zones.
 */
Vminfod.prototype.serializeVms = function serializeVms() {
    var self = this;

    var json = '[';
    var zones = Object.keys(self.vmobjs);

    zones.forEach(function (zone, index) {
        json += self.serializeVm(zone);

        if (index < zones.length - 1) {
            json += ',';
        }
    });

    json += ']';

    return json;
};

/*
 * reset() hard reset the data to ensure integrity
 *
 * This function will:
 *   1- pause the event queue
 *   2- fetch new vm_data
 *   3- fast-forward the event queue
 *   4- compare datasets
 *   5- replace vm_data with vm_data_tmp if the sets are different
 *   6- refresh vmobjs if the sets are different
 *   7- resume the event queue
 */
Vminfod.prototype.reset = function reset(callback) {
    var self = this;

    var old_vm_data;
    var obj = {
        started: process.hrtime()
    };
    vasync.pipeline({funcs: [
        // pause the queue
        function (_, cb) {
            self.setState('paused');
            self.setStatus('pausing the event queue');
            self.log.debug('%d VMs total', Object.keys(self.vmobjs).length);

            self.event_queue.pause({timeout: 5 * 60 * 1000},
                function (err) {

                if (err) {
                    self.log.warn('failed to pause the queue: %s',
                        err.message);
                    cb(err);
                    return;
                }

                cb();
            });
        },
        // fetch new data
        function (_, cb) {
            self.setStatus('fetching vm cache data');
            self._loadVmData(function (err, results) {
                if (err) {
                    self.log.error('failed to fetch new vm_data');
                    cb(err);
                    return;
                }

                self.vm_data_tmp = results;
                cb();
            });
        },
        // fast-forward the queue
        function (_, cb) {
            var now = process.hrtime();
            self.setStatus('fast-forwarding the queue to %j', now);
            self.event_queue.fastForward(now, {timeout: 5 * 60 * 1000},
                function (err) {

                if (err) {
                    self.log.warn('failed to fast-forward queue: %s',
                        err.message);
                    cb(err);
                    return;
                }

                cb();
            });
        },
        // compare/update vmobjs
        function (_, cb) {
            self.setStatus('comparing vmobj sets');

            var changes = diff(self.vm_data, self.vm_data_tmp);

            // filter out "last_modified" since we handle this ourselves
            changes = changes.filter(function (change) {
                return change.path[0] !== 'last_modified';
            });

            // if changes are empty, we have nothing left to do
            if (changes.length === 0) {
                self.log.info('vmobj sets are in sync');
                cb();
                return;
            }

            self.log.warn({changes: changes}, 'vm_data and vm_data_tmp diff');

            obj.changes = changes;

            self.setStatus('synchronizing data');

            // keep a temporary reference to compare against
            old_vm_data = self.vm_data;

            // replace the data with new
            self.vm_data = self.vm_data_tmp;

            vasync.pipeline({funcs: [
                // create vmobjs we don't know about
                function (__, cb2) {
                    var new_objs = self.vm_data.zoneadm_objects;
                    var keys = Object.keys(new_objs);

                    vasync.forEachParallel({
                        inputs: keys,
                        func: function (zonename, cb3) {
                            var old_objs = old_vm_data.zoneadm_objects;
                            if (old_objs.hasOwnProperty(zonename)) {
                                cb3();
                                return;
                            }

                            self.createVmobj(zonename, cb3);
                        }
                    }, cb2);
                },
                // delete vmobjs we shouldn't know about
                function (__, cb2) {
                    var old_objs = old_vm_data.zoneadm_objects;
                    var keys = Object.keys(old_objs);

                    vasync.forEachParallel({
                        inputs: keys,
                        func: function (zonename, cb3) {
                            var new_objs = self.vm_data.zoneadm_objects;
                            if (new_objs.hasOwnProperty(zonename)) {
                                cb3();
                                return;
                            }

                            self.deleteVmobj(zonename, cb3);
                        }
                    }, cb);
                },
                // refresh the rest
                function (__, cb2) {
                    vasync.forEachParallel({
                        inputs: Object.keys(self.vmobjs),
                        func: function (zone, cb3) {
                            self.refreshVmobj(zone, cb3);
                        }
                    }, cb2);
                }
            ]}, cb);
        }
    ]}, function (err) {
        // always make sure vminfod goes back to a running state
        self.setState('running');
        self.setStatus('working');
        self.vm_data_tmp = undefined;

        var ended = process.hrtime();
        var delta = hrtime.hrtimeDelta(ended, obj.started);
        var prettyDelta = hrtime.prettyHrtime(delta);

        self.log.debug('self.reset() took %s', prettyDelta);

        self.log.info('resuming the event queue');
        self.event_queue.resume();

        if (obj.changes) {
            obj.ended = ended;
            obj.delta = delta;
            obj.prettyDelta = prettyDelta;
            self.refresh_log.write(obj);
        }

        callback(err);
    });
};

/*
 * loadVmData() loads a cache object from vmload.getZoneData
 *
 * Arguments:
 *   'callback' - will be called with (err, cache)
 *
 * This function will load a cache object from vmload.getZoneData
 * passing a nocache: true flag to ensure the cache object is generated
 * from raw data.
 *
 */
Vminfod.prototype._loadVmData = function _loadVmData(callback) {
    var self = this;

    var opts = {
        log: self.log,
        nocache: true,
        keepalive: true
    };
    vmload.getZoneData(null, opts, function (err, cache) {
        if (err) {
            self.log.error({err: err}, 'failed vmload.getZoneData: %s',
                err.message);
            callback(err);
            return;
        }

        callback(null, cache);
    });
};

/*
 * Called when a new VM is seen
 *
 * This will create all internal variables needed for the VM, as well as
 * emit a "create" event
 */
Vminfod.prototype.createVmobj = function createVmobj(zonename, callback) {
    var self = this;

    var uuid;

    if (self.vmobjs.hasOwnProperty(zonename)) {
        self.log.warn('createVmobj(%s) called for zone already known about',
            zonename);
        callback();
        return;
    }

    vasync.pipeline({funcs: [
        function (_, cb) {
            /*
             * Figure out the zone UUID from the zonename seen.  If the
             * zonename is a UUID, assume that it is the zones UUID and skip
             * the call to getZoneRecords.
             */
            if (isUUID(zonename)) {
                uuid = zonename;
                cb();
                return;
            }

            var opts = {
                log: self.log
            };
            getZoneRecords(zonename, opts, function (err, records) {
                if (err) {
                    self.log.debug({err: err}, 'failed to getZoneRecords(%s)',
                        zonename);
                    cb(err);
                    return;
                }

                var keys = Object.keys(records);

                assert.equal(keys.length, 1, 'Only 1 record found');

                uuid = keys[0];

                self.log.warn('VM zonename "%s" does not match uuid "%s"',
                    zonename, uuid);

                cb();
            });
        }, function (_, cb) {
            assert.uuid(uuid, 'uuid');

            self.log.debug({uuid: uuid, zonename: zonename},
                'createVmobj zonename: %s -> uuid: %s', zonename, uuid);

            cb();
        }, function (_, cb) {
            var opts = {
                log: self.log,
                keepalive: true
            };
            vmload.getZoneData(uuid, opts, function (err, res) {
                if (err) {
                    self.log.error('failed to getZoneData(%s): %s',
                        uuid, err.message);
                    cb(err);
                    return;
                }

                if (self.vm_data_tmp !== undefined)
                    self.zone_vm_data_tmp[zonename] = res;
                self.zone_vm_data[zonename] = res;

                cb();
            });
        }, function (_, cb) {
            self.mergeZoneVmDatasets(zonename);
            cb();
        }, function (_, cb) {
            vasync.forEachParallel({
                inputs: self.vmDatasets(),
                func: function (vm_data, cb2) {
                    var opts = {
                        log: self.log,
                        cache: vm_data,
                        keepalive: true,
                        loadManually: true
                    };
                    vmload.getVmobj(uuid, opts, function (err2, vmobj) {
                        if (err2) {
                            self.log.error('failed to getVmobj(%s): %s',
                                uuid, err2.message);
                            cb2(err2);
                            return;
                        }

                        if (self.vmobjs.hasOwnProperty(zonename)) {
                            self.log.error('vmobj already created for %s',
                                zonename);
                            cb2();
                            return;
                        }

                        self.vmobjs[zonename] = vmobj;
                        self.startVmWatchers(zonename, function (err) {
                            self.log.info('started watching %s', zonename);
                            self.emit('create', vmobj);
                            cb2();
                        });
                    });
                }
            }, cb);
        }
    ]}, function (err) {
        if (err) {
            // TODO should we ignore error here?
            self.log.error({err: err}, 'createVmobj(%s) (uuid: %s)',
                zonename, uuid);
        }
        callback();
    });
};

/*
 * Called when a VM is deleted
 *
 * This will remove all internal variables needed by the VM as well as emit a
 * "delete" event
 */
Vminfod.prototype.deleteVmobj = function deleteVmobj(zonename, callback) {
    var self = this;

    if (!self.vmobjs.hasOwnProperty(zonename)) {
        self.log.warn('deleteVmobj(%s) called for non-existent zone',
            zonename);
        callback();
        return;
    }

    var obj = {
        zonename: zonename,
        uuid: self.vmobjs[zonename].uuid
    };
    assert.uuid(obj.uuid, 'obj.uuid for: ' + zonename);

    vasync.pipeline({funcs: [
        // unregister events
        function (_, cb) {
            self.stopVmWatchers(zonename, cb);
        },
        // delete vmobj
        function (_, cb) {
            delete (self.vmobjs)[zonename];
            delete (self.vmobjs_json)[zonename];
            cb();
        },
        // clean vm_data
        function (_, cb) {
            self.vmDatasets().forEach(function (data) {
                for (var key in data) {
                    if (data[key].hasOwnProperty(zonename)) {
                        delete (data[key])[zonename];
                    }
                }
            });
            cb();
        }
    ]}, function (err) {
        if (err) {
            // TODO should we ignore error here?
            self.log.error({err: err}, 'deleteVmobj(%s)', zonename);
        }
        self.log.info('stopped watching %s', zonename);
        self.emit('delete', obj);
        callback();
    });
};

/*
 * refreshVmobj() refreshes the cached vmobj and reports any changes
 *
 * Process:
 *     1) refresh the vm_data cache by calling vmload.getZoneData
 *     2) request a new vmobj by calling vmload.getVmobj
 *     3) analyze vmobj delta
 *     4) if different:
 *       4a) replace the vmobj with the new vmobj
 *       4b) log the delta
 *       4c) inform any subscribers of the delta
 */
Vminfod.prototype.refreshVmobj =
    function refreshVmobj(zonename, vm_datasets, callback) {

    var self = this;

    if (typeof (vm_datasets) === 'function') {
        callback = vm_datasets;
        self.cloneVmDatasets(zonename);
        vm_datasets = self.vmDatasets(zonename);
    }

    // short-circuit if this vmobj doesn't exist
    if (!self.vmobjs.hasOwnProperty(zonename)) {
        self.log.debug('cannot refresh vmobj, doesn\'t exist');
        self.resetVmDatasets(zonename);
        callback();
        return;
    }

    var vmobj;
    vasync.pipeline({funcs: [
        // refresh vm_data cache
        function (_, cb) {
            self.log.debug('refreshing zoneData for %s', zonename);
            vasync.forEachParallel({
                inputs: vm_datasets,
                func: function (vm_data, cb2) {
                    var opts = {
                        log: self.log,
                        cache: vm_data,
                        keepalive: true
                    };
                    vmload.getZoneData(zonename, opts,
                        function (err, cache) {

                        // we don't care about cache here because we
                        // provided a cache object that was transformed by
                        // reference. So, cache in this case is just a
                        // reference to vm_data, which we already store
                        // globally. The idea here is that we just fill in
                        // the holes that we previously created.

                        if (err) {
                            self.log.error('unable to refresh vmobj for '
                                + zonename + ', failed to getZoneData');
                            cb2(err);
                            return;
                        }

                        cb2();
                    });
                }
            }, cb);
        },
        // merge zone_vm_objs
        function (_, cb) {
            self.mergeZoneVmDatasets(zonename);
            cb();
        },
        // request a new vmobj
        function (_, cb) {
            self.log.debug('requesting new vmobj for %s', zonename);
            var opts = {
                log: self.log,
                keepalive: true,
                cache: self.vm_data,
                loadManually: true
            };
            vmload.getVmobj(zonename, opts, function (err, _vmobj) {
                if (err) {
                    self.log.error({err: err},
                        'unable to refresh vmobj for %s, failed getVmobj',
                        zonename);

                    if (err.code === 'ENOENT'
                        && err.message.match(/No such zone configured$/)) {
                        self.log.debug({uuid: zonename},
                            'marking %s as deleted', zonename);
                        self.deleteVmobj(zonename, function (err2) {
                            if (err2) {
                                self.log.error({uuid: zonename, err: err2},
                                    'error marking %s as deleted',
                                    zonename);
                            } else {
                                self.log.debug({uuid: zonename},
                                    'successfully marked %s as deleted',
                                    zonename);
                            }
                            cb(err2 || err);
                        });
                        return;
                    }

                    cb(err);
                    return;
                }

                vmobj = _vmobj;
                cb();
            });
        },
        // analyze delta, update live copy
        function (_, cb) {
            // We remove both VMs "last_modified" property to compare the
            // objects.  If there are no changes, we keep at as the current
            // value, and if there are any changes we silently set it to
            // the current time.
            var cur_last_modified = self.vmobjs[zonename].last_modified;
            delete self.vmobjs[zonename].last_modified;
            delete vmobj.last_modified;

            var changes;
            try {
                changes = diff(self.vmobjs[zonename], vmobj, {
                    map: DIFF_MAP
                });
            } catch (err) {
                self.log.error({
                    from: self.vmobjs[zonename],
                    to: vmobj,
                    err: err},
                    'failed to calculate object diff');
                throw err;
            }
            self.vmobjs[zonename] = vmobj;

            if (changes.length > 0) {
                self.vmobjs[zonename].last_modified = new
                    Date().toISOString();
                delete (self.vmobjs_json[zonename]);
                self.emit('modify', vmobj, changes);
            } else {
                self.vmobjs[zonename].last_modified = cur_last_modified;
            }

            cb();
        }
    ]}, callback);
};

/*
 * return the active data objects for a given zone (if zonename is set)
 * or for all zones.
 */
Vminfod.prototype.vmDatasets = function vmDatasets(zonename) {
    var self = this;
    var ret = [];

    if (zonename) {
        ret.push(self.zone_vm_data[zonename]);
        if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
            ret.push(self.zone_vm_data_tmp[zonename]);
        }
    } else {
        ret.push(self.vm_data);
        if (self.vm_data_tmp !== undefined) {
            ret.push(self.vm_data_tmp);
        }
    }

    return (ret);
};

/*
 * remove the given zone from the internal zone data
 */
Vminfod.prototype.resetVmDatasets = function resetVmDatasets(zonename) {
    var self = this;

    if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
        delete (self.zone_vm_data_tmp)[zonename];
    }

    if (self.zone_vm_data.hasOwnProperty(zonename)) {
        delete (self.zone_vm_data)[zonename];
    }
};

/*
 * copy a single zone's information from the "all zones" cache to an
 * individual cache specific to the zone
 */
Vminfod.prototype.cloneVmDatasets = function cloneVmDatasets(zonename) {
    var self = this;

    function cloneVmDataset(from, to) {
        Object.keys(from).forEach(function (key) {
            switch (key) {
            case 'dataset_objects':
            case 'sysinfo':
                to[key] = from[key];
                break;
            default:
                if (!to.hasOwnProperty(key)) {
                    to[key] = {};
                }
                if (from[key].hasOwnProperty(zonename)) {
                    to[key][zonename] = from[key][zonename];
                }
                break;
            }
        });
    }

    if (self.vm_data_tmp !== undefined) {
        self.zone_vm_data_tmp[zonename] = {};
        cloneVmDataset(self.vm_data_tmp, self.zone_vm_data_tmp[zonename]);
    }

    self.zone_vm_data[zonename] = {};
    cloneVmDataset(self.vm_data, self.zone_vm_data[zonename]);
};

/*
 * take a zones specific information and put it in the "all zones" cache, as
 * well as clear the individual zones cache
 */
Vminfod.prototype.mergeZoneVmDatasets = function mergeZoneVmDatasets(zonename) {
    var self = this;

    /*
     * The rationale here is to iterate through all of the keys in the from
     * object and check for a zonename key. If it exists, copy it over. Then
     * we remove any objects containing the zonename key in the to object
     * that aren't in the from object, to ensure we don't leave any cruft.
     */
    function mergeVmDataset(from, to) {
        Object.keys(from).forEach(function (key) {
            if (from[key].hasOwnProperty(zonename)) {
                to[key][zonename] = from[key][zonename];
            } else {
                if (to[key].hasOwnProperty(zonename)) {
                    delete (to[key])[zonename];
                }
            }
        });
    }

    /*
     * Any time a point of data has been merged, we also need to clear
     * the cached JSON for this data. The JSON will later be generated
     * and cached as needed by incoming requests.
     */
    function clearCache(from) {
        Object.keys(from).forEach(function (key) {
            if (from[key].hasOwnProperty(zonename)
                && self.vm_data_json.hasOwnProperty(key)
                && self.vm_data_json[key].hasOwnProperty(zonename)) {

                delete (self.vm_data_json[key])[zonename];
            }
        });
    }

    if (self.vm_data_tmp !== undefined
        && self.zone_vm_data_tmp.hasOwnProperty(zonename)) {

        mergeVmDataset(self.zone_vm_data_tmp[zonename], self.vm_data_tmp);
        clearCache(self.zone_vm_data_tmp[zonename]);
    }

    if (self.zone_vm_data.hasOwnProperty(zonename)) {
        mergeVmDataset(self.zone_vm_data[zonename], self.vm_data);
        clearCache(self.zone_vm_data[zonename]);
    }

    self.resetVmDatasets(zonename);
};

/*
 * poke holes in cache objects for a specific zone
 */
Vminfod.prototype.invalidateZoneDataCache =
    function invalidateZoneDataCache(zonename, vm_datasets, contexts) {

    vm_datasets.forEach(function (data) {
        contexts.forEach(function (context) {
            if (!data.hasOwnProperty(context))
                return;

            if (data[context].hasOwnProperty(zonename))
                delete (data[context])[zonename];

            if (Object.keys(data[context]).length === 0)
                delete data[context];
        });
    });
};

/*
 * handleZoneEvent() is a callback for a ZoneWatcher
 *
 * Process:
 *
 *   First we extract the zonename property from the event, then see if we
 *   have any vmobjs registered with that zonename. If not, then this must
 *   be a vm create, which we will:
 *     1) fetch the vmobj from vmload.getVmobj
 *     2) register observers
 *     3) inform subscribers of the new vmobj
 *   If this is a vm that we already know about, we will:
 *     1) invalidate the relevant pieces of the vm_data
 *     2) refresh the vmobj by calling refreshVmobj
 */
Vminfod.prototype.handleZoneEvent = function handleZoneEvent(obj) {
    var self = this;

    assert.object(obj, 'obj');
    assert.string(obj.zonename, 'obj.zonename');

    var zonename = obj.zonename;
    var meta = util.format('zonename: %s newstate: %s',
        zonename, obj.newstate);
    var vm_datasets;

    self.log.debug({obj: obj}, 'handleZoneEvent: %s', meta);

    self.event_queue.enqueue({
        description: 'handle zone event - zonename: ' + zonename,
        timeout: QUEUE_TASK_TIMEOUT,
        func: function (extras, callback) {
            if (!self.vmobjs.hasOwnProperty(zonename)) {
                // a new vm!
                self.createVmobj(zonename, callback);
                return;
            }

            self.cloneVmDatasets(zonename);
            vm_datasets = self.vmDatasets(zonename);

            // remove pieces of the cache that might have been affected
            var contexts = [
                'pids',
                'zoneadm_objects',
                'zonexml_objects',
                'zoneinfo_objects'
            ];

            self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
            self.refreshVmobj(zonename, vm_datasets, callback);
        }
    });
};

/*
 * handleFsEvent() is a callback for a FsWatcher
 */
Vminfod.prototype.handleFsEvent = function handleFsEvent(obj) {
    var self = this;

    var zonexml_re = /\/etc\/zones\/(.+)\.xml/;
    var metadata_re = /\/zones\/(.+)\/config\/.+\.json/;
    var lastexit_re = /\/zones\/(.+)\/lastexited/;
    var contexts;
    var matches;
    var meta;
    var vm_datasets;
    var zonename;

    assert.object(obj, 'obj');
    assert.string(obj.pathname, 'obj.pathname');

    meta = util.format('pathname: %s (%s)',
        obj.pathname, obj.changes || obj.type);

    self.log.debug({obj: obj}, 'handleFsEvent: %s', meta);

    // zone XML file
    if ((matches = obj.pathname.match(zonexml_re))) {
        zonename = matches[1];

        self.event_queue.enqueue({
            description: 'handle zonexml fs change - ' + meta,
            timeout: QUEUE_TASK_TIMEOUT,
            func: function (extras, callback) {
                // short-circuit if this vmobj doesn't exist
                if (!self.vmobjs.hasOwnProperty(zonename)) {
                    extras.log.debug('vmobj doesn\'t exist for %s',
                        zonename);
                    callback();
                    return;
                }

                switch (obj.type) {
                case 'delete':
                    extras.log.debug('%s deleted', obj.pathname);
                    // the show is over! teardown!
                    self.deleteVmobj(zonename, callback);
                    break;
                case 'change':
                    extras.log.debug('%s modified', obj.pathname);
                    self.cloneVmDatasets(zonename);
                    vm_datasets = self.vmDatasets(zonename);

                    // clear the missing pieces and refresh
                    contexts = [
                        'zonexml_objects',
                        'zoneinfo_objects'
                    ];

                    self.invalidateZoneDataCache(zonename, vm_datasets,
                        contexts);
                    self.refreshVmobj(zonename, vm_datasets, callback);
                    break;
                default:
                    extras.log.warn({obj: obj},
                        'unhandled fs change type "%s"',
                        obj.type);
                    callback();
                    break;
                }
            }
        });

    // zone metadata file
    } else if ((matches = obj.pathname.match(metadata_re))) {
        zonename = matches[1];

        self.event_queue.enqueue({
            description: 'handle metadata fs update - ' + meta,
            timeout: QUEUE_TASK_TIMEOUT,
            func: function (extras, callback) {
                // short-circuit if this vmobj doesn't exist
                if (!self.vmobjs.hasOwnProperty(zonename)) {
                    extras.log.debug('vmobj doesn\'t exist for %s',
                        zonename);
                    callback();
                    return;
                }

                self.cloneVmDatasets(zonename);
                vm_datasets = self.vmDatasets(zonename);

                // clear the missing pieces and refresh
                contexts = [
                    'json_objects'
                ];

                self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
                self.refreshVmobj(zonename, vm_datasets, callback);
            }
        });
    // zone lastexited file
    } else if ((matches = obj.pathname.match(lastexit_re))) {
        zonename = matches[1];

        self.event_queue.enqueue({
            description: 'handle lastexit fs change - ' + meta,
            timeout: QUEUE_TASK_TIMEOUT,
            func: function (extras, callback) {
                // short-circuit if this vmobj doesn't exist
                if (!self.vmobjs.hasOwnProperty(zonename)) {
                    self.log.debug('vmobj doesn\'t exist for ' + zonename);
                    callback();
                    return;
                }

                self.cloneVmDatasets(zonename);
                vm_datasets = self.vmDatasets(zonename);

                // clear the missing pieces and refresh
                contexts = [
                    'last_exited'
                ];

                self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
                self.refreshVmobj(zonename, vm_datasets, callback);
            }
        });

    // sysinfo
    } else if (obj.pathname === '/tmp/.sysinfo.json') {
        self.event_queue.enqueue({
            description: 'handle sysinfo fs change - ' + meta,
            timeout: QUEUE_TASK_TIMEOUT,
            func: function (extras, callback) {
                vasync.forEachParallel({
                    inputs: self.vmDatasets(),
                    func: function (data, cb) {
                        if (data.hasOwnProperty('sysinfo')) {
                            delete data.sysinfo;
                        }

                        var opts = {
                            log: extras.log,
                            cache: data,
                            keepalive: true
                        };
                        vmload.getZoneData(null, opts,
                            function (err, cache) {

                            if (err) {
                                extras.log.error('failed to refresh '
                                    + 'sysinfo, failed to getZoneData');
                            }

                            cb();
                        });
                    }
                }, callback);
            }
        });
    } else {
        self.log.warn('unhandled event for file: %s', obj.pathname);
    }
};

/*
 * handleZpoolEvent() is a callback for a zpool watcher
 *
 * Process:
 *
 *   When action is clone or create:
 *     - fetch zpool data
 *     - merge into vm_cache
 *     - refresh vmobj
 *
 *   When action is set:
 *     - unset vm_data pieces
 *     - fetch zpool data
 *     - merge into vm_cache
 *     - refresh vmobj
 *
 *   When action is destroy:
 *     - unset vm_data
 *     - refresh vmobj
 *
 */
Vminfod.prototype.handleZpoolEvent = function handleZpoolEvent(obj) {
    var self = this;
    var action;
    var description;
    var sections = ['datasets', 'mountpoints', 'snapshots'];
    var name = obj.dsname;
    var _s = name.split('@');
    var dsname = _s[0];
    var snapname = _s[1];
    var parts;
    var uuid;
    var zonepath;
    var meta = util.format('dsname: %s action: %s %s',
        obj.dsname, obj.action, obj.extras).trim();

    self.log.debug({obj: obj}, 'handleZpoolEvent: %s', meta);

    /*
     * break the incoming zfs dataset into an array
     * ex => ['zones', '<uuid>', 'config']
     */
    parts = dsname.split('/');
    if (parts[1]) {
        /*
         * Attempt to extract a UUID from the second part.  This will succeed
         * for KVM instances (for example) that have a dataset like
         * /zones/<uuid>-disk0.
         */
        uuid = extractUUID(parts[1]);
    }

    /*
     * If the dataset name matches "/zones/<uuid>" exactly we use that as the
     * zonepath argument to getDatasets.  Otherwise, we use the parent dataset.
     */
    if (parts[0] === ZONES_ZPOOL && parts[1] === uuid && !parts[2]) {
        zonepath = dsname;
    } else {
        zonepath = path.dirname(dsname);
    }

    /*
     * Based on the "action" seen from the ZFS sysevent, we determine ahead of
     * time what kind of action we will need to take as a response.  By doing
     * this we can dedup the tasks pushed to the queue, because while the ZFS
     * sysevents might differ, the actions we take as a response may be the
     * same, in which case they only need to be done once.
     */
    switch (obj.action) {
    case 'clone':
    case 'create':
    case 'snapshot':
        action = 'fetchAndCopy';
        break;
    case 'clone swap': // rollback
    case 'set':
    case 'hold':
    case 'release':
    case 'rename':
    case 'finish receiving':
        action = 'fetchExpireAndCopy';
        break;
    case 'destroy':
        action = 'expire';
        break;
    case 'receive':
        // do nothing
        self.log.debug('ignoring action: %s', obj.action);
        return;
    default:
        self.log.fatal('unknown action: %s', obj.action);
        return;
    }
    description = util.format('dsname: %s action: %s', obj.dsname, action);

    function expire() {
        function expireObjects(ds_objects) {
            sections.forEach(function (section) {
                if (!ds_objects.hasOwnProperty(section)) {
                    return;
                }

                switch (section) {
                case 'mountpoints':
                    for (var key in ds_objects[section]) {
                        if (ds_objects[section][key] === name) {
                            delete (ds_objects[section])[key];
                        }
                    }
                    break;
                default:
                    if (ds_objects[section].hasOwnProperty(name)) {
                        delete (ds_objects[section])[name];
                    }
                    break;
                }

                if (snapname && section === 'snapshots') {
                    // remove the snapshot here as well
                    if (ds_objects[section].hasOwnProperty(dsname)) {
                        ds_objects[section][dsname] =
                            ds_objects[section][dsname].filter(function (o) {

                            return o.snapname !== snapname;
                        });
                    }
                }
            });
        }

        self.vmDatasets().forEach(function (data) {
            expireObjects(data.dataset_objects);
        });

        if (self.vm_data_json.hasOwnProperty('dataset_objects')) {
            expireObjects(self.vm_data_json.dataset_objects);
        }
    }

    function fetch(datasetObj, cb) {
        var opts = {
            log: self.log,
            dataset: name
        };
        getDatasets(datasetObj, opts, function (err, results) {
            if (err) {
                self.log.warn('failed to fetch datasets');
            }
            cb(err, results);
        });
    }

    function copy(cache) {
        self.vmDatasets().forEach(function (data) {
            sections.forEach(function (section) {
                for (var key in cache[section]) {
                    if (!data.hasOwnProperty('dataset_objects')) {
                        data.dataset_objects = {};
                    }
                    if (!data.dataset_objects.hasOwnProperty(section)) {
                        data.dataset_objects[section] = {};
                    }
                    data.dataset_objects[section][key] = cache[section][key];
                }
            });
        });
    }

    self.event_queue.enqueue({
        description: 'handle zfs event - ' + description,
        timeout: QUEUE_TASK_TIMEOUT,
        func: function (extras, cb) {
            var datasetObj = {};
            if (zonepath !== '.') {
                datasetObj.zonepath = util.format('/%s', zonepath);
            }

            switch (action) {
            case 'fetchAndCopy':
                fetch(datasetObj, function (err, cache) {
                    if (err) {
                        finish();
                        return;
                    }
                    copy(cache);
                    finish();
                });
                return;
            case 'fetchExpireAndCopy':
                fetch(datasetObj, function (err, cache) {
                    if (err) {
                        finish();
                        return;
                    }
                    expire();
                    copy(cache);
                    finish();
                });
                return;
            case 'expire':
                expire();
                finish();
                break;
            default:
                extras.log.fatal('unknown action: %s', obj.action);
                finish();
                break;
            }

            function finish() {
                if (!uuid) {
                    cb();
                    return;
                }

                // if we happen to grab an image uuid here,
                // the refreshVmobj will return immediately
                extras.log.debug('refreshing vmobj %s after zfs event', uuid);
                self.refreshVmobj(uuid, cb);
            }
        }
    });
};

/*
 * Extract a (the first) UUID from a string
 */
function extractUUID(s) {
    var uuid_re = new RegExp('('
        + '[a-f0-9]{8}-'
        + '[a-f0-9]{4}-'
        + '[a-f0-9]{4}-'
        + '[a-f0-9]{4}-'
        + '[a-f0-9]{12}'
        + ')'
    );
    var match = uuid_re.exec(s);

    return match && match[1];
}

function formatEventsListeners(evls) {
    var now = process.hrtime();
    var ret = {};

    assert.object(evls, 'evls');

    Object.keys(evls).forEach(function (uuid) {
        var evl = evls[uuid];

        ret[uuid] = {
            userAgent: evl.userAgent,
            createdTime: hrtime.hrtimeToString(evl.createdTime),
            createdDate: evl.createdDate,
            createdAgo: hrtime.hrtimeDeltaPretty(now, evl.createdTime)
        };
    });

    return ret;
}

function formatRefreshErrors(refreshErrors) {
    var now = process.hrtime();
    var ret;

    assert.arrayOfObject(refreshErrors, 'refreshErrors');

    ret = refreshErrors.map(function (re) {
        var o = {
            err: re.err.message,
            time: hrtime.hrtimeToString(re.time),
            ago: hrtime.hrtimeDeltaPretty(now, re.time)
        };

        return o;
    });

    return ret;
}

function formatRefreshLog(refreshLog) {
    assert.arrayOfObject(refreshLog, 'refreshLog');

    var now = process.hrtime();
    var ret;

    ret = refreshLog.map(function (rl) {
        var o = {
            changes: rl.changes,
            started: hrtime.hrtimeToString(rl.started),
            ended: hrtime.hrtimeToString(rl.ended),
            took: rl.prettyDelta,
            endedAgo: hrtime.hrtimeDeltaPretty(now, rl.ended)
        };

        return o;
    });

    return ret;
}

function isUUID(s) {
    try {
        assert.uuid(s);
        return true;
    } catch (e) {
        return false;
    }
}
