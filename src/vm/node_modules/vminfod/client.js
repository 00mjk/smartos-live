/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2017, Joyent, Inc.
 *
 * - VminfodClient
 *
 * A client class that can be used to make basic GET requests to the vminfod
 * service.
 *
 * var vc = new require('vminfod/client').VminfodClient();
 *
 * vc.ping(cb);
 * vc.status(cb);
 * vc.data(cb);
 * vc.vms(cb);
 * vc.vm(zonename, cb);
 * vc.get(urlPath, cb); // arbitrary GET request
 *
 * Where `cb` has the signature function(err, result)
 *
 * - VminfodEventStream
 *
 * A class that can be used to interface directly with the vminfod events
 * stream (GET /events).  It creates a readable stream in objectMode where each
 * call to read returns an object parsed from the event stream that represents
 * a single event.
 *
 * var vs = new require('vminfod/client').VminfodEventStream();
 *
 * vs.on('ready', function (ev) {
 *     // stream ready
 * });
 *
 * // create a live stream
 * vs.on('readable', function () {
 *     var ev;
 *     while ((ev = vs.read())) {
 *         console.log(JSON.stringify(ev));
 *     }
 * });
 *
 * // or instead, call a convenince function
 *
 * - VminfodEventStream#watchForEvent(obj, opts, cb)
 *
 * // wait 60 seconds for the zone_state to transition to "running"
 * var obj = {
 *     zonename: '<uuid>',
 *     vm: {
 *         zone_state: 'running'
 *     }
 * };
 * var opts = {
 *     timeout: 60 * 1000, // error after 60 seconds if event is not seen
 *     teardown: true, // end the stream at any error or when the event is seen
 *     startFresh: true, // clear any unread events
 *     catchErrors: true // bind .on('error') and callback if any is seen
 * };
 *
 * // watchForEvent returns a function that can be used to cancel the watch.
 * // It is bascially a shortcut to the callback that is fired - any arguments
 * // passed to cancel will be applied to the callback given.
 * var cancel = vs.watchForEvent(obj, opts, function (err, ev) {
 *     if (err) {
 *         // either the stream ended prematurely or the event was not seen for
 *         // 60 seconds
 *     }
 *     // `ev` is the event that matched "obj"
 *     console.log(JSON.stringify(ev, null, 2));
 * });
 *
 * - VminfodEventStream#watchForChanges(obj, changes, opts, cb)
 *
 * // wait 30 seconds for the quota to change from 10 to 20
 *
 * // just like watchForEvent, this object is matched against the event object
 * // before any further processing is done.
 * var obj = {
 *     zonename: '<uuid>',
 * };
 * // same as watchForEvent
 * var opts = {
 *     timeout: 30 * 1000,
 *     teardown: true,
 *     startFresh: true,
 *     catchErrors: true
 * };
 * // every element in the array must be matched for the callback to fire
 * // successfully (logical AND).
 * var changes = [
 *    {
 *        path: ['quota'],
 *        action: 'changed',
 *        from: 10,
 *        to: 20
 *    }
 * ];
 * var cancel = vs.watchForChanges(obj, changes, opts, function (err) {
 *     if (err) {
 *         // either the stream ended prematurely or the event was not seen for
 *         // 30 seconds
 *     }
 *     // matched the changes given
 * });
 *
 * - VminfodWatcher
 *
 * A class that wraps VminfodEventStream and can be used to mirror vminfod
 * effectively.  Under the hood, a VminfodEventStream will be created and used
 * to manage an internal object of all VMs that vminfod is aware of.  This way,
 * the internal object is kept up to date by getting notified of any changes
 * from the vminfod service.  For Example:
 *
 * var vw = new require('vminfod/client').VminfodWatcher();
 *
 * vw.on('ready', function (ev) {
 *     // returns an object that maps zonenames to vm objects
 *     var vms = vw.vms();
 *     // vms[<uuid] == vmobj
 *
 *     var vmobj = vw.vm('uuid');
 *     // vmobj is an object, or undefined if it is not found
 * });
 *
 * vw.on('create', cb); // a VM was created
 * vw.on('modify', cb); // a VM was modified
 * vw.on('delete', cb); // a VM was deleted
 * vw.on('event', cb);  // a VM was created/modified/deleted
 *
 * All callbacks will be called with a single argument - the event from the
 * vminfod stream.
 *
 * The calls to `vs.vms` and `vs.vm` are very fast, because they just check
 * a local JavaScript object (as opposed to making an HTTP call to the
 * vminfod service) that is kept up to date by the VminfodEventStream.
 */

var EventEmitter = require('events').EventEmitter;
var http = require('http');
var stream = require('stream');
var os = require('os');
var util = require('util');
var qs = require('querystring');

var assert = require('/usr/node/node_modules/assert-plus');
var bunyan = require('/usr/node/node_modules/bunyan');
var LineStream = require('/usr/node/node_modules/linestream');

module.exports.VminfodClient = VminfodClient;
module.exports.VminfodEventStream = VminfodEventStream;
module.exports.VminfodWatcher = VminfodWatcher;

var log = bunyan.createLogger({
    level: 'debug',
    name: 'vminfod/client',
    stream: process.stderr,
    serializers: bunyan.stdSerializers
});

/*
 * VminfodClient class
 */
function VminfodClient(opts) {
    var self = this;

    assert(self instanceof VminfodClient, 'must be called with "new"');

    opts = opts || {};
    if (typeof (opts) === 'string')
        opts = {name: opts};

    var _log = opts.log || log;

    self.vc_host = opts.host || '127.0.0.1';
    self.vc_port = opts.port || 9090;
    self.vc_name = opts.name || _log.fields.name;
    self.vc_logger = _log.child({client: self.vc_name});
}

/*
 * Perform a GET request to the Vminfod daemon.
 *
 * @param {Object|String} opts - options to pass to http.request, if this is a
 *                               string it is used as opts.path (the endpoint)
 * @param {Function} cb - callback of signature cb(err, data)
 *   - err - any possible error, including non-200 statusCode or failure to
 *           parse JSON response
 *   - data - the JSON.parse'd data returned from the server
 * @return {HTTPRequest} req - the HTTP request object
 */
VminfodClient.prototype.get = function get(opts, cb) {
    var self = this;

    if (typeof (opts) === 'string')
        opts = {path: opts};
    assert.object(opts, 'opts');

    var reqOpts = {
        host: self.vc_host,
        port: self.vc_port,
        method: 'GET',
        headers: {
            'user-agent': makeUserAgent(self.vc_name)
        }
    };
    Object.keys(opts).forEach(function (key) {
        reqOpts[key] = opts[key];
    });

    var req = http.request(reqOpts, function (res) {
        if (res.statusCode !== 200) {
            var err = new Error('bad statusCode: ' + res.statusCode);
            err.code = err.statusCode = res.statusCode;
            res.destroy();
            cb(err);
            return;
        }

        res.setEncoding('utf8');
        var body = '';
        res.on('readable', function () {
            var chunk;
            while ((chunk = res.read()) !== null)
                body += chunk;
        });
        res.on('end', function () {
            try {
                var d = JSON.parse(body);
                cb(null, d);
            } catch (e) {
                cb(e);
            }
        });
    });
    req.on('error', function (e) {
        cb(e);
        req.destroy();
    });
    req.end();
    return req;
};

/*
 * shortcuts for common endpoints, eqivalent to:
 *   get('/status', cb), get('/vms', cb), etc.
 */
['ping', 'status', 'vms'].forEach(function (s) {
    VminfodClient.prototype[s] = function (opts, cb) {
        if (typeof (opts) === 'function') {
            cb = opts;
            opts = {};
        }
        opts.path = '/' + s;

        if (opts.query)
            opts.path += '?' + qs.stringify(opts.query);

        return this.get(opts, cb);
    };
});

/*
 * Get a information for a specific vm given the zonename
 *
 * @param {String} zonename - the zonename (UUID most likely)
 * @param {Function} cb - same signature and usage as .get()
 */
VminfodClient.prototype.vm = function vm(zonename, cb) {
    var endpoint = '/vms/' + encodeURIComponent(zonename);
    return this.get(endpoint, function (err, vmobj) {
        if (err && err.code === 404) {
            // TODO this is a lame hack so the vmadm command line outputs
            // a message we expect for a zone that is missing.
            err.message = util.format('zoneadm: %s: No such zone configured',
                zonename);
        }
        cb(err, vmobj);
    });
};

/*
 * Create a new vminfod stream by creating a persistent HTTP request to vminfod
 *
 */
function VminfodEventStream(opts) {
    var self = this;

    assert(self instanceof VminfodEventStream, 'must be called with "new"');

    opts = opts || {};
    if (typeof (opts) === 'string')
        opts = {name: opts};

    // become a transform stream
    stream.Transform.call(self, {objectMode: true});

    var _log = opts.log || log;

    // process opts
    self.vs_host = opts.host || '127.0.0.1';
    self.vs_port = opts.port || 9090;
    self.vs_name = opts.name || _log.fields.name;
    self.vs_parseReady = opts.parseReady || false;
    self.vs_logger = _log.child({client: self.vs_name});

    self.start();
}
util.inherits(VminfodEventStream, stream.Transform);

/*
 * start the stream by opening a persistent HTTP connection
 */
VminfodEventStream.prototype.start = function start(opts) {
    var self = this;

    opts = opts || {};

    assert.ok(!self.vs_req, 'VminfodEventStream already started');

    var reqOpts = {
        host: self.vs_host,
        port: self.vs_port,
        method: 'GET',
        path: '/events',
        headers: {
            'user-agent': makeUserAgent(self.vs_name)
        }
    };
    Object.keys(opts).forEach(function (key) {
        reqOpts[key] = opts[key];
    });

    self.vs_req = http.request(reqOpts, function (res) {
        var e;
        if (res.statusCode !== 200) {
            e = new Error('bad statusCode: ' + res.statusCode);
            e.code = res.statusCode;
            res.destroy();
            self.vs_logger.error({err: e}, '%s', e.message);
            self.emit('error', e);
            return;
        }

        var ls = new LineStream();
        res.pipe(ls).pipe(self);
        res.on('end', function () {
            if (self.vs_req) {
                e = new Error('VminfodEventStream ended prematurely');
                self.vs_logger.error({err: e}, '%s', e.message);
                self.emit('error', e);
                return;
            }
        });
    });
    self.vs_req.setTimeout(0);
    self.vs_req.end();

    return self.vs_req;
};

/*
 * the transform method to process http body-by-line
 */
VminfodEventStream.prototype._transform =
function _transform(chunk, encoding, cb) {
    var self = this;

    var now;
    var line = chunk.toString('utf8');
    var ev;
    var vms;

    try {
        ev = JSON.parse(line);
        ev.ts = new Date(ev.ts);
    } catch (e) {
        // any JSON parse failure is a fatal error
        self.vs_logger.error({err: e, line: line},
            'failed to parse output line');
        self._abort();
        return;
    }

    if (ev.type === 'ready') {
        if (self.vs_parseReady) {
            // this is less-than-ideal, but because vminfod pre-serializes
            // vm data to cut down on the number of calls to JSON.stringify
            // required, we have to JSON.parse the vms property, as its been
            // serialized twice.  Also, we convert the vms array to an object
            // indexed off of the "zonename" (uuid) property
            now = Date.now();
            vms = {};
            JSON.parse(ev.vms).forEach(function (vmobj) {
                vms[vmobj.zonename] = vmobj;
            });
            ev.vms = vms;
            self.vs_logger.debug('vminfod took %dms to parse "ready" event',
                Date.now() - now);
        }
        self.vs_logger.debug('vminfod event stream ready');
        self.emit('ready', ev);
    } else {
        self.push(ev);
    }
    cb();
};

/*
 * clear all unread objects from the internal buffer
 */
VminfodEventStream.prototype.exhaustEvents = function exhaustEvents() {
    var self = this;
    var i = 0;

    while (self.read()) {
        i++;
    }

    self.vs_logger.debug({i: i}, 'vminfod exhausted %d events', i);
};

/*
 * cleanly stop the VminfodEventStream by destroying the request
 */
VminfodEventStream.prototype.stop = function stop() {
    var self = this;

    if (self.vs_req) {
        self.vs_logger.debug('vminfod event stream stopped');
        self.vs_req.destroy();
        self.vs_req = null;
    }
};

/*
 * same as above, but emit an error
 */
VminfodEventStream.prototype._abort = function _abort() {
    var self = this;

    self.stop();
    var e = new Error('VminfodEventStream aborted');
    self.emit('error', e);
};

/*
 * watch for a specific event (with an optional timeout), and
 * optionally teardown the stream when it is received
 */
VminfodEventStream.prototype.watchForEvent =
function watchForEvent(obj, opts, cb) {
    var self = this;
    var events = [];
    var timeout;
    var isDone = false;

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }
    assert.object(obj, 'obj');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.optionalBool(opts.teardown, 'opts.teardown');
    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
    assert.optionalBool(opts.startFresh, 'opts.startFresh');
    assert.func(cb, 'cb');

    if (opts.timeout) {
        timeout = setTimeout(function () {
            isDone = true;
            self.stop();
            self.vs_logger.error({obj: obj, events: events},
                'vminfod watchForEvent timeout exceeded - unmatched events');
            var e = new Error('timeout exceeded');
            e.code = 'ETIMEOUT';
            done(e);
        }, opts.timeout);
    }

    self.vs_logger.debug({
        obj: obj,
        opts: opts
    }, 'vminfod watchForEvent created');

    self.on('readable', readable);
    if (opts.startFresh)
        self.exhaustEvents();
    else
        readable();
    function readable() {
        var ev;
        while ((ev = self.read()) !== null) {
            processevent(ev);
        }
    }

    function processevent(ev) {
        if (isDone)
            return;

        events.push(ev);

        if (!objSameValues(obj, ev))
            return;

        self.vs_logger.debug({obj: obj},
            'vminfod watchForEvent matched event');

        done(null, ev);
    }

    function onerror(e) {
        self.vs_logger.error({err: e},
            'vminfod watchForEvent stream error');
        done(e);
    }
    if (opts.catchErrors) {
        self.on('error', onerror);
    }

    function done(err, o) {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        if (opts.teardown || (opts.catchErrors && err)) {
            self.stop();
        }
        if (opts.catchErrors) {
            self.removeListener('error', onerror);
        }
        self.removeListener('readable', readable);
        isDone = true;
        cb(err, o);
    }

    function cancel(err, o) {
        if (isDone) {
            self.vs_logger.warn('vminfod watchForEvent cancelled after done');
        } else {
            self.vs_logger.debug('vminfod watchForEvent cancelled');
            done(err, o);
        }
    }

    return cancel;
};

/*
 * watch for one or more changes (with an optional timeout), and
 * optionally teardown the stream when it is seen
 */
VminfodEventStream.prototype.watchForChanges =
function watchForChanges(obj, changes, opts, cb) {
    var self = this;
    var timeout;
    var events = [];
    var isDone = false;

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }

    assert.object(obj, 'obj');
    assert.array(changes, 'changes');
    changes.forEach(function (_changes) {
        // change can be an object, or an array of objects
        if (!Array.isArray(_changes))
            _changes = [_changes];
        assert.arrayOfObject(_changes, 'changes');
        _changes.forEach(function (change) {
            // in order for a "change" object to be valid, it must have the
            // "path" property set, as well as one other property indicating
            // change type.
            assert.array(change.path, 'change.path');
            var otherkeys = Object.keys(change).filter(function (key) {
                return key !== 'path';
            });
            assert(otherkeys.length > 0, 'change only has "path" set');
        });
    });
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.optionalBool(opts.teardown, 'opts.teardown');
    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
    assert.optionalBool(opts.firstMatch, 'opts.firstMatch');
    assert.optionalBool(opts.startFresh, 'opts.startFresh');
    assert.func(cb, 'cb');

    var total = changes.length;

    self.vs_logger.debug({
        obj: obj,
        opts: opts,
        changes: changes,
        total: total
    }, 'vminfod watchForChanges created');

    if (total === 0) {
        self.vs_logger.warn('vminfod watchForChanges called '
            + 'with empty changes array');
        if (opts.startFresh)
            self.exhaustEvents();
        done();
        return null;
    }

    if (opts.timeout) {
        timeout = setTimeout(function () {
            self.vs_logger.error({changes: changes, events: events},
                'vminfod watchForChanges timeout exceeded - unmatched events');
            var e = new Error('timeout exceeded');
            e.code = 'ETIMEOUT';
            done(e);
        }, opts.timeout);
    }

    self.vs_logger.trace({changes: changes},
        'beginning watch for vminfod changes');

    self.on('readable', readable);
    if (opts.startFresh)
        self.exhaustEvents();
    else
        readable();
    function readable() {
        var ev;
        while ((ev = self.read()) !== null) {
            processevent(ev);
        }
    }

    function processevent(ev) {
        if (isDone)
            return;

        // filter out events that don't match our predicate (obj)
        if (!objSameValues(obj, ev))
            return;

        self.vs_logger.trace({ev: ev},
            'inspecting possible match from vminfod');

        // loop changes found from vminfod
        (ev.changes || []).forEach(function (change) {

            // compare to changes we are looking for.
            // we return false to remove the item from the changes
            // array (meaning we matched it) or true to keep it in
            // the array (it was not a match)

            // it's possible that there are duplicate changes we are looking
            // for, so only filter out one element per change
            var hasMatched = false;
            changes = changes.filter(function (wantedArr) {
                if (isDone)
                    return false;

                if (hasMatched)
                    return true;

                if (!Array.isArray(wantedArr))
                    wantedArr = [wantedArr];

                for (var i = 0; i < wantedArr.length; i++) {
                    var match;

                    var wanted = wantedArr[i];
                    var originalWantedPath = wanted.path.slice(0);

                    var wantedPath = wanted.path;
                    var changePath = change.path;

                    // we skip this change if the path of the wanted
                    // variable doesn't match
                    if (wantedPath.length !== changePath.length)
                        continue;

                    // check each part of the "path" match
                    match = true;
                    for (var j = 0; j < wantedPath.length; j++) {
                        var wantedPart = wantedPath[j];
                        var changePart = changePath[j];
                        if (!(wantedPart === null
                            || wantedPart === changePart)) {
                            match = false;
                            break;
                        }
                    }
                    if (!match)
                        continue;

                    // compare the event fire to the event we want,
                    // omitting the "path" variable as it was checked
                    // above
                    delete wanted.path;
                    match = objSameValues(wanted, change);
                    wanted.path = originalWantedPath;

                    if (match) {
                        // we matched, this change will be removed from the
                        // array
                        hasMatched = true;
                        self.vs_logger.trace({change: change, match: match},
                            'vminfod change match');
                        if (opts.firstMatch) {
                            self.vs_logger.trace('first match met');
                            isDone = true;
                        }

                        return false;
                    }
                }

                // if we get here, the event didn't match any of the
                // changes wanted so we keep the change and try again
                // when a new event is received. we also push the event
                // onto the "events" array to be logged later if the
                // changes are never satisified for debugging purposes
                events.push(change);
                return true;
            });
        });

        if (isDone)
            changes.length = 0;

        if (changes.length === 0) {
            // no more changes to wait for, we're done!
            self.vs_logger.debug('vminfod watchForChanges all changes matched');
            done();
            return;
        }

        self.vs_logger.debug({remaining: changes.length, total: total},
            'vminfod watchForChanges %d/%d changes remaining',
            changes.length, total);
    }

    function onerror(e) {
        self.vs_logger.error({err: e}, 'vminfod stream error');
        done(e);
    }
    if (opts.catchErrors) {
        self.on('error', onerror);
    }

    function done(err, o) {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        if (opts.teardown || (opts.catchErrors && err)) {
            self.stop();
        }
        if (opts.catchErrors) {
            self.removeListener('error', onerror);
        }
        self.removeListener('readable', readable);
        isDone = true;
        cb(err, o);
    }

    function cancel(err, o) {
        if (isDone) {
            self.vs_logger.warn('vminfod watchForChanges cancelled after done');
        } else {
            self.vs_logger.debug('vminfod watchForChanges cancelled');
            done(err, o);
        }
    }

    return cancel;
};

/*
 * Create a new VminfodEventStream and manage an internal object that houses
 * all known vmobjs that is updated when a new event is seen
 *
 */
function VminfodWatcher(opts) {
    var self = this;

    assert(self instanceof VminfodWatcher, 'must be called with "new"');

    opts = opts || {};
    if (typeof (opts) === 'string')
        opts = {name: opts};

    var _log = opts.log || log;

    self.vw_name = opts.name || _log.fields.name;
    self.vw_logger = _log.child({client: self.vw_name});
    self.vw_vms = {};

    self.vw_vs = new VminfodEventStream({
        name: self.vw_name,
        log: self.vw_logger,
        parseReady: true
    });

    self.vw_vs.on('ready', function (ready_ev) {
        self.vw_vms = ready_ev.vms;
        self.emit('ready');
    });

    self.vw_vs.on('readable', function () {
        var ev;
        while ((ev = self.vw_vs.read())) {
            self._handle_event(ev);
        }
    });
}
util.inherits(VminfodWatcher, EventEmitter);

/*
 * Handle an incoming vminfod update
 */
VminfodWatcher.prototype._handle_event = function _handle_event(ev) {
    var self = this;

    assert.object(ev, 'ev');
    assert.string(ev.type, 'ev.type');

    switch (ev.type) {
    case 'create':
    case 'modify':
        self.vw_vms[ev.zonename] = ev.vm;
        break;
    case 'delete':
        delete self.vw_vms[ev.zonename];
        break;
    default:
        assert(false, 'unknown vminfod event type: ' + ev.type);
        break;
    }

    self.emit(ev.type, ev);
    self.emit('event', ev);
};

/*
 * return all vms
 */
VminfodWatcher.prototype.vms = function vminfod_watcher_vms() {
    var self = this;

    return self.vw_vms;
};

/*
 * return a specific vm
 */
VminfodWatcher.prototype.vm = function vminfod_watcher_vm(zonename) {
    var self = this;

    return self.vw_vms[zonename];
};

/*
 * stop the watcher
 */
VminfodWatcher.prototype.stop = function vminfod_watcher_stop() {
    var self = this;

    self.vw_vs.stop();
};

// check to see that all key=>value pairs in "a" are found in "b"
function objSameValues(a, b) {
    if (!a || typeof (a) !== 'object' || !b || typeof (b) !== 'object')
        return false;

    var match = true;

    Object.keys(a).forEach(function (k) {
        var ak = a[k];
        var bk = b[k];

        if (Array.isArray(ak)) {
            try {
                assert.arrayOfString(ak, 'a.' + k);
                ak = ak.join(',');
            } catch (e) {
            }
        }
        if (Array.isArray(bk)) {
            try {
                assert.arrayOfString(bk, 'b.' + k);
                bk = bk.join(',');
            } catch (e) {
            }
        }

        if (ak !== null && typeof (ak) === 'object') {
            if (!objSameValues(ak, bk))
                match = false;
        } else if (ak !== bk) {
            match = false;
        }
    });

    return match;
}

function makeUserAgent(name) {
    return util.format('%s - %s/%d (%s)',
        name || log.name,
        os.hostname(),
        process.pid,
        process.argv[1]);
}

/*
 * if called directly just hook a vminfo stream to stdout
 */
if (require.main === module) {
    var _vs = new VminfodEventStream();
    _vs.on('readable', function () {
        var ev;
        while ((ev = _vs.read()) !== null) {
            console.log(JSON.stringify(ev));
        }
    });
}
