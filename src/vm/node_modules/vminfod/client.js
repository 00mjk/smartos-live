/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2015, Joyent, Inc.
 *
 * Vminfod Client and EventStream class
 */

var http = require('http');
var stream = require('stream');
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus.js');
var bunyan = require('/usr/node/node_modules/bunyan');
var LineStream = require('/usr/node/node_modules/linestream.js');

module.exports = VminfodClient;
module.exports.VminfodClient = VminfodClient;
module.exports.VminfodEventStream = VminfodEventStream;

var log = bunyan.createLogger({
    level: 'debug',
    name: 'vminfod-client',
    streams: [
    {
        stream: process.stderr,
        level: 'debug'
    }
    ],
    serializers: bunyan.stdSerializers
});

/*
 * VminfodClient class
 */
function VminfodClient(opts) {
    var self = this;

    opts = opts || {};
    self.vc_host = opts.host || '127.0.0.1';
    self.vc_port = opts.port || 9090;
    self.vc_logger = opts.log || log;
}

/*
 * Perform a GET request to the Vminfod daemon.
 *
 * @param {Object|String} opts - options to pass to http.request, if this is a
 *                               string it is used as opts.path (the endpoint)
 * @param {Function} cb - callback of signature cb(err, data)
 *   - err - any possible error, including non-200 statusCode or failure to
 *           parse JSON response
 *   - data - the JSON.parse'd data returned from the server
 * @return {HTTPRequest} req - the HTTP request object
 */
VminfodClient.prototype.get = function get(opts, cb) {
    var self = this;

    if (typeof (opts) === 'string')
        opts = {path: opts};
    assert.object(opts, 'opts');

    var reqOpts = {
        host: self.vc_host,
        port: self.vc_port,
        method: 'GET'
    };
    Object.keys(opts).forEach(function (key) {
        reqOpts[key] = opts[key];
    });

    var req = http.request(reqOpts, function (res) {
        if (res.statusCode !== 200) {
            var err = new Error('bad statusCode: ' + res.statusCode);
            err.code = err.statusCode = res.statusCode;
            res.destroy();
            cb(err);
            return;
        }

        res.setEncoding('utf8');
        var body = '';
        res.on('readable', function () {
            var chunk;
            while ((chunk = res.read()) !== null)
                body += chunk;
        });
        res.on('end', function () {
            try {
                var d = JSON.parse(body);
                cb(null, d);
            } catch (e) {
                cb(e);
            }
        });
    });
    req.on('error', function (e) {
        cb(e);
        req.destroy();
    });
    req.end();
    return req;
};

/*
 * shortcuts for common endpoints, eqivalent to:
 *   get('/status', cb), get('/vms', cb), etc.
 */
['status', 'vms', 'data'].forEach(function (s) {
    VminfodClient.prototype[s] = function (opts, cb) {
        if (typeof (opts) === 'function') {
            cb = opts;
            opts = {};
        }
        opts.path = '/' + s;
        return this.get(opts, cb);
    };
});

/*
 * Get a information for a specific vm given the zonename
 *
 * @param {String} zonename - the zonename (UUID most likely)
 * @param {Function} cb - same signature and usage as .get()
 */
VminfodClient.prototype.vm = function vm(zonename, cb) {
    var endpoint = '/vms/' + encodeURIComponent(zonename);
    return this.get(endpoint, cb);
};

/*
 * Return a new VminfodEventStream using the options
 * given to create this VminfodClient
 */
VminfodClient.prototype.createEventStream =
    function createEventStream(opts) {
    opts = opts || {};
    opts.host = this.vc_host || opts.host;
    opts.port = this.vc_port || opts.port;
    opts.log = this.vc_logger || opts.log;
    return new VminfodEventStream(opts);
};

/*
 * Create a new vminfod stream by creating a persistent HTTP request to vminfod
 *
 */
function VminfodEventStream(opts) {
    var self = this;

    // become a transform stream
    stream.Transform.call(self, {objectMode: true});

    // process opts
    opts = opts || {};
    self.vs_host = opts.host || '127.0.0.1';
    self.vs_port = opts.port || 9090;
    self.vs_logger = opts.log || log;
    self.start();
}
util.inherits(VminfodEventStream, stream.Transform);

/*
 * start the stream by opening a persistent HTTP connection
 */
VminfodEventStream.prototype.start = function start(opts) {
    var self = this;

    opts = opts || {};

    assert.ok(!self.vs_req, 'VminfodEventStream already started');

    var reqOpts = {
        host: self.vs_host,
        port: self.vs_port,
        method: 'GET',
        path: '/events'
    };
    Object.keys(opts).forEach(function (key) {
        reqOpts[key] = opts[key];
    });

    self.vs_req = http.request(reqOpts, function (res) {
        var e;
        if (res.statusCode !== 200) {
            e = new Error('bad statusCode: ' + res.statusCode);
            e.code = res.statusCode;
            res.destroy();
            self.vs_logger.error({err: e}, '%s', e.message);
            self.emit('error', e);
            return;
        }

        var ls = new LineStream();
        res.pipe(ls).pipe(self);
        res.on('end', function () {
            if (self.vs_req) {
                e = new Error('VminfodEventStream ended prematurely');
                self.vs_logger.error({err: e}, '%s', e.message);
                self.emit('error', e);
                return;
            }
        });
    });
    self.vs_req.setTimeout(0);
    self.vs_req.end();

    return self.vs_req;
};

/*
 * the transform method to process http body-by-line
 */
VminfodEventStream.prototype._transform =
function _transform(chunk, encoding, cb) {
    var line = chunk.toString('utf8');
    var ev;
    try {
        ev = JSON.parse(line);
        ev.ts = new Date(ev.ts);
    } catch (e) {
        // any JSON parse failure is a fatal error
        this.vs_logger.error({err: e, line: line},
            'failed to parse output line');
        this._abort();
        return;
    }

    if (ev.type === 'ack') {
        this.emit('ready');
    } else {
        this.push(ev);
    }
    cb();
};

/*
 * cleanly stop the VminfodEventStream by destroying the request
 */
VminfodEventStream.prototype.stop = function stop() {
    if (this.vs_req) {
        this.vs_req.destroy();
        this.vs_req = null;
    }
};

/*
 * same as above, but emit an error
 */
VminfodEventStream.prototype._abort = function _abort() {
    this.stop();
    var e = new Error('VminfodEventStream aborted');
    this.emit('error', e);
};

/*
 * watch for a specific event (with an optional timeout), and
 * optionally teardown the stream when it is received
 */
VminfodEventStream.prototype.watchForEvent =
function watchForEvent(obj, opts, cb) {
    var self = this;
    var events = [];
    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }
    assert.object(obj, 'obj');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.optionalBool(opts.teardown, 'opts.teardown');
    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
    assert.func(cb, 'cb');

    var timeout;
    if (opts.timeout) {
        timeout = setTimeout(function () {
            self.stop();
            self.vs_logger.error({events: events},
                'vminfod timeout exceeded - unmatched events');
            cb(new Error('timeout exceeded'));
        }, opts.timeout);
    }

    self.vs_logger.debug({obj: obj},
        'beginning watch for vminfod event');
    self.on('readable', readable);
    function readable() {
        var ev;
        while ((ev = self.read()) !== null) {
            events.push(ev);
            if (objSameValues(obj, ev)) {
                self.vs_logger.debug({obj: obj},
                    'matched vminfod event');
                done(null, ev);
                return;
            }
        }
    }

    function onerror(e) {
        self.vs_logger.error({err: e}, 'vminfod stream error');
        done(e);
    }
    if (opts.catchErrors) {
        self.on('error', onerror);
    }

    function done(err, o) {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        if (opts.teardown || (opts.catchErrors && err)) {
            self.stop();
        }
        if (opts.catchErrors) {
            self.removeListener('error', onerror);
        }
        self.removeListener('readable', readable);
        cb(err, o);
    }
};

/*
 * watch for one or more changes (with an optional timeout), and
 * optionally teardown the stream when it is received
 */
VminfodEventStream.prototype.watchForChanges =
function watchForChanges(obj, changes, opts, cb) {
    var self = this;
    var timeout;
    var events = [];

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }
    assert.object(obj, 'obj');
    assert.arrayOfObject(changes, 'changes');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.optionalBool(opts.teardown, 'opts.teardown');
    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
    assert.func(cb, 'cb');

    var total = changes.length;

    if (total === 0) {
        done();
        return;
    }

    if (opts.timeout) {
        timeout = setTimeout(function () {
            self.stop();
            self.vs_logger.error({events: events},
                'vminfod timeout exceeded - unmatched events');
            cb(new Error('timeout exceeded'));
        }, opts.timeout);
    }

    self.vs_logger.debug({changes: changes},
        'beginning watch for vminfod changes');
    self.on('readable', readable);
    function readable() {
        var ev;
        while ((ev = self.read()) !== null) {
            // filter out events that don't match our predicate (obj)
            if (!objSameValues(obj, ev))
                continue;

            self.vs_logger.debug({ev: ev},
                'inspecting possible match from vminfod');

            // loop changes found from vminfod
            (ev.changes || []).forEach(function (change) {
                // compare to changes we are looking for
                changes = changes.filter(function (wanted) {
                    var match = objSameValues(wanted, change);

                    if (match) {
                        self.vs_logger.debug({change: change, match: match},
                            'vminfod change match');
                    } else {
                        events.push(change);
                    }

                    return !match;
                });
            });

            self.vs_logger.debug({remaining: changes.length, total: total},
                '%d/%d changes remaining', changes.length, total);

            if (changes.length === 0) {
                // no more changes to wait for, we're done!
                self.vs_logger.debug('vminfod changes done');
                done();
                return;
            }
        }
    }

    function onerror(e) {
        self.vs_logger.error({err: e}, 'vminfod stream error');
        done(e);
    }
    if (opts.catchErrors) {
        self.on('error', onerror);
    }

    function done(err, o) {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        if (opts.teardown || (opts.catchErrors && err)) {
            self.stop();
        }
        if (opts.catchErrors) {
            self.removeListener('error', onerror);
        }
        self.removeListener('readable', readable);
        cb(err, o);
    }
};

// check to see that all key=>value pairs in "a" are found in "b"
function objSameValues(a, b) {
    if (!a || typeof (a) !== 'object' || !b || typeof (b) !== 'object')
        return false;

    var match = true;
    Object.keys(a).forEach(function (k) {
        if (a[k] !== null && typeof (a[k]) === 'object') {
            if (!objSameValues(a[k], b[k]))
                match = false;
        } else if (a[k] !== b[k]) {
            match = false;
        }
    });
    return match;
}

/*
 * if called directly just hook a vminfo stream to stdout
 */
if (require.main === module) {
    var _vs = new VminfodEventStream();
    _vs.on('readable', function () {
        var ev;
        while ((ev = _vs.read()) !== null) {
            console.log(JSON.stringify(ev));
        }
    });
}
