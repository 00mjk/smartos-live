/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2017, Joyent, Inc.
 *
 * This module exists to watch files for changes. It is somewhat similar to
 * node's fs.watch except:
 *
 *  * FsWatcher.watch() is asynchronous and optionally can call a callback when
 *    it actually starts watching.
 *  * FsWatcher works with files that do not exist yet, notifying you when they
 *    are created.
 *
 * To use you should do something like:
 *
 *  var fsw = new FsWatcher({log: log});
 *  fsw.once('ready', function () {
 *      fsw.watch('/path/to/some/file', function (err) { ... });
 *      fsw.unwatch('/path/to/some/file', function (err) { ... });
 *      fsw.status(function (err, obj) { ... });
 *      fsw.stop();
 *  });
 *  fsw.on(<event type>, callback(event));
 *  fsw.start();
 *
 * Where the event types can be:
 *
 *  * event - for any event
 *  * create - emitted when a file is created
 *  * change - emitted when a file is modified
 *  * delete - emitted when a file is deleted
 *
 * How this works:
 *
 *   This module is a wrapper around the fswatcher tool. That tool is driven by
 *   commands on STDIN which start and stop watches on files. Output goes to
 *   STDOUT (as json)  and is scraped by this module and turned into events.
 *
 * When `fsw.start()` is called, the companion fswatcher C program is started,
 * and a 'ready' event is emitted when the program is fully loaded and ready to
 * start receiving input.  Once it is ready, you may call .watch, .unwatch,
 * etc.
 *
 * When a file watch is attempted, the command to watch it is sent to the
 * fswatcher C program.  If it succeeds, the callback is fired immediately
 * and any new events for the file will be emitted when they are seen.  If
 * it fails however, a successful callback is still fired, but the file
 * is moved to a retry "interval".  The term interval is used here, but it's
 * actually a JavaScript setTimeout under the hood that calls itself as part
 * of the retry logic.
 *
 * The common case is, when a .watch() command is given, the file we want to
 * watch either exists or will exist very soon.  Because of this, if the initial
 * watch fails, that file specifically will be retried (the WATCH command sent
 * to the fswatcher program again) 10 times every 200ms - this is called the
 * INITIAL_WATCH_INTERVAL.  If it succeeds during this time, the timeout will
 * be cleared and a 'create' event for the file will be emitted.
 *
 * If the file fails the INITIAL_WATCH_INTERVAL, it will move over to the
 * LONG_WATCH_INTERVAL.  This is an interval (again, actually a setTimeout
 * that calls itself when finished) that runs every 5 seconds to retry every
 * file that does not yet exist.  This is a single interval that runs every
 * 5 seconds no matter what, and loops every file that we want to watch but
 * does not yet exist.  When a WATCH command succeeds for a file in this
 * interval it is removed from the "not_yet_watching" list and a 'create'
 * event for the file be emitted.
 *
 */

var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var bunyan = require('/usr/node/node_modules/bunyan');
var LineStream = require('/usr/node/node_modules/linestream');
var RingBuffer = require('/usr/vm/node_modules/bunyan').RingBuffer;
var vasync = require('/usr/vm/node_modules/vasync');

// default values

// when a file is watched but does not yet exist, FsWatcher will default to
// retry watching the file INITIAL_WATCH_TRIES (10) tries every
// INITIAL_WATCH_DELAY (200) milliseconds before transitioning the file
// to the long watch interval.
var INITIAL_WATCH_DELAY = 200;
var INITIAL_WATCH_TRIES = 10;

// when a file fails to be watched during its own initial watch interval it
// will be transferred to a longer class-wide interval that tries to watch
// all unwatched files every LONG_WATCH_DELAY (5000) milliseconds.
var LONG_WATCH_DELAY = 5 * 1000;

// maximum value of the request key to use - this is defined inside fswatcher.c
var FSWATCHER_MAX_KEY = 4294967295;

// illegal characters for filenames - this limitation is in fswatcher.c
var ILLEGAL_FILENAME_CHARS = ['\n', '\0'];

// companion C program that is our interface to event ports
var FSWATCHER_CMD = '/usr/vm/sbin/fswatcher';
if (process.env.FSWATCHER_CMD) {
    FSWATCHER_CMD = process.env.FSWATCHER_CMD;
}

// default logger if left unspecified
var LOG = bunyan.createLogger({
    level: 'debug',
    name: 'fswatcher',
    streams: [
    {
        stream: process.stderr,
        level: 'debug'
    }
    ],
    serializers: bunyan.stdSerializers
});

function noop() {}

function FsWatcher(opts) {
    var self = this;

    opts = opts || {};
    self.log = opts.log || LOG;

    // current state, set by .start and .stop
    self.stopped = true;

    // if we should dedup events from the same time (millisecond resolution)
    self.dedup = opts.dedup;

    // files currently being watched
    self.watching = {};

    // files that need to be watched but don't exist yet
    self.not_yet_watching = {};

    // see comments at the top of this file for "default values" for information
    // on these variables
    self.initial_watch_delay = opts.initial_watch_delay || INITIAL_WATCH_DELAY;
    self.initial_watch_tries = opts.initial_watch_tries || INITIAL_WATCH_TRIES;
    self.long_watch_delay = opts.long_watch_delay || LONG_WATCH_DELAY;
}
util.inherits(FsWatcher, EventEmitter);

// start the long interval
FsWatcher.prototype.start = function start() {
    var self = this;

    assert.ok(self.stopped, 'already running');

    self.stopped = false;
    self.stderr_buffer = new RingBuffer({limit: 100});
    self.cur_request_key = 0;
    self.pending_actions = {};

    // we store the previous event seen to use for deduplication purposes.
    // if the same exact event is seen (same timestamp in milliseconds as
    // well) every event after the first is thrown out.
    self.prev_event = {
        date: new Date(0)
    };

    // no matter what, this loop runs to watch any unwatched files
    function long_watch_interval() {
        self._watch_unwatched_files(function () {
            self.long_watch_timeout = setTimeout(long_watch_interval,
                self.long_watch_delay);
        });
    }
    self.long_watch_timeout = setTimeout(long_watch_interval,
        self.long_watch_delay);

    // start the companion C program
    self.watcher = cp.spawn(FSWATCHER_CMD, ['-r', '-j'], {stdio: 'pipe'});
    self.watcher_pid = self.watcher.pid;

    // stdout is newline separated JSON.  It is broken into lines
    // here and each raw line (String) is pushed on the vasync res_queue
    // that handles parsing and processing it.  A queue is used to add
    // a callback to processing a single line of stdout - this way, any
    // async work required by a stdout line is handled before a next line is
    // processed.
    var stdoutls = new LineStream();
    self.watcher.stdout.pipe(stdoutls).on('readable', function () {
        var line;
        while ((line = stdoutls.read()) !== null) {
            self.log.trace({line: line}, 'fswatcher stdout line');
            self.res_queue.push(line);
        }
    });

    // stderr can contain useful debugging information from the fswatcher
    // program, so all lines are output via log.trace(), and the last 10
    // lines are stored in a ring buffer and printed if a fatal error
    // occurs
    var stderrls = new LineStream();
    self.watcher.stderr.pipe(stderrls).on('readable', function () {
        var line;
        while ((line = stderrls.read()) !== null) {
            self.stderr_buffer.write(line);
            self.log.trace({line: line}, 'fswatcher stderr line');
        }
    });

    // handle watcher exiting.  if this is not the result of .stop(), we
    // error loudly
    self.watcher.on('close', function (code, signal) {
        var e = new Error('fswatcher exited');
        e.code = code;
        e.signal = signal;
        e.pid = self.watcher_pid;
        e.stderr = self.stderr_buffer.records.join('\n');

        self.watcher = null;
        self.watcher_pid = null;

        if (self.stopped) {
            self.log.debug({err: e, signal: signal, code: code, pid: e.pid},
                'fswatcher exited');
        } else {
            self.log.error({err: e, signal: signal, code: code, pid: e.pid},
                'fswatcher exited');
            self.log.error({dump: self.dump()},
                'fswatcher .dump()');
            self.log.error({stderr: e.stderr}, 'fswatcher stderr');
            self.emit('error', e);
        }
    });

    // this queue handles line-by-line stdout responses from the fswatcher.c
    // program
    self.res_queue = vasync.queue(function (line, cb) {
        if (self.stopped) {
            self.log.warn({line: line},
                'stdout received after .stop() instructed');
            cb();
            return;
        }

        var obj;
        try {
            obj = JSON.parse(line);
            assert.string(obj.type, 'stdout obj.type');
            assert.string(obj.date, 'stdout obj.date');
            obj.date = new Date(obj.date);
            assert.ok(isFinite(obj.date), 'stdout invalid obj.date');
        } catch (err) {
            self.log.error({
                line: line
            }, 'BAD JSON');
            throw err;
        }
        self.log.trace({obj: obj}, 'fswatcher event');

        // discard duplicate events
        if (self.dedup) {
            var o1 = deepClone(self.prev_event);
            var o2 = deepClone(obj);
            o1.date = o1.date.toISOString();
            o2.date = o2.date.toISOString();
            try {
                assert.deepEqual(o1, o2, 'duplicate object');
                // the same
                self.log.debug({obj: obj}, 'discarding duplicate object');
                process.nextTick(cb);
                return;
            } catch (err) {
                // not the same
                self.prev_event = deepClone(obj);
            }
        }

        switch (obj.type) {
        case 'ready':
            handleReady(obj, cb);
            break;
        case 'event':
            handleEvent(obj, cb);
            break;
        case 'response':
            handleResponse(obj, cb);
            break;
        case 'error':
        default:
            self.log.warn({obj: obj}, 'dispatching error');
            var e = new Error('dispatching error');
            throw e;
        }
    }, 1);

    function handleReady(obj, cb) {
        self.emit('ready', obj);
        cb();
    }

    function handleEvent(obj, cb) {
        assert.bool(obj.final, 'obj.final');
        assert.arrayOfString(obj.changes, 'obj.changes');
        assert.string(obj.pathname, 'obj.pathname');

        var f = obj.pathname;
        var w = self.watching[f];
        assert.object(w, 'not watching ' + obj.pathname);

        // UNWATCH is queued, ignore event
        if (!w.active) {
            cb();
            return;
        }

        // fswatcher.c is done watching this file, queue a rewatch
        if (obj.final) {
            self.log.debug({f: f}, 'file was final, queueing rewatch');
            delete self.watching[f];
            self.watch(f);
        }

        if (obj.changes.indexOf('FILE_MODIFIED') !== -1)
            obj.type = 'change';
        if (obj.changes.indexOf('FILE_RENAME_TO') !== -1)
            obj.type = 'change';
        if (obj.changes.indexOf('FILE_TRUNC') !== -1)
            obj.type = 'change';
        if (obj.changes.indexOf('FILE_DELETE') !== -1)
            obj.type = 'delete';
        if (obj.changes.indexOf('UNMOUNTED') !== -1)
            obj.type = 'delete';

        if (obj.final && obj.type !== 'delete') {
            /*
             * An event marked as "final" means that fswatcher.c will not
             * attempt to rewatch the file.  It's possible that a file could
             * be marked as "final" without a "delete" event being seen,
             * because of the asynchronous nature of filesystem events.
             *
             * In this case, we log a warning, and pretend it was a delete -
             * since the file is effectively gone for our purposes.
             */
            self.log.warn({obj: obj}, 'final event seen for non-delete type');
            obj.type = 'delete';
        }

        if (obj.type !== 'event')
            self.emit(obj.type, obj);
        self.emit('event', obj);
        cb();
    }

    function handleResponse(obj, cb) {
        assert.number(obj.key, 'obj.key');
        assert.number(obj.code, 'obj.code');
        assert.string(obj.result, 'obj.result');
        assert.optionalString(obj.pathname, 'obj.pathname');
        assert.optionalString(obj.message, 'obj.message');
        assert.optionalObject(obj.data, 'obj.data');

        var pa = self.pending_actions[obj.key];

        assert.object(pa, 'pending_action ' + obj.key);
        assert.func(pa.cb, 'pending_action.cb ' + obj.key);

        pa.cb(obj);
        delete self.pending_actions[obj.key];
        cb();
    }
};

// stop watching everything
FsWatcher.prototype.stop = function stop() {
    var self = this;

    assert.ok(!self.stopped, 'not running');

    self.stopped = true;

    // stop the watcher
    self.watcher.kill();

    // clear all watches that haven't been established yet
    Object.keys(self.not_yet_watching).forEach(function (f) {
        var o = self.not_yet_watching[f];

        if (o.timeout) {
            clearTimeout(o.timeout);
            o.timeout = null;
        }

        delete self.not_yet_watching[f];
    });

    // clear all existing watches
    self.watching = {};

    // stop the long_watch_interval
    clearTimeout(self.long_watch_timeout);
    self.long_watch_timeout = null;
};

// watch a file
FsWatcher.prototype.watch = function watch(f, cb) {
    var self = this;
    cb = cb || noop;

    var initial = true;

    assert.string(f, 'filename unspecified');
    assert.ok(!self.stopped, 'not running');
    assert.func(cb, 'cb');

    // validate filename
    var e = self._valid_filename(f);
    if (e) {
        cb(e);
        return;
    }

    // callback with an error if we've already been instructed to watch this
    // file
    if (self._is_watching(f)) {
        cb(new Error('already watchng ' + f));
        return;
    }

    // all new files start off in the 'not_yet_watching' bucket and are moved
    // to the 'watching' bucket when/if a call to `fs.watch(f)` is successful
    self.not_yet_watching[f] = {
        tries: 0,
        timeout: null,
        long_watch: false
    };

    // try to watch the file - this function will call itself multiple times
    // based on the values set in the constructor if it fails before moving
    // the file to the long interval
    try_watching();

    function try_watching() {
        var o = self.not_yet_watching[f];

        // watch was cancelled (probably shutting down or told to unwatch),
        // just give up
        if (!o) {
            if (initial) {
                initial = false;
                cb();
            }
            return;
        }

        o.timeout = null;

        // we've tried too many times, just give up and let the long
        // interval catch it
        if (o.tries >= self.initial_watch_tries) {
            self.log.trace('%s exceeded max tries, moving to long interval', f);
            o.long_watch = true;
            if (initial) {
                initial = false;
                cb();
            }
            return;
        }

        self._try_watching(f, function (err) {
            if (err) {
                o.tries++;
                o.timeout = setTimeout(try_watching, self.initial_watch_delay);
                self.log.trace('%d/%d %s watch failed',
                    o.tries, self.initial_watch_tries, f);
                if (initial) {
                    initial = false;
                    cb();
                }
                return;
            }

            // watch succeeded!
            self.watching[f] = {
                active: true
            };
            delete self.not_yet_watching[f];

            var obj = {
                type: 'create',
                date: new Date(),
                pathname: f
            };

            if (!initial) {
                self.emit('create', obj);
                self.emit('event', obj);
            }

            self.log.trace('%d/%d %s watch succeeded',
                o.tries, self.initial_watch_tries, f);

            if (initial) {
                initial = false;
                cb();
            }
        });
    }
};

// stop watching a file
FsWatcher.prototype.unwatch = function unwatch(f, cb) {
    var self = this;
    cb = cb || noop;

    assert.string(f, 'filename unspecified');
    assert.ok(!self.stopped, 'not running');
    assert.func(cb, 'cb');

    // validate filename
    var e = self._valid_filename(f);
    if (e) {
        cb(e);
        return;
    }

    if (self.watching[f]) {
        if (self.watching[f].active) {
            self.watching[f].active = false;
            var cmd = util.format('UNWATCH %s', f);
            self._send_command(cmd, function (obj) {
                delete self.watching[f];
                // assert.equal(obj.result, 'SUCCESS', 'unwatch success');
                cb();
            });
        } else {
            delete self.watching[f];
            cb();
        }
    } else if (self.not_yet_watching[f]) {
        if (self.not_yet_watching[f].timeout) {
            clearTimeout(self.not_yet_watching[f].timeout);
            self.not_yet_watching[f].timeout = null;
        }
        delete self.not_yet_watching[f];
        cb();
    } else {
        throw new Error('not watching ' + f);
    }
};

// get program status
FsWatcher.prototype.status = function status(cb) {
    var self = this;

    assert.ok(!self.stopped, 'not running');
    assert.func(cb, 'cb');

    self._send_command('STATUS', function (obj) {
        cb(null, obj);
    });
};

// send stdin to the watcher program and callback when stdout
// is receieved.  the `cmd` arg should look something like this:
//
//   'WATCH /path/to/file|12345'
//   'UNWATCH /other/path'
//
// a trailing newline character will be added if it is not present, and
// a key will be prepended to track the request as well.
FsWatcher.prototype._send_command = function _send_command(cmd, cb) {
    var self = this;

    assert.ok(!self.stopped, 'not running');

    // ensure the command has a trailing newline
    if (cmd[cmd.length - 1] !== '\n')
        cmd += '\n';

    // generate a unique key for the request, this will let us know
    // which response is meant for us
    var key = self._next_request_key();

    assert(!self.pending_actions[key], 'key already used: ' + key);

    cmd = util.format('%d %s', key, cmd);

    // when the response for this key is received, the callback will be called
    self.pending_actions[key] = {
        cmd: cmd,
        cb: cb
    };

    // write the command to the watcher
    self.log.trace({cmd: cmd.trim()}, 'writing to fswatcher stdin');
    self.watcher.stdin.write(cmd);
};

// generate the next index to use for a request
FsWatcher.prototype._next_request_key = function _next_request_key() {
    var self = this;

    self.cur_request_key = (self.cur_request_key + 1) % FSWATCHER_MAX_KEY;

    return self.cur_request_key;
};


// check if we are, or were instructed to, watch a file
FsWatcher.prototype._is_watching = function _is_watching(f) {
    var self = this;

    return self.watching.hasOwnProperty(f)
        || self.not_yet_watching.hasOwnProperty(f);
};

// validate a filename string - returns null on success and an
// Error object on failure
FsWatcher.prototype._valid_filename = function _valid_filename(f) {
    try {
        ILLEGAL_FILENAME_CHARS.forEach(function (c) {
            assert.equal(f.indexOf(c), -1, 'filename contains bad char ' + c);
        });
    } catch (e) {
        return e;
    }
    return null;
};

// try to watch all unwatched files - this will be called
// at an interval specified in the constructor options or at
// a default of every 5 seconds
FsWatcher.prototype._watch_unwatched_files =
    function _watch_unwatched_files(cb) {

    var self = this;

    var started = 0;
    var still_waiting = 0;

    vasync.forEachPipeline({
        inputs: Object.keys(self.not_yet_watching),
        func: function (f, cb2) {
            var o = self.not_yet_watching[f];

            // this interval only looks for files that are in the "long_watch"
            // bucket
            if (!o || !o.long_watch) {
                cb2();
                return;
            }

            self._try_watching(f, function (err) {
                if (err) {
                    // watch failed, still waiting for this file to exist
                    still_waiting++;
                    cb2();
                    return;
                }

                // watch succeeded! we can now emit a 'create' event
                // and stop waiting on this file to exist
                self.watching[f] = {
                    active: true
                };
                delete self.not_yet_watching[f];
                started++;

                var obj = {
                    type: 'create',
                    date: new Date(),
                    pathname: f
                };

                self.emit('create', obj);
                self.emit('event', obj);

                cb2();
            });
        }
    }, function (err) {
        if (started > 0 || still_waiting > 0) {
            self.log.debug('FsWatcher _watch_unwatched_files: '
                + 'started watching: %d, still waiting: %d',
                started, still_waiting);
        }

        cb();
    });
};

// send a command to watch the filename given, and callback when the response
// is seen.  an error is set if the file fails to watch, and no error on
// success
FsWatcher.prototype._try_watching = function _try_watching(f, cb) {
    var self = this;

    var cmd = util.format('WATCH %s', f);

    self._send_command(cmd, function (obj) {
        switch (obj.result) {
        case 'SUCCESS':
            cb(null, obj);
            break;
        case 'FAIL':
            cb(new Error(obj.message), obj);
            break;
        default:
            throw new Error('unknown result: ' + obj.result);
        }
    });
};

// dump current state
FsWatcher.prototype.dump = function _dump() {
var self = this;

    return {
        watching: Object.keys(self.watching),
        not_yet_watching: Object.keys(self.not_yet_watching),
        pending_actions: self.pending_actions,
        watcher_pid: self.watcher_pid,
        stopped: self.stopped
    };
};

module.exports.FsWatcher = FsWatcher;

function deepClone(src) {
    var dst;
    var key;

    if (src instanceof Date) {
        dst = src;
    } else if (Array.isArray(src)) {
        dst = [];
        src.forEach(function (e) {
            dst.push(deepClone(e));
        });
    } else if (typeof (src) === 'object') {
        dst = {};
        for (key in src) {
            dst[key] = deepClone(src[key]);
        }
    } else {
        dst = src;
    }

    return dst;
}

if (require.main === module) {
    var _f = process.argv[2];
    var fsw = new FsWatcher();
    fsw.once('ready', function (obj) {
        fsw.watch(_f, function () {
            console.log('watching %s', _f);
        });
    });
    fsw.on('event', function (ev) {
        console.log('new event: %j', ev);
    });
    fsw.start();
}
