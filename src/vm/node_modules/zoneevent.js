/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2017, Joyent, Inc.
 *
 * Substitute for 'zoneevent.c' that uses Vminfod or sysevents (as appropriate)
 * as an event source
 *
 */

var EventEmitter = require('events').EventEmitter;
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var bunyan = require('/usr/node/node_modules/bunyan');
var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');

var vminfod;
var VMINFOD_AVAILABLE;

try {
    vminfod = require('/usr/vm/node_modules/vminfod/client');
    VMINFOD_AVAILABLE = true;
} catch (e) {
    VMINFOD_AVAILABLE = false;
}

module.exports.ZoneEvent = ZoneEvent;

var LOG = bunyan.createLogger({
    level: 'fatal',
    name: 'zoneevent',
    stream: process.stderr,
    serializers: bunyan.stdSerializers
});

/*
 * ZoneEvent class
 */
function ZoneEvent(opts) {
    var self = this;

    var log;

    assert(self instanceof ZoneEvent, 'must be called with "new"');

    EventEmitter.call(self);

    opts = opts || {};
    if (typeof (opts) === 'string')
        opts = {name: opts};

    assert.object(opts, 'opts');
    assert.string(opts.name, 'opts.name');
    assert.optionalObject(opts.log, 'opts.log');
    assert.optionalString(opts.eventSource, 'opts.eventSource');

    log = opts.log || LOG;

    self.ze_name = opts.name;
    self.ze_logger = log.child({client: self.ze_name});
    self.ze_eventSource = opts.eventSource;

    if (!self.ze_eventSource) {
        self.ze_eventSource = VMINFOD_AVAILABLE ? 'vminfod' : 'sysevents';
    }
    self.ze_logger.info('starting ZoneEvent with "%s" event source',
        self.ze_eventSource);

    switch (self.ze_eventSource) {
    case 'vminfod':
        assert(VMINFOD_AVAILABLE, 'vminfod not available');
        self.startVminfod();
        break;
    case 'sysevents':
        self.startSysevents();
        break;
    default:
        assert(false, 'zw_eventSource not supported: ' + self.ze_eventSource);
        break;
    }
}
util.inherits(ZoneEvent, EventEmitter);

/*
 * Start the sysevent stream
 */
ZoneEvent.prototype.startSysevents = function startSysevents() {
    var self = this;

    // create a Sysevent stream
    var opts = {
        logger: self.ze_logger,
        class: 'status',
        channel: 'com.sun:zones:status'
    };

    self.se = new SyseventStream(opts);

    self.se.once('ready', function () {
        self.ze_logger.debug('ZoneEvent (sysevents) ready');
        self.emit('ready');
    });

    self.se.on('readable', function () {
        var ev;
        while ((ev = self.se.read()) !== null) {
            self._handleSysevent(ev);
        }
    });
};

/*
 * Handle an incoming sysevent update
 *
 * An example zone sysevent update will look like:
 * {
 *   "date": "2017-05-12T19:33:33.097Z",
 *   "type": "event",
 *   "vendor": "sun.com",
 *   "publisher": "kernel",
 *   "class": "status",
 *   "subclass": "change",
 *   "pid": 0,
 *   "data": {
 *     "zonename": "fb622681-3d62-413b-dc8a-c7515367464f",
 *     "newstate": "running",
 *     "oldstate": "ready",
 *     "zoneid": 463,
 *     "when": 1494617613097227800
 *   },
 *   "channel": "com.sun:zones:status"
 * }
 *
 */
ZoneEvent.prototype._handleSysevent = function _handleSysevent(ev) {
    var self = this;

    assert.object(ev, 'ev');
    assert.date(ev.date, 'ev.date');
    assert.object(ev.data, 'ev.data');
    assert.string(ev.data.zonename, 'ev.zonename');
    assert.string(ev.data.oldstate, 'ev.oldstate');
    assert.string(ev.data.newstate, 'ev.newstate');

    var obj = {
        zonename: ev.data.zonename,
        newstate: ev.data.newstate,
        oldstate: ev.data.oldstate,
        date: ev.date
    };

    self.emit('event', obj);
};

/*
 * Start the vminfod stream
 */
ZoneEvent.prototype.startVminfod = function startVminfod() {
    var self = this;

    self.ze_vs = new vminfod.VminfodEventStream({
        name: self.ze_name,
        log: self.ze_logger
    });

    self.ze_vs.once('ready', function (ready_ev) {
        self.ze_logger.debug('ZoneEvent (vminfod) ready');
        self.emit('ready');
    });

    self.ze_vs.on('readable', function () {
        var ev;
        while ((ev = self.ze_vs.read())) {
            self._handleVminfodEvent(ev);
        }
    });
};

/*
 * Handle an incoming vminfod update
 */
ZoneEvent.prototype._handleVminfodEvent = function _handleVminfodEvent(ev) {
    var self = this;

    assert.object(ev, 'ev');
    assert.date(ev.date, 'ev.date');
    assert.string(ev.type, 'ev.type');
    assert.string(ev.zonename, 'ev.zonename');

    self.ze_logger.trace({ev: ev}, 'processing vminfod event');

    var zoneupdated = false;
    var obj = {
        date: ev.date,
        zonename: ev.zonename
    };

    switch (ev.type) {
    case 'create':
        obj.oldstate = '';
        obj.newstate = ev.vm.zone_state;
        zoneupdated = true;
        break;
    case 'delete':
        obj.newstate = '';
        zoneupdated = true;
        break;
    case 'modify':
        assert.array(ev.changes, 'ev.changes');
        for (var i = 0; i < ev.changes.length; i++) {
            var change = ev.changes[i];
            if (change.path.length === 1
                && change.path[0] === 'zone_state') {

                obj.oldstate = change.from;
                obj.newstate = change.to;
                zoneupdated = true;
                break;
            }
        }
        break;
    default:
        assert(false, 'unknown vminfod event type: ' + ev.type);
        break;
    }

    if (zoneupdated) {
        /*
         * There is some discrepency with vminfod and sysevents, so we
         * translate the vminfod events to match what is expected by sysevent
         */
        if (obj.newstate === 'installed' && obj.oldstate !== 'incomplete') {
            obj.newstate = 'uninitialized';
        }
        if (obj.oldstate === 'installed') {
            obj.oldstate = 'uninitialized';
        }
        self.emit('event', obj);
    }
};

/*
 * stop the watcher
 */
ZoneEvent.prototype.stop = function vminfod_watcher_stop() {
    var self = this;

    switch (self.ze_eventSource) {
    case 'vminfod':
        self.ze_vs.stop();
        break;
    case 'sysevents':
        self.ze_se.stop();
        break;
    default:
        assert(false, 'unexpected eventSource: ' + self.ze_eventSource);
        break;
    }
};

/*
 * if called directly just hook a vminfo stream to stdout
 */
if (require.main === module) {
    var zw = new ZoneEvent('Module Run Directly');
    zw.on('event', function (ev) {
        console.log(JSON.stringify(ev));
    });
}
