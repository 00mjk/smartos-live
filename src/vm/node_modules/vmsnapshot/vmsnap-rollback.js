/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */


function performSnapshotRollback(snapshots, log, callback)
{
    assert(log, 'no logger passed to performSnapshotRollback()');

    // NOTE: we assume machine is stopped and snapshots are already validated

    function rollback(snapname, cb) {
        var args;

        args = ['rollback', '-r', snapname];
        zfs(args, log, function (zfs_err, fds) {
            if (zfs_err) {
                log.error({'err': zfs_err, 'stdout': fds.stdout,
                    'stderr': fds.stdout}, 'zfs rollback of ' + snapname
                    + ' failed.');
                cb(zfs_err);
                return;
            }
            log.info('rolled back snapshot ' + snapname);
            log.debug('zfs destroy stdout: ' + fds.stdout);
            log.debug('zfs destroy stderr: ' + fds.stderr);
            cb();
        });
    }

    async.forEachSeries(snapshots, rollback, function (err) {
        if (err) {
            log.error(err, 'Unable to rollback some datasets.');
        }
        callback(err);
    });
}

function rollbackSnapshot(uuid, snapname, options, callback)
{
    var datasets = [];
    var failed = false;
    var log = options.log;
    var mount_snapshot = true;
    var mountpath;
    var mountpoint;
    var snapsuffix;
    var zoneroot;

    assert(options.log, 'missing log option to rollbackSnapshot()');
    assert(options.stopZone, 'missing stopZone option to rollbackSnapshot()');

    if (!validSnapshotName(snapname, log)) {
        // XXX error code?
        callback(new Error('Invalid snapshot name'));
        return;
    }

    snapsuffix = '@vmsnap-' + snapname;

    // Ensure we have all the fields we need to make a snapshot
    [
        'brand',
        'snapshots',
        'uuid',
        'zfs_filesystem',
        'zone_state',
        'zonename',
        'zonepath'
    ].forEach(function (prop) {
        assert(vmobj.hasOwnProperty(prop), 'vmobj missing property: ' + prop);
    });

    zoneroot = path.join(vmobj.zonepath, '/root');
    mountpath = path.join('/checkpoints', snapname);
    mountpoint = path.join(zoneroot, mountpath);

    async.waterfall([
        function (cb) {
            // Ensure snapshot exists in VM list
            var exists = false;

            vmobj.snapshots.forEach(function (snap) {
                if (snap.name === snapname) {
                    exists = true;
                }
            });

            if (!exists) {
                cb(new Error('snapshot with name "' + snapname
                    + '" does not exist.'));
            } else {
                cb();
            }
        }, function (cb) {
            /*
             * zonepath/snapshots/snapname.json should exist if this snapshot
             * was created since OS-1750. If it does exist, we'll read the list
             * of datasets that were there at the time of snapshot and fail if
             * the current list of datasets is not the same.
             *
             * If snapname.json does *not* exist, we'll fail if there are any
             * datasets other than the zoneroot *now*. Because either the
             * snapshot was taken before OS-1750 when we only supported zones
             * with one dataset, or something has been corrupted in which case
             * we should fail so we can investigate and ensure things are safe
             * before rolling back.
             */


function rollbackSnapshot(uuid, snapname, options, callback)
{
    var load_fields;
    var log;

    ensureLogging(true);
    if (options.hasOwnProperty('log')) {
        log = options.log;
    } else {
        log = VM.log.child({action: 'rollback_snapshot', vm: uuid});
    }

    if (!validSnapshotName(snapname, log)) {
        callback(new Error('Invalid snapshot name'));
        return;
    }

    load_fields = [
        'brand',
        'snapshots',
        'zfs_filesystem',
        'state',
        'uuid'
    ];

    VM.load(uuid, {fields: load_fields, log: log}, function (err, vmobj) {
        var found;
        var snap;
        var snapshot_list = [];

        if (err) {
            callback(err);
            return;
        }

        if (vmobj.brand === 'kvm') {
            callback(new Error('snapshots for KVM VMs currently unsupported'));
            return;
        }

        found = false;
        if (vmobj.hasOwnProperty('snapshots')) {
            for (snap in vmobj.snapshots) {
                if (vmobj.snapshots[snap].name === snapname) {
                    found = true;
                    break;
                }
            }
        }
        if (!found) {
            callback(new Error('No snapshot named "' + snapname + '" for '
                + uuid));
            return;
        }

        snapshot_list = [vmobj.zfs_filesystem + '@vmsnap-' + snapname];

        if (vmobj.state !== 'stopped') {
            VM.stop(vmobj.uuid, {'force': true, log: log}, function (stop_err) {
                if (stop_err) {
                    log.error(stop_err, 'failed to stop VM ' + vmobj.uuid
                        + ': ' + stop_err.message);
                    callback(stop_err);
                    return;
                }
                performSnapshotRollback(snapshot_list, log,
                    function (rollback_err) {

                    if (rollback_err) {
                        log.error(rollback_err, 'failed to '
                            + 'performSnapshotRollback');
                        callback(rollback_err);
                        return;
                    }
                    if (options.do_not_start) {
                        callback();
                    } else {
                        VM.start(vmobj.uuid, {}, {log: log}, callback);
                    }
                    return;
                });
            });
        } else {
            performSnapshotRollback(snapshot_list, log,
                function (rollback_err) {

                if (rollback_err) {
                    log.error(rollback_err, 'failed to '
                        + 'performSnapshotRollback');
                    callback(rollback_err);
                    return;
                }
                if (options.do_not_start) {
                    callback();
                } else {
                    VM.start(vmobj.uuid, {}, {log: log}, callback);
                }
                return;
            });
        }
    });
};

