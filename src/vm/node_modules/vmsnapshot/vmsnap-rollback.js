/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var cp = require('child_process');
var execFile = cp.execFile;
var fs = require('fs');
var path = require('path');
var props = require('/usr/vm/node_modules/props');
var utils = require('utils');
var validSnapshotName = require('./vmsnap-validate').validSnapshotName;
var vmsnap_utils = require('./vmsnap-utils');

// load generated tables of data
var BRAND_OPTIONS = props.BRAND_OPTIONS;

// utils
var getSnapshotable = vmsnap_utils.getSnapshotable;
var trim = utils.trim;

// XXX replace with common one:
function zfs(args, log, callback)
{
    var cmd = '/usr/sbin/zfs';

    assert(log, 'no logger passed to zfs()');

    log.debug(cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            callback(error, {'stdout': stdout, 'stderr': stderr});
        } else {
            callback(null, {'stdout': stdout, 'stderr': stderr});
        }
    });
}

// XXX replace with common one:
function updateZonecfgTimestamp(vmobj, callback)
{
    var file;
    var now;

    assert(vmobj.zonename, 'updateZonecfgTimestamp() vmobj must have '
        + '.zonename');

    file = path.join('/etc/zones/', vmobj.zonename + '.xml');
    now = new Date();

    fs.utimes(file, now, now, callback);
}

function performSnapshotRollback(snapshots, log, callback)
{
    assert(log, 'no logger passed to performSnapshotRollback()');

    // NOTE: this assumes machine is stopped and snapshots are already validated

    function rollback(snapname, cb) {
        var args;

        args = ['rollback', '-r', snapname];
        zfs(args, log, function (zfs_err, fds) {
            if (zfs_err) {
                // XXX: If rollback fails here, Operator likely will need to be
                // involved with fixing things.
                log.error({
                    err: zfs_err,
                    stdout: fds.stdout,
                    stderr: fds.stdout
                }, 'zfs rollback of ' + snapname + ' failed.');
                cb(zfs_err);
                return;
            }
            log.info('rolled back snapshot ' + snapname);
            log.debug({
                stdout: fds.stdout,
                stderr: fds.stdout
            }, 'zfs destroy output');
            cb();
        });
    }

    async.forEachSeries(snapshots, rollback, function (err) {
        if (err) {
            log.error(err, 'Unable to rollback some datasets.');
        }
        callback(err);
    });
}

function rollbackSnapshot(vmobj, snapname, options, callback)
{
    var datasets = [];
    var log = options.log;
    var snaps_to_rollback = [];
    var snapsuffix;
    var stopZone;

    assert(options.log, 'missing log option to rollbackSnapshot()');
    assert(options.stopZone, 'missing stopZone option to rollbackSnapshot()');

    if (!validSnapshotName(snapname, log)) {
        // XXX error code?
        callback(new Error('Invalid snapshot name'));
        return;
    }

    snapsuffix = '@vmsnap-' + snapname;

    // stopZone() should be a function to call to stop this zone if we need to.
    stopZone = options.stopZone;

    // Ensure we have all the fields we need to make a snapshot
    [
        'brand',
        'snapshots',
        'uuid',
        'zfs_filesystem',
        'zone_state',
        'zonename',
        'zonepath'
    ].forEach(function (prop) {
        assert(vmobj.hasOwnProperty(prop), 'vmobj missing property: ' + prop);
    });

    async.waterfall([
        function (cb) {
            // Ensure snapshot exists in VM list
            var exists = false;

            vmobj.snapshots.forEach(function (snap) {
                if (snap.name === snapname) {
                    exists = true;
                }
            });

            if (!exists) {
                cb(new Error('snapshot with name "' + snapname
                    + '" does not exist.'));
            } else {
                cb();
            }
        }, function (cb) {
            // Find all the snapshotable datasets so we know what we have *now*
            getSnapshotable(vmobj, options, function _getSnapshotableCB(e, ds) {
                if (e) {
                    cb(e);
                    return;
                }

                datasets = ds;
                cb();
            });
        }, function (cb) {
            /*
             * zonepath/snapshots/snapname.json should exist if this snapshot
             * was created since OS-1750. If it does exist, we'll read the list
             * of datasets that were there at the time of snapshot and fail if
             * the current list of datasets is not the same.
             *
             * If snapname.json does *not* exist, we'll fail if there are any
             * datasets other than the zoneroot *now*. Because either the
             * snapshot was taken before OS-1750 when we only supported zones
             * with one dataset, or something has been corrupted in which case
             * we should fail so we can investigate and ensure things are safe
             * before rolling back.
             */

            var snapdir = path.join(vmobj.zonepath, '/snapshots');
            var snapfile = path.join(snapdir, snapname + '.json');
            var snapobj;
            var snapobj_snaps = [];

            fs.readFile(snapfile, function (err, data) {
                if (err) {
                    if (err.code !== 'ENOENT') {
                        cb(err);
                        return;
                    }

                    // In ENOENT case, we're just checking whether there are
                    // non-zoneroot datasets, if so: fail.
                    if (datasets.length !== 1
                        || datasets[0] !== vmobj.zfs_filesystem) {

                        log.error({datasets: datasets}, 'no ' + snapfile
                            + ' in ' + snapdir + ', currently have more than '
                            + 'zoneroot');
                        cb(new Error('cannot snapshot zone with multiple '
                            + 'datasets without ' + snapfile));
                        return;
                    }

                    // We only have zoneroot now and have no indication there
                    // was ever more than that, so we'll allow rollback of that.
                    snaps_to_rollback = [vmobj.zfs_filesystem + snapsuffix];
                    cb();
                    return;
                }

                // No errors, so we have snapshots/<snapname>.json
                try {
                    snapobj = JSON.parse(data.toString());
                } catch (e) {
                    log.error({err: e}, 'Failed to parse JSON from '
                        + snapfile);
                    cb(e);
                    return;
                }

                // Compare snapobj.datasets to datasets (current)
                if (!snapobj.hasOwnProperty('datasets')
                    || snapobj.datasets.length != datasets.length) {

                    log.error({
                        datasets: datasets,
                        snapobj_datasets: snapobj.datasets
                    }, 'current number of datasets does not match ' + snapfile);
                    cb(new Error('current number of datasets does not match '
                        + snapfile));
                    return;
                }

                snapobj.datasets.forEach(function (snapds) {
                    if (datasets.indexOf(snapds) === -1) {
                        log.error({
                            datasets: datasets,
                            snapobj_datasets: snapobj.datasets
                        }, 'dataset ' + snapds + ' no longer exists');
                        cb(new Error('dataset ' + snapds + ' no longer '
                            + 'exists'));
                        return;
                    }
                    snapobj_snaps.push(snapds + snapsuffix);
                });

                datasets.forEach(function (ds) {
                    if (snapobj.datasets.indexOf(ds) === -1) {
                        log.error({
                            datasets: datasets,
                            snapobj_datasets: snapobj.datasets
                        }, 'dataset ' + ds + ' did not exist at snapshot time');
                        cb(new Error('dataset ' + ds + ' did not exist at '
                            + 'snapshot time'));
                        return;
                    }
                });

                // If we got here, the current set of datasets matches the set
                // of datasets we had at snapshot time, so add them all to the
                // list of datasets we'll try to roll back now.
                snaps_to_rollback = snapobj_snaps;
                cb();
                return;
            });
        }, function (cb) {
            // We have a list of snapshots we want to rollback, ensure they all
            // exist at this point.
            var args = ['list', '-H', '-o', 'name', '-t', 'snapshot'];
            var msg;
            var snaps;

            args = args.concat(snaps_to_rollback);

            zfs(args, log, function (zfs_err, fds) {
                if (zfs_err) {
                    log.error({
                        err: zfs_err,
                        snaps_to_rollback: snaps_to_rollback,
                        stdout: fds.stdout,
                        stderr: fds.stdout
                    }, 'grabbing snapshot list failed.');
                    cb(zfs_err);
                    return;
                }

                snaps = trim(fds.stdout).split('\n');
                if (snaps.length !== snaps_to_rollback.length) {
                    msg = 'incorrect number of snapshots from zfs for '
                        + snapname + ': ' + snaps.length + ' expected: '
                        + snaps_to_rollback.length;
                    log.error({
                        snaps: snaps,
                        snaps_to_rollback: snaps_to_rollback,
                        stdout: fds.stdout
                    }, msg);
                    cb(new Error(msg));
                    return;
                }

                // Same length and we passed in our list, so just check sanity.
                snaps_to_rollback.forEach(function (snap) {
                    if (snaps.indexOf(snap) === -1) {
                        msg = 'missing snapshot ' + snap + ' for ' + vmobj.uuid;
                        log.error({
                            snaps_to_rollback: snaps_to_rollback,
                            stdout: fds.stdout
                        }, msg);
                        cb(new Error(msg));
                        return;
                    }
                });

                // We have everything we need!
                log.debug('we seem to have all snapshots for ' + snapname
                    + ' for ' + vmobj.uuid);
                cb();
            });
        }, function (cb) {
            // looks like we can roll back, need to ensure the zone is stopped.

            if (vmobj.zone_state !== 'installed') {
                log.debug('VM ' + vmobj.uuid + ' has state "' + vmobj.zone_state
                    + '", attempting to stop');
                stopZone(cb);
            } else {
                log.debug('VM ' + vmobj.uuid + ' has state "installed", no need'
                    + ' to stop');
                cb();
            }
        }, function (cb) {
            /*
             * If we get here we assume:
             *
             *  - zone is stopped
             *  - vmsnap-snapname exists
             *  - we have vmsnap-snapname on all datasets we should rollback
             *
             * So now we'll rollback each of the snapshots. XXX: The caller is
             * responsible for starting the VM back up.
             *
             */
            log.debug({snapshots: snaps_to_rollback}, 'rolling back snapshots');
            performSnapshotRollback(snaps_to_rollback, log, function (err) {
                if (err) {
                    log.error({err: err, snapshots: snaps_to_rollback},
                        'failed to roll back snapshots');
                } else {
                    log.debug({snapshots: snaps_to_rollback}, 'rolled back '
                        + 'snapshots');
                }
                cb(err);
            });
        }, function (cb) {
            // update timestamp so last_modified gets bumped
            updateZonecfgTimestamp(vmobj, function (e) {
                if (e) {
                    log.warn(e, 'failed to update timestamp after rollback');
                }
                // ignore error since there's no recovery
                // (snapshot was rolled back)
                cb();
            });
        }
    ], function (err) {
        callback(err);
    });
}

module.exports = {
    rollbackSnapshot: rollbackSnapshot
};
