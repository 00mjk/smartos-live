/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var cp = require('child_process');
var execFile = cp.execFile;
var fs = require('fs');
var path = require('path');
var utils = require('utils');
var validSnapshotName = require('./vmsnap-validate').validSnapshotName;
var vmsnap_utils = require('./vmsnap-utils');

// utils
var assertSafeZonePath = utils.assertSafeZonePath;
var getSnapshotable = vmsnap_utils.getSnapshotable;

// XXX replace with common one:
function zfs(args, log, callback)
{
    var cmd = '/usr/sbin/zfs';

    assert(log, 'no logger passed to zfs()');

    log.debug(cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            callback(error, {'stdout': stdout, 'stderr': stderr});
        } else {
            callback(null, {'stdout': stdout, 'stderr': stderr});
        }
    });
}

// XXX replace with common one:
function updateZonecfgTimestamp(vmobj, callback)
{
    var file;
    var now;

    assert(vmobj.zonename, 'updateZonecfgTimestamp() vmobj must have '
        + '.zonename');

    file = path.join('/etc/zones/', vmobj.zonename + '.xml');
    now = new Date();

    fs.utimes(file, now, now, callback);
}

function createSnapshot(vmobj, snapname, options, callback)
{
    var datasets = [];
    var failed = false;
    var log = options.log;
    var mount_snapshot = true;
    var mountpath;
    var mountpoint;
    var snapsuffix;
    var zoneroot;

    assert(options.log, 'missing log option to createSnapshot()');

    if (!validSnapshotName(snapname, log)) {
        // XXX error code?
        callback(new Error('Invalid snapshot name'));
        return;
    }

    snapsuffix = '@vmsnap-' + snapname;

    // Ensure we have all the fields we need to make a snapshot
    [
        'brand',
        'snapshots',
        'uuid',
        'zfs_filesystem',
        'zone_state',
        'zonename',
        'zonepath'
    ].forEach(function (prop) {
        assert(vmobj.hasOwnProperty(prop), 'vmobj missing property: ' + prop);
    });

    zoneroot = path.join(vmobj.zonepath, '/root');
    mountpath = path.join('/checkpoints', snapname);
    mountpoint = path.join(zoneroot, mountpath);

    async.waterfall([
        function (cb) {
            // Ensure snapshot name not already used for this VM
            var exists = false;

            vmobj.snapshots.forEach(function (snap) {
                if (snap.name === snapname) {
                    exists = true;
                }
            });

            if (exists) {
                cb(new Error('snapshot with name "' + snapname
                    + '" already exists.'));
            } else {
                cb();
            }
        }, function (cb) {
            // Find all the snapshotable datasets.
            getSnapshotable(vmobj, options, function _getSnapshotableCB(e, ds) {
                if (e) {
                    cb(e);
                    return;
                }

                datasets = ds;
                cb();
            });
        }, function (cb) {
            // TODO:
            // Create <zonepath>/snapshots
            // Write <zonepath>/snapshots/snapname.json w/
            //   { datasets: [] }
            var newmode;
            var snapdir = path.join(vmobj.zonepath, '/snapshots');
            var snapfile = path.join(snapdir, snapname + '.json');

            /*jsl:ignore*/
            newmode = 0755;
            /*jsl:end*/

            fs.mkdir(snapdir, newmode, function _mkSnapshotsDir(e) {
                var data;

                if (e && e.code !== 'EEXIST') {
                    log.error({err: e}, 'unable to create snapshots dir: '
                        + e.message);
                    cb(e);
                    return;
                }

                data = JSON.stringify({datasets: datasets}, null, 2) + '\n';

                /*
                 * Write the datasets we're snapshotting into the file. If for
                 * some reason we fail from this point on, the file will exist
                 * and vmadmd should eventually clean up files here that don't
                 * have actual snapshots attached. These won't cause any harm.
                 */
                fs.writeFile(snapfile, data, function _writeSnapshotFileCB(err) {
                    if (err) {
                        log.error({err: err, data: data}, 'failed to write '
                            + snapfile);
                        cb(err);
                        return;
                    }

                    log.debug({data: data}, 'wrote dataset info to ' + snapfile);
                    cb();
                });
            });
        }, function (cb) {
            // Take the snapshot
            var args;
            var new_snapshots = [];

            log.info('Creating snapshot "' + snapname
                + '" for datasets: ' + JSON.stringify(datasets));

            datasets.forEach(function (dataset) {
                new_snapshots.push(dataset + snapsuffix);
            });
            args = ['snapshot'].concat(new_snapshots);

            zfs(args, log, function (zfs_err, fds) {
                if (zfs_err) {
                    log.error({err: zfs_err, stdout: fds.stdout,
                        stderr: fds.stdout}, 'zfs snapshot failed.');
                } else {
                    log.debug({err: zfs_err, stdout: fds.stdout,
                        stderr: fds.stderr}, 'zfs ' + args.join(' '));
                }
                cb(zfs_err);
            });
        }, function (cb) {
            // If VM is running and not KVM (TODO check features), attempt to
            // mount the snapshot of zoneroot on /checkpoints

            if (vmobj.zone_state !== 'running') {
                log.info('Not mounting zoneroot snapshot as zone is in state '
                    + vmobj.zone_state + ', must be: running');
                mount_snapshot = false;
                cb();
                return;
            }

            if (vmobj.brand === 'kvm') {
                log.info('Not mounting zoneroot snapshot for KVM VM '
                    + vmobj.uuid);
                mount_snapshot = false;
                cb();
                return;
            }

            // Ensure it's safe for us to be doing something in this dir
            try {
                assertSafeZonePath(zoneroot, mountpath,
                    {type: 'dir', enoent_ok: true});
            } catch (e) {
                log.error(e, 'Unsafe mountpoint for checkpoints: '
                    + e.message);
                cb(e);
                return;
            }
            cb();

        }, function (cb) {
            // Make the mountpoint directory and parent
            var newmode;

            if (mount_snapshot === false) {
                cb();
                return;
            }

            /*jsl:ignore*/
            newmode = 0755;
            /*jsl:end*/

            function doMkdir(dir, callbk) {
                fs.mkdir(dir, newmode, function (e) {
                    if (e && e.code !== 'EEXIST') {
                        log.error({err: e}, 'unable to create mountpoint '
                            + 'for checkpoints: ' + e.message);
                        callbk(e);
                        return;
                    }
                    callbk();
                });
            }

            doMkdir(path.dirname(mountpoint), function (parent_e) {
                if (parent_e) {
                    cb(parent_e);
                    return;
                }
                doMkdir(mountpoint, function (dir_e) {
                    if (dir_e) {
                        cb(dir_e);
                        return;
                    }

                    log.debug('created ' + mountpoint);
                    cb();
                });
            });
        }, function (cb) {
            var argv;
            var cmd = '/usr/sbin/mount';
            var snapdir;

            if (mount_snapshot === false) {
                cb();
                return;
            }

            snapdir = vmobj.zonepath + '/.zfs/snapshot/vmsnap-' + snapname
                + '/root';
            argv = [ '-F', 'lofs', '-o', 'ro,setuid,nodevices', snapdir,
                mountpoint];

            execFile(cmd, argv, function (e, stdout, stderr) {
                if (e) {
                    log.error({err: e}, 'unable to mount snapshot: '
                        + e.message);
                }
                // not fatal becase snapshot was already created.
                cb();
            });
        }, function (cb) {
            // update timestamp so last_modified gets bumped
            updateZonecfgTimestamp(vmobj, function (e) {
                if (e) {
                    log.warn(e,
                        'failed to update timestamp after snapshot');
                }
                // ignore error since there's no recovery
                // (snapshot was created)
                cb();
            });
        }
    ], function (error) {
        callback(error);
    });
}

module.exports = {
    createSnapshot: createSnapshot
};
