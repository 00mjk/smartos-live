/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var validSnapshotName = require('./vmsnap-validate').validSnapshotName;

function createSnapshot(vmobj, snapname, options, callback)
{
    var datasets = [];
    var failed = false;
    var log = options.log;
    var new_snapshots = [];
    var snapsuffix;

    assert(options.log, 'missing log option to createSnapshot()');

    if (!validSnapshotName(snapname, log)) {
        // XXX error code?
        callback(new Error('Invalid snapshot name'));
        return;
    }

    snapsuffix = '@vmsnap-' + snapname;

    // Ensure we have all the fields we need to make a snapshot
    [
        'brand',
        'snapshots',
        'uuid',
        'zfs_filesystem',
        'zone_state',
        'zonename',
        'zonepath'
    ].forEach(function (prop) {
        assert(vmobj.hasOwnProperty(prop), 'vmobj missing property: ' + prop);
    });

    // add zoneroot
    datasets.push(vmobj.zfs_filesystem);

    // XXX TODO: check brand property instead
    if (vmobj.brand === 'kvm') {
        assert(vmobj.hasOwnProperty('disks'), 'vmobj missing "disks"');
        vmobj.disks.forEach(function (disk) {
            assert(disk.zfs_filesystem, 'disk missing zfs_filesystem: '
                + JSON.stringify(disk));
            datasets.push(disk.zfs_filesystem);
        });
    } else {
        assert(Array.isArray(vmobj.datasets), 'vmobj missing "datasets"');
    }

    /*
     * Add datasets if they're attached, regardless of brand. This will include
     * any delegated datasets.
     */
    if (Array.isArray(vmobj.datasets) && vmobj.datasets.length > 0) {
        datasets = datasets.concat(vmobj.datasets);
    }

    // Ensure snapshot name not already used for this VM
    vmobj.snapshots.forEach(function (snap) {
        if (failed) {
            return;
        }
        if (snap.name === snapname) {
            failed = true;
            callback(new Error('snapshot with name "' + snapname + '" already '
                + 'exists.'));
            return;
        }
    });
    if (failed) {
        return;
    }

    // XXX TODO: write vmobj dataset data to zones/<uuid>/config?

    log.debug('createSnapshot() will make snapshot ' + snapname + ' for '
        + 'datasets: ' + JSON.stringify(datasets));
    log.info('Taking snapshot "' + snapname + '" of VM ' + vmobj.uuid);

    datasets.forEach(function (dataset) {
        new_snapshots.push(dataset + snapsuffix);
    });

    log.debug('zfs snapshot ' + new_snapshots.join(' '));

    callback();
}

exports.create_snapshot = function (uuid, snapname, options, callback)
{

        // Check that name not already used
        if (vmobj.hasOwnProperty('snapshots')) {
        }

        snapshot_list.push(full_snapname);

        // assert snapshot_list.length > 0

        log.info('Taking snapshot "' + snapname + '" of ' + uuid);

        zoneroot = vmobj.zonepath + '/root';
        mountpath = '/checkpoints/' + snapname;
        mountpoint = zoneroot + '/' + mountpath;

        async.waterfall([
            function (cb) {
                // take the snapshot
                var args;
                args = ['snapshot'].concat(snapshot_list);

                zfs(args, log, function (zfs_err, fds) {
                    if (zfs_err) {
                        log.error({err: zfs_err, stdout: fds.stdout,
                            stderr: fds.stdout}, 'zfs snapshot failed.');
                    } else {
                        log.debug({err: zfs_err, stdout: fds.stdout,
                            stderr: fds.stderr}, 'zfs ' + args.join(' '));
                    }
                    cb(zfs_err);
                });
            }, function (cb) {

                if (vmobj.zone_state !== 'running') {
                    log.info('Not mounting snapshot as zone is in state '
                        + vmobj.zone_state + ', must be: running');
                    mount_snapshot = false;
                    cb();
                    return;
                }

                // Ensure it's safe for us to be doing something in this dir
                try {
                    assertSafeZonePath(zoneroot, mountpath,
                        {type: 'dir', enoent_ok: true});
                } catch (e) {
                    log.error(e, 'Unsafe mountpoint for checkpoints: '
                        + e.message);
                    cb(e);
                    return;
                }
                cb();
            }, function (cb) {
                // Make the mountpoint directory and parent
                var newmode;

                if (mount_snapshot === false) {
                    cb();
                    return;
                }

                /*jsl:ignore*/
                newmode = 0755;
                /*jsl:end*/

                function doMkdir(dir, callbk) {
                    fs.mkdir(dir, newmode, function (e) {
                        if (e && e.code !== 'EEXIST') {
                            log.error({err: e}, 'unable to create mountpoint '
                                + 'for checkpoints: ' + e.message);
                            callbk(e);
                            return;
                        }
                        callbk();
                    });
                }

                doMkdir(path.dirname(mountpoint), function (parent_e) {
                    if (parent_e) {
                        cb(parent_e);
                        return;
                    }
                    doMkdir(mountpoint, function (dir_e) {
                        if (dir_e) {
                            cb(dir_e);
                            return;
                        }

                        log.debug('created ' + mountpoint);
                        cb();
                    });
                });
            }, function (cb) {
                var argv;
                var cmd = '/usr/sbin/mount';
                var snapdir;

                if (mount_snapshot === false) {
                    cb();
                    return;
                }

                snapdir = vmobj.zonepath + '/.zfs/snapshot/vmsnap-' + snapname
                    + '/root';
                argv = [ '-F', 'lofs', '-o', 'ro,setuid,nodevices', snapdir,
                    mountpoint];

                execFile(cmd, argv, function (e, stdout, stderr) {
                    if (e) {
                        log.error({err: e}, 'unable to mount snapshot: '
                            + e.message);
                    }
                    // not fatal becase snapshot was already created.
                    cb();
                });
            }, function (cb) {
                // update timestamp so last_modified gets bumped
                updateZonecfgTimestamp(vmobj, function (e) {
                    if (e) {
                        log.warn(e,
                            'failed to update timestamp after snapshot');
                    }
                    // ignore error since there's no recovery
                    // (snapshot was created)
                    cb();
                });
            }
        ], function (error) {
            callback(error);
        });
};

module.exports = {
    createSnapshot: createSnapshot
};
