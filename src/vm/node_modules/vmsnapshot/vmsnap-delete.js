/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

// TODO XXX normalize error messages

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var cp = require('child_process');
var execFile = cp.execFile;
var fs = require('fs');
var path = require('path');
var utils = require('utils');
var validSnapshotName = require('./vmsnap-validate').validSnapshotName;
var vmsnap_utils = require('./vmsnap-utils');

// utils
var assertSafeZonePath = utils.assertSafeZonePath;
var getSnapshotable = vmsnap_utils.getSnapshotable;

// XXX replace with common one:
function zfs(args, log, callback)
{
    var cmd = '/usr/sbin/zfs';

    assert(log, 'no logger passed to zfs()');

    log.debug(cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            callback(error, {'stdout': stdout, 'stderr': stderr});
        } else {
            callback(null, {'stdout': stdout, 'stderr': stderr});
        }
    });
}

// XXX replace with common one:
function updateZonecfgTimestamp(vmobj, callback)
{
    var file;
    var now;

    assert(vmobj.zonename, 'updateZonecfgTimestamp() vmobj must have '
        + '.zonename');

    file = path.join('/etc/zones/', vmobj.zonename + '.xml');
    now = new Date();

    fs.utimes(file, now, now, callback);
}

function deleteSnapshot(vmobj, snapname, options, callback)
{
    var log = options.log;
    var mountpath;
    var mountpoint;
    var snapsuffix;
    var zoneroot;

    assert(options.log, 'missing log option to deleteSnapshot()');

    if (!validSnapshotName(snapname, log)) {
        // XXX error code?
        callback(new Error('invalid snapshot name'));
        return;
    }

    snapsuffix = '@vmsnap-' + snapname;

    // Ensure we have all the fields we need to make a snapshot
    [
        'brand',
        'snapshots',
        'uuid',
        'zfs_filesystem',
        'zone_state',
        'zonename',
        'zonepath'
    ].forEach(function (prop) {
        assert(vmobj.hasOwnProperty(prop), 'vmobj missing property: ' + prop);
    });

    zoneroot = path.join(vmobj.zonepath, '/root');
    mountpath = path.join('/checkpoints', snapname);
    mountpoint = path.join(zoneroot, mountpath);

    async.waterfall([
        function (cb) {
            // Ensure the named snapshot exists in vmobj.snapshots
            var exists = false;

            vmobj.snapshots.forEach(function _checkSnapshotInList(snap) {
                if (snap.name == snapname) {
                    exists = true;
                }
            });

            if (!exists) {
                cb(new Error('snapshot "' + snapname + '" does not exist'));
            } else {
                cb();
            }
        }, function (cb) {
            // Ensure it's safe for us to be doing something in the (potentially
            // mounted) checkpoint dir.

            try {
                assertSafeZonePath(zoneroot, mountpath,
                    {type: 'dir', enoent_ok: true});
            } catch (e) {
                log.error(e, 'Unsafe mountpoint for checkpoints: '
                    + e.message);
                cb(e);
                return;
            }
            cb();
        }, function (cb) {
            // Umount snapshot
            var argv;
            var cmd = '/usr/sbin/umount';

            argv = [mountpoint];

            execFile(cmd, argv, function (e, stdout, stderr) {
                if (!e) {
                    log.trace('umounted ' + mountpoint);
                } else if (stderr.match(/no such file or directory/)) {
                    // not existing isn't really an error
                    log.debug(mountpoint + ' does not exist for ' + vmobj.uuid);
                } else if (stderr.match(/ not mounted/)) {
                    // not being mounted also isn't really an error
                    log.debug(mountpoint + ' not mounted for ' + vmobj.uuid);
                } else {
                    log.error({
                        err: e,
                        stdout: stdout,
                        stderr: stderr
                    }, 'There was an error while unmounting the snapshot: '
                        + e.message);

                    cb(e);
                    return;
                }
                cb();
            });
        }, function (cb) {
            // Remove the mountpoint directory
            fs.rmdir(mountpoint, function (e) {
                if (e) {
                    log.error(e);
                } else {
                    log.trace('removed directory ' + mountpoint);
                }
                cb(); // XXX not fatal because might also not exist
            });
        }, function (cb) {
            /*
             * Find all snapshots with name @vmsnap-<snapname> on:
             *
             *  - zfs_filesystem (zoneroot)
             *  - datasets: [] (delegated)
             *  - disks: [] (kvm disks)
             *
             * and then destroy them.
             *
             */
            getSnapshotable(vmobj, options,
                function _getSnapshotableCB(err, datasets) {
                    var destroyed = 0;

                    if (err) {
                        cb(err);
                        return;
                    }

                    async.each(datasets, function _destroySnapshot(ds, next) {
                        var args;
                        args = ['destroy', ds + snapsuffix];
                        zfs(args, log, function (e, fds) {
                            var pattern;

                            pattern = /could not find any snapshots to destroy/;

                            if (e && !fds.stderr.match(pattern)) {
                                // only if the error was something other than
                                // not existing do we want to bail.
                                log.error({
                                    err: e,
                                    stdout: fds.stdout,
                                    stderr: fds.stderr
                                }, 'zfs destroy failed');
                                next(e);
                                return;
                            }
                            destroyed++;
                            log.debug({
                                err: e,
                                stdout: fds.stdout,
                                stderr: fds.stderr
                            }, 'zfs destroy ' + ds + snapsuffix);
                            next();
                        });
                    }, function _finishedDestroying(e) {
                        log.debug('destroyed ' + destroyed + ' component '
                            + 'snapshots');
                        if (!e && destroyed === 0) {
                            cb(new Error('failed to destroy any snapshots named'
                                + ' ' + snapname + ' for ' + vmobj.uuid));
                            return;
                        }
                        cb(e);
                    });
                }
            );
        }, function (cb) {
            // Cleanup snapshots json file created by create-snapshot
            var snapdir = path.join(vmobj.zonepath, '/snapshots');
            var snapfile = path.join(snapdir, snapname + '.json');

            fs.unlink(snapfile, function _unlinkSnapshotsFile(e) {
                log.debug({
                    err: e,
                    ecode: (e.code ? e.code : 'UNKNOWN')
                }, 'fs.unlink completed');
                /*
                 * We ignore errors here because if this file is left behind
                 * it should not cause the snapshot delete to fail. The
                 * snapshot(s) are actually gone so this metadata can be cleaned
                 * up later by vmadmd.
                 */
                cb();
            });
        }, function (cb) {
            updateZonecfgTimestamp(vmobj, function (e) {
                if (e) {
                    log.warn(e, 'failed to update timestamp after deleting '
                        + 'snapshot');
                }
                // don't pass err because there's no recovery possible
                // (the snapshot's gone)
                cb();
            });
        }
    ], function (error) {
        callback(error);
    });
}

module.exports = {
    deleteSnapshot: deleteSnapshot
};
