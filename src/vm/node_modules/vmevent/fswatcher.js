/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 * This module exists to watch files for changes. It is somewhat similar to
 * node's fs.watch except:
 *
 *  * FsWatcher.watch() is asynchronous
 *  * it emits an error event when a file cannot be watched
 *  * it works with files that do not exist yet
 *
 * To use you should do something like:
 *
 *  fsw = new FsWatcher(log);
 *  fsw.watch('/path/to/some/file');
 *
 * and then
 *
 *  CREATED
 *  MODIFIED (contents)
 *  DELETED
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var path = require('path');
var spawn = cp.spawn;
var util = require('util');

var FSWATCHER_CMD = '/root/fswatcher';


function FsWatcher(log)
{
    var stderr_buffer = '';
    var stdout_buffer = '';
    var stderr_chunks;
    var stdout_chunks;
    var self = this;

    assert(log, 'no logger passed to FsWatcher()');

    self.debug_ival = undefined;
    self.index = 0;
    self.log = log;
    self.pending_actions = {};
    self.prev_event = {}; // kept for deduplication
    self.watches = {};
    log.debug({cmdline: FSWATCHER_CMD}, 'executing fswatcher');
    self.watcher = spawn(FSWATCHER_CMD, [], {stdio: 'pipe'});
    self.watcher_pid = self.watcher.pid;
    log.debug('fswatcher running with pid ' + self.watcher_pid);

    self.debug_ival = setInterval(function () {
        log.trace({
            watches: self.watches,
            pending_actions: self.pending_actions
        }, 'current state');
    }, 5000);

    function dispatchObj(obj) {
        switch (obj.type) {
            case 'event':
                handleEvent(obj);
                break;
            case 'response':
                handleResponse(obj);
                break;
            case 'error':
            default:
                console.error('dispatching error!: ' + JSON.stringify(obj));
                break;
        }
    }

    function isDuplicate(obj) {
        log.trace({obj: obj, prev_obj: self.prev_event},
            'checking for duplicate');

        // TODO XXX should we treat +/- 10ms as same?
        if (obj.timestamp !== self.prev_event.timestamp) {
            return (false);
        }

        if (obj.pathname !== self.prev_event.pathname) {
            return (false);
        }

        if (JSON.stringify(obj.changes.sort())
            !== JSON.stringify(self.prev_event.changes.sort())) {

            return (false);
        }

        return (true);
    }

    function tryWatching(pathname) {
        var wobj;

        /*
         * A primary watch gets created and destroyed only when .watch() or
         * .unwatch() is called by the caller. We only try watching here when
         * we're dealing with a file that is intentionally being watched.
         */
        if (self.watches[pathname] && self.watches[pathname].primary) {
            wobj = {pathname: pathname, action: 'WATCH'};
            self.watch_queue.push(wobj);
        } else {
            log.debug('Ignoring tryWatching(' + pathname + '): not primary');
        }
    }

    self.queueAction = function (pathname, action, callback) {
        var wobj;

        wobj = {pathname: pathname, action: action};
        if (callback) {
            wobj.callback = callback;
        }
        self.watch_queue.push(wobj);
    };

    function handleEvent(obj) {
        var children = [];
        var pathname = obj.pathname;
        var parent_dir;

        // avoid sending 2 identical messages which could otherwise happen as
        // fswatcher.c does not prevent this.
        if (self.prev_event && isDuplicate(obj)) {
            log.trace({evt: obj}, 'ignoring duplicate event');
            return;
        }
        self.prev_event = obj;

        if (!self.watches.hasOwnProperty(pathname)) {
            log.warn({evt: obj}, 'ignoring event for unwatched file');
            return;
        }

        console.error('handleEvent: ' + JSON.stringify(obj, null, 2));

        // TODO: filter these objects

        // Send everything to the "all" channel
        self.emit('all', obj);

        if (obj.changes.indexOf('FILE_MODIFIED') !== -1) {
            self.emit('change', obj);
        }
        if (obj.changes.indexOf('FILE_DELETE') !== -1) {
            self.emit('delete', obj);
        }

        // XXX can we be smarter about clearing and recreating based on event
        // type?

        /*
         * If we got an event for a secondary watch, retry watching all the
         * children we're waiting for.
         */
        if (self.watches[pathname] && self.watches[pathname].secondary) {
            children = self.watches[pathname].children;
            self.watches[pathname].children = [];
            self.watches[pathname].secondary = false;

            if (obj.is_final) {
                self.watches[pathname].running = false;
            } else if (!self.watches[pathname].primary
                && self.watches[pathname].running) {

                log.error({
                    watches: self.watches,
                    pending: self.pending_actions
                }, 'unwatch 1');
                self.queueAction(pathname, 'UNWATCH');
            }

            if (!self.watches[pathname].primary) {
                delete self.watches[pathname];
            }

            Object.keys(children).forEach(function (child) {
                if (self.watches[child] && self.watches[child].primary) {
                    delete self.watches[child].parent_watch;
                    tryWatching(child);
                }
            });
        }

        if (self.watches[pathname] && self.watches[pathname].primary) {
            if (obj.is_final) {
                /*
                 * is_final means that the fswatcher is not going to rearm,
                 * possibly because the file was deleted. We attempt to re-add
                 * the watch here in this case which will cause a result and if
                 * we can't watch this file itself, we'll end up creating the
                 * appropriate secondary watch.
                 */
                // XXX self.watches[pathname].running = false?
                if (self.watches[pathname].parent_watch) {
                    parent_dir = self.watches[pathname].parent_watch;
                    if (self.watches[parent_dir]
                        && self.watches[parent_dir].children) {

                        delete self.watches[parent_dir].children[pathname];
                    }
                    delete self.watches[pathname].parent_watch;
                }
                tryWatching(obj.pathname);
            }
        }
    }

    function handleResponse(obj) {
        var action;
        var callback;
        var children = {};
        var err;
        var parent_dir;

        assert(self.pending_actions[obj.key]);

        log.trace({
            obj: obj,
            watch: self.watches[obj.pathname],
            pending_action: self.pending_actions[obj.key]
        }, 'handling response');
        parent_dir = path.dirname(obj.pathname);

        action = self.pending_actions[obj.key].action;
        callback = self.pending_actions[obj.key].callback;
        delete self.pending_actions[obj.key];

        if (obj.result == 'FAIL') {

            if (action === 'UNWATCH') {
                err = new Error('failed to unwatch ' + obj.pathname);
                log.error({obj: obj}, err.message);
                // XXX should we remove the watch here anyway?
                if (callback) {
                    callback(err);
                }
                return;
            }

            assert(action === 'WATCH');

            // XXX TODO should only do this after checking code?

            assert(obj.pathname !== parent_dir);

            if (self.watches[obj.pathname]
                && self.watches[obj.pathname].primary) {

                /*
                 * Attempt to watch primary failed, add secondary watch with
                 * this as child.
                 */
                if (!self.watches[parent_dir]) {
                    self.watches[parent_dir] = {
                        children: {},
                        primary: false,
                        running: false,
                        secondary: true
                    };
                }

                /* link */
                self.watches[parent_dir].secondary = true;
                self.watches[parent_dir].children[obj.pathname] = true;
                self.watches[obj.pathname].parent_watch = parent_dir;

                // XXX there's a race here if someone just did unwatch but it
                // hasn't succeeded yet, just try the WATCH always?
                if (!self.watches[parent_dir].running) {
                    self.queueAction(parent_dir, 'WATCH');
                }

                /*
                 * The initial WATCH failed, but we've queued a watch for the
                 * parent, so we'll call callback now.
                 */

                if (callback) {
                    callback();
                }
            } else if (self.watches[obj.pathname]
                && self.watches[obj.pathname].secondary) {

                if (!self.watches[parent_dir]) {
                    self.watches[parent_dir] = {
                        children: {},
                        primary: false,
                        running: false,
                        secondary: true
                    };
                }

                children = self.watches[obj.pathname].children;
                self.watches[obj.pathname].children = {};
                self.watches[obj.pathname].secondary = false;
                if (!self.watches[obj.pathname].primary) {
                    delete self.watches[obj.pathname];
                }

                /* link */
                self.watches[parent_dir].secondary = true;
                Object.keys(children).forEach(function (child) {
                    self.watches[parent_dir].children[child] = true;
                    self.watches[child].parent_watch = parent_dir;
                });

                // XXX there's a race here if someone just did unwatch but it
                // hasn't succeeded yet, just try the WATCH always?
                if (!self.watches[parent_dir].running) {
                    self.queueAction(parent_dir, 'WATCH');
                }

                if (callback) {
                    callback();
                }
            } else {
                // XXX received FAIL for something we're not watching?
                assert(false);
            }

        } else if (obj.result === 'SUCCESS') {

            /*
             * On success we'll always call callback here since we're not going
             * to send it an error object.
             */
            if (callback) {
                callback();
            }

            if (action === 'UNWATCH') {
                log.info({obj: obj}, 'SUCCEDED TO UNWATCH ' + obj.pathname);
                if (self.watches[obj.pathname]) {
                    self.watches[obj.pathname].running = false;
                    children = self.watches[obj.pathname].children;
                    assert(Object.keys(children).length === 0);
                }
                return;
            }

            assert(action === 'WATCH');

            if (self.watches[obj.pathname]) {
                self.watches[obj.pathname].running = true;
            }

            if (self.watches[obj.pathname]
                && self.watches[obj.pathname].primary) {

                /*
                 * If we're a primary we'll check for parents, if we have one
                 * we'll divorce ourselves from them.
                 */
                if (self.watches[obj.pathname].parent_watch) {
                    parent_dir = self.watches[obj.pathname].parent_watch;
                    delete self.watches[obj.pathname].parent_watch;
                    if (self.watches[parent_dir]) {
                        delete self.watches[parent_dir].children[obj.pathname];
                        children = self.watches[parent_dir].children;
                        if (Object.keys(children).length === 0) {
                            self.watches[parent_dir].secondary = false;
                        }
                        if (self.watches[parent_dir].secondary === false
                            && self.watches[parent_dir].primary === false) {
                            if (self.watches[parent_dir].running) {
                                log.error({
                                    watches: self.watches,
                                    pending: self.pending_actions
                                }, 'unwatch 3');
                                self.queueAction(parent_dir, 'UNWATCH');
                            }
                            delete self.watches[parent_dir];
                        }
                    }
                }

                if (!self.watches[obj.pathname].initial) {
                    /*
                     * We're a primary and this is not an initial watch, emit
                     * create, since file was just created.
                     */
                    log.trace('emitting CREATE');
                    self.emit('create', obj);
                }
            } else if (self.watches[obj.pathname]
                && self.watches[obj.pathname].secondary) {

                /*
                 * When a secondary-only watch succeeds, there's nothing special
                 * to do until it gets an event.
                 */
                log.debug('SECONDARY ' + obj.pathname + ' SUCCESS');
                fs.readdir(obj.pathname, function (e, files) {
                    // XXX
                    log.debug({files: files, pathname: obj.pathname},
                        'SECONDARY FILES');

                    if (!self.watches[obj.pathname]
                        || self.watches[obj.pathname].children) {

                        log.warn('secondary watch ' + obj.pathname
                            + ' has no children');
                        return;
                    }
                    children = self.watches[obj.pathname].children;

                    Object.keys(children).forEach(function (child) {
                        files.forEach(function (file) {
                            log.debug('checking ' + file + ' vs. ' + child);
                            if (child.length < file) {
                                /* too short to be a match */
                                return;
                            }
                            if (self.watches[obj.pathname]) {
                                /* if watch was deleted, we're done here */
                                log.debug(obj.pathname + ' was deleted?!');
                                return;
                            }

                            if ((child.substr(0, file.length) === file)
                                && ((child.length === file.length)
                                || (child[file.length] === '/'))) {

                                /* XXX this child might exist try to reparent */
                                delete self.watches[obj.pathname].children[child];
                                if (self.watches[obj.pathname].children.length === 0) {
                                    self.watches[obj.pathname].secondary = false;
                                    if (!self.watches[obj.pathname].primary) {
                                        if (self.watches[obj.pathname].running) {
                                            self.queueAction(obj.pathname, 'UNWATCH', function () {
                                                if (self.watches[obj.pathname].running) {
                                                    log.warn('watch for ' + obj.pathname + ' still running after unwatch');
                                                } else {
                                                    delete self.watches[obj.pathname];
                                                }
                                            });
                                        } else {
                                            delete self.watches[obj.pathname];
                                        }
                                    }
                                }
                            }
                        });
                    });
                });
            } else {
                assert('OMGWTFBBQ');
            }
        }

        /* no longer initial since we've seen a response */
        if (self.watches[obj.pathname]) {
            self.watches[obj.pathname].initial = false;
        }
    }

    function nextIndex() {

        if (self.index < 4294967295) {
            self.index++;
        } else {
            self.index = 1;
        }

        return (self.index);
    }

// XXX watch_Queue is a bad name if we also unwatch
    self.watch_queue = async.queue(function (obj, callback) {
        var action = obj.action;
        var pathname = obj.pathname;
        var idx;

        log.debug('watcher running with PID '
            + self.watcher_pid); // XXX DELETEME

        if (!self.watcher_pid) {
            /*
             * If watcher's not running, it should be restarting, so we add a
             * small delay and requeue. Since the next object won't be processed
             * from the queue until this one calls callback anyway, this means
             * we only delay small amounts for each object until the watchers
             * running again at which point we'll no longer get to this delay.
             */
            setTimeout(function _requeueAfterDelay() {
                self.watch_queue.push(obj);
                callback();
            }, 50);
            return;
        }

        idx = nextIndex();
        if (action === 'UNWATCH') {
            log.trace(idx + ' UNWATCH ' + pathname);
            // XXX self.watcher.stdin can be null here?!
            try {
                self.watcher.stdin.write(idx + ' UNWATCH ' + pathname + '\n');
            } catch (e) {
                log.error({unwatch_err: e}, 'failed to write UNWATCH: ' + e.message);
            }
        } else {
            assert(action === 'WATCH');
            log.trace(idx + ' WATCH ' + pathname);
            self.watcher.stdin.write(idx + ' WATCH ' + pathname + '\n');
        }

        /*
         * Every "action" should result in a response. We track actions we've
         * requested so that we can match them up when we get responses.
         */
        self.pending_actions[idx] = {action: action, pathname: pathname};
        if (obj.callback) {
            self.pending_actions[idx].callback = obj.callback;
        }

        callback();
    }, 1);

    self.watch_queue.drain = function () {
        // log.trace('watch_queue is empty');
    };

    self.watcher.stdout.on('data', function (data) {
        var chunk;
        var obj;

        stdout_buffer += data.toString();
        stdout_chunks = stdout_buffer.split('\n');
        while (stdout_chunks.length > 1) {
            chunk = stdout_chunks.shift();
            obj = JSON.parse(chunk);
            dispatchObj(obj);
        }
        stdout_buffer = stdout_chunks.pop();
    });

    self.watcher.stderr.on('data', function (data) {
        var chunk;

        stderr_buffer += data.toString();
        stderr_chunks = stderr_buffer.split('\n');
        while (stderr_chunks.length > 1) {
            chunk = stderr_chunks.shift();
            log.trace({stderr: chunk});
        }
        stderr_buffer = stderr_chunks.pop();
    });

    self.watcher.on('close', function (code) {
        // XXX do we need to call some callbacks here?

        log.warn('fswatcher ' + self.watcher_pid + ' exited: ',
            JSON.stringify(code));
        self.watcher_pid = null;

        // tell all the listeners of this zoneevent (if there are any) that
        // we exited.  Then null it out so next time we'll make a new one.
        // zoneevent.emit('zoneevent', new Error('zoneevent watcher exited '
            // + 'prematurely with code: ' + code));
        // fswatcher = null;
        console.log('XXX');

        // TODO if unexpected (ie, not shutdown()): restart
    });
}

util.inherits(FsWatcher, EventEmitter);

FsWatcher.prototype.watch = function (pathname, callback)
{
    var err = undefined;
    var self = this;

    var log = self.log;

    // XXX pathname must be absolute path

    if (self.watches[pathname]) {
        // This becomes a primary watch now whether it was or not before
        self.watches.primary = true;

        err = new Error('Already watching ' + pathname);
        // XXX use a code so caller can know this is not really an error
        log.warn(err);

        if (!self.watches[pathname].running) {
            self.queueAction(pathname, 'WATCH', callback);
        } else {
            /*
             * We're not starting a watch (because it's already running)
             * so call callback now if set
             */
            if (callback) {
                callback();
            }
        }
    } else {
        self.watches[pathname] = {
            initial: true,
            primary: true,
            running: false,
            secondary: false
        };
        self.queueAction(pathname, 'WATCH', callback);
        return; // callback will be called when we actually start watching.
    }
};

FsWatcher.prototype.unwatch = function (pathname, callback)
{
    var children;
    var err = undefined;
    var log;
    var parent_dir;
    var self = this;

    log = self.log;

    // XXX must be absolute path

    if (!self.watches.hasOwnProperty(pathname)) {
        // XXX use a code so caller can know this is not really an error
        err = new Error('Not watching ' + pathname);
        log.warn(err);
    } else if (!self.watches[pathname].primary) {
        // XXX use a code so caller can know this is not really an error
        err = new Error('No primary watch for ' + pathname);
        log.warn(err);
    }

    if (!err) {
        if (!self.watches[pathname].secondary) {
            /*
             * If we're not secondary, we only had primary watch so we can
             * totally remove the watch.
             */
            log.error({
                watches: self.watches,
                pending: self.pending_actions
            }, 'unwatch 4');
            self.queueAction(pathname, 'UNWATCH', callback);
            if (self.watches[pathname].parent_watch) {
                parent_dir = self.watches[pathname].parent_watch;
                if (self.watches[parent_dir]) {
                    delete self.watches[parent_dir].children[pathname];
                }
                children = self.watches[parent_dir].children;
                if (Object.keys(children).length === 0) {
                    self.watches[parent_dir].secondary = false;
                    if (!self.watches[parent_dir].primary) {
                        self.queueAction(parent_dir, 'UNWATCH');
                        delete self.watches[parent_dir];
                    }
                }
            }
            delete self.watches[pathname];
        } else {
            /*
             * If we are secondary, we just remove the primary flag because
             * someone is depending on this watch as a parent.
             */
            self.watches[pathname].primary = false;
            /* we're not going to UNWATCH, so call callback now */
            if (callback) {
                callback(err);
            }
        }
    } else {
        if (callback) {
            callback(err);
        }
    }

    // XXX also remove parents who are only watching because of this
};

/*
 * Return ths list of watched files.
 */
FsWatcher.prototype.watches = function ()
{
    var self = this;

    // XXX should only return primaries?
    return Object.keys(self.watches);
};

FsWatcher.prototype.shutdown = function ()
{
    var listeners = [];
    var self = this;
    var log = self.log;

    ['change', 'delete', 'create', 'all'].forEach(function (type) {
        listeners = self.listeners(type);
        log.debug('cleanup called w/ listeners(' + type + '): '
            + util.inspect(listeners));
        self.removeAllListeners(type);
    });

    log.debug('zoneevent watcher ' + self.watcher_pid + ' cleanup called');
    if (self.watcher) {
        self.watcher.stdout.destroy(); // so we don't send more 'data'
        self.watcher.stderr.destroy();
        self.watcher.removeAllListeners('exit'); // so don't fail on kill
        log.debug('killing watcher');
        self.watcher.kill();
        self.watcher = null;
    }

    if (self.debug_ival) {
        clearInterval(self.debug_ival);
        self.debug_ival = null;
    }
};

module.exports = {
    FsWatcher: FsWatcher
};
