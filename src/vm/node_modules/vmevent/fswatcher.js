/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 * This module exists to watch files for changes. It is somewhat similar to
 * node's fs.watch except:
 *
 *  * FsWatcher.watch() is asynchronous and optionally can call a callback when
 *    it actually starts watching.
 *  * FsWatcher emits an error event when a file cannot be watched
 *  * FsWatcher works with files that do not exist yet, notifying you when they
 *    are created.
 *
 * To use you should do something like:
 *
 *  fsw = new FsWatcher({log: log});
 *  fsw.watch('/path/to/some/file', [callback]);
 *  fsw.unwatch('/path/to/some/file', [callback]);
 *  fsw.shutdown();
 *  fsw.on(<event type>, callback(event));
 *
 * Where the event types can be:
 *
 *  * all - for any event
 *  * create - emitted when a file is created
 *  * change - emitted when a file is modified
 *  * delete - emitted when a file is deleted
 *
 * and then
 *
 *  CREATED
 *  MODIFIED (contents)
 *  DELETED
 *
 *
 * How this works:
 *
 *   This module is a wrapper around the fswatcher tool. That tool is driven by
 *   commands on STDIN which start and stop watches on files. Output goes to
 *   STDOUT and is scraped by this module and turned into events.
 *
 *   When you FsWatcher.watch() a file first we attempt a WATCH for the file
 *   specified in the arguments. If the result is that the file does not exist,
 *   we'll try to watch the parent directory. If that doesn't exist, we'll keep
 *   going up the directory stack until we find something to watch.
 *
 *   A watch on a file that we've specifically asked to watch is here called a
 *   "primary" watch. We will keep a primary watch active until it is
 *   specifically unwatched. If we start watching parents because a primary does
 *   not exist, we call that a "secondary" watch. These secondary watches keep
 *   track of the "children" they're watching for and when an event happens on
 *   a directory we're watching as a secondary, we check to see whether the
 *   change resulted in previously non-existent primaries showing up. If so we
 *   emit a "create" event and remove the child from the secondary's list.
 *
 *   A watch can be both primary and secondary. When removing watches with
 *   unwatch we only remove primaries directly. Secondaries will be removed if
 *   the removed watch is a child and that secondary has no other children.
 *
 *   If the fswatcher child dies unexpectedly, it is restarted and all primary
 *   watches are rewatched with the timestamp of the last event we saw passed
 *   in as the 4th argument. This way fswatcher will immediately fire an event
 *   if the file was modified while the fswatcher was dying/starting.
 *
 *
 * TODO:
 *
 *   If we restart watcher and file does not exist but existed before watcher
 *   died, or if it exists now but did *not* exist before watcher died... We
 *   need to make sure we emit the create or delete event. We can detect this
 *   by checking for FAIL on first watch after restart. If there's a timestamp
 *   set, we send DELETE event right away because file must have been destroyed.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var path = require('path');
var spawn = cp.spawn;
var util = require('util');

var FSWATCHER_CMD = '/usr/vm/sbin/fswatcher';
if (process.env.FSWATCHER_CMD) {
    FSWATCHER_CMD = process.env.FSWATCHER_CMD;
}

function FsWatcher(options)
{
    var buffers = {stdout: '', stderr: ''};
    var log = options.log;
    var prev_chunk = '';
    var self = this;

    assert(log, 'no logger passed to FsWatcher()');

    self.debug_ival = null;
    self.dedup_ns = options.dedup_ns;
    self.index = 0;
    self.log = log;
    self.pending_actions = {};
    self.prev_event = {}; // kept for deduplication
    self.watches = {};
    self.shutting_down = false;

    startWatcher();

    function startWatcher() {
        log.debug({cmdline: FSWATCHER_CMD}, 'executing fswatcher');
        self.watcher = spawn(FSWATCHER_CMD, [], {stdio: 'pipe'});
        self.watcher_pid = self.watcher.pid;
        log.debug('fswatcher running with pid ' + self.watcher_pid);

        self.watcher.stdout.on('data', function (data) {
            lineChunk(data, 'stdout', function (chunk) {
                var obj;

                try {
                    obj = JSON.parse(chunk);
                } catch (e) {
                    log.error({
                        chunk: chunk,
                        prev_chunk: prev_chunk
                    }, 'BAD JSON');
                    throw e;
                }
                prev_chunk = chunk;
                dispatchObj(obj);
            });
        });

        self.watcher.stderr.on('data', function (data) {
            lineChunk(data, 'stderr', function (chunk) {
                log.trace({stderr: chunk});
            });
        });

        self.watcher.on('close', function (code, signal) {

            log.warn('fswatcher ' + self.watcher_pid + ' exited. code: ' + code
                + ' signal: ' + signal);
            self.watcher_pid = null;

            /*
             * If child closed unexpectedly (ie. it was not shutdown()): we'll
             * restart the child and re-add the watches here.
             */
            if (!self.shutting_down) {
                startWatcher();
                log.debug('trying to re-watch all watches');
                Object.keys(self.watches).forEach(function (w) {
                    log.trace('WATCH[' + w + ']: '
                        + JSON.stringify(self.watches[w]));
                    self.watches[w].secondary = false;
                    if (!self.watches[w].primary) {
                        // we only re-add primary watches, as secondary watches
                        // will get added as WATCH commands fail.
                        delete self.watches[w];
                    } else {
                        self.watches[w].running = false;
                        tryWatching(w, self.watches[w].last_event);
                    }
                });
            }
        });
    }

    // Disabled as this outputs too much data currently
    if (0 === 1) {
        self.debug_ival = setInterval(function () {
            log.trace({
                watches: self.watches,
                pending_actions: self.pending_actions
            }, 'current state');
        }, 5000);
    }

    /*
     * For a given JSON object that came from fswatcher this dispatches
     */
    function dispatchObj(obj) {
        switch (obj.type) {
            case 'event':
                handleEvent(obj);
                break;
            case 'response':
                handleResponse(obj);
                break;
            case 'error':
            default:
                log.warn('dispatching error!: ' + JSON.stringify(obj));
                break;
        }
    }

    /*
     * Check whether "obj" matches the previous event. If it's the same event
     * within dedup_ns nanoseconds, returns true. If it's a different event or
     * spaced further apart, returns false.
     */
    function isDuplicate(obj) {

        if (!self.dedup_ns) {
            return (false);
        }

        /*
         * The timestamps here are generated when fswatcher is logging the
         * messages. We want to check that these are within some +/-  of a
         * previous message to be a duplicate instead of an exact match
         * to account for this inaccuracy. The worst case here however is that
         * we end up sending duplicate messages.
         */
        if ((self.prev_event.timestamp + self.dedup_ns < obj.timestamp)
            || (self.prev_event.timestamp - self.dedup_ns > obj.timestamp)) {

            return (false);
        }

        if (obj.pathname !== self.prev_event.pathname) {
            return (false);
        }

        if (obj.is_final !== self.prev_event.is_final) {
            return (false);
        }

        if (JSON.stringify(obj.changes.sort())
            !== JSON.stringify(self.prev_event.changes.sort())) {

            return (false);
        }

        return (true);
    }

    // XXX tryWatching vs queueAction, why?

    function tryWatching(pathname, start_timestamp) {
        var wobj;

        /*
         * A primary watch gets created and destroyed only when .watch() or
         * .unwatch() is called by the caller. We only try watching here when
         * we're dealing with a file that is intentionally being watched.
         */
        if (self.watches[pathname] && self.watches[pathname].primary) {
            wobj = {pathname: pathname, action: 'WATCH'};
            if (start_timestamp) {
                wobj.start_timestamp = start_timestamp;
            }
            self.watch_queue.push(wobj);
        } else {
            log.debug('Ignoring tryWatching(' + pathname + '): not primary');
        }
    }

    /*
     * Add an action to the queue for a path and attach callback if passed.
     */
    self.queueAction = function (pathname, action, opts, callback) {
        var wobj;

        wobj = {pathname: pathname, action: action};
        if (opts && opts.timestamp && opts.timestamp > 0) {
            assert(action === 'WATCH'); // timestamp makes no sense elsewhere
            wobj.timestamp = opts.timestamp;
        }
        if (callback) {
            wobj.callback = callback;
        }
        self.watch_queue.push(wobj);
    };

    function filterObject(obj) {
        log.trace({obj: obj}, 'filtering object');
        return (obj);
    }

    /*
     * pathname must be the name of a secondary watch. In which case
     * this function will:
     *
     *  - remove the secondary watch
     *  - attempt to watch each child of this secondary watch
     *
     * which could ultimately result in the secondary getting recreated
     * if any of the children do not exist.
     *
     */
    function retryAllChildren(pathname) {
        var children = [];

        children = self.watches[pathname].children;
        self.watches[pathname].children = [];
        self.watches[pathname].secondary = false;

        /*
         * We're basically treating secondary watches as one-shot watches.
         * So if we get an event that's *not* final, and we don't also have
         * a primary watch, we'll UNWATCH it. Below we're going to try
         * adding new watches for all the children which will recreate this
         * watch if necessary.
         */
        if (!self.watches[pathname].primary) {
            if (self.watches[pathname].running) {
                self.queueAction(pathname, 'UNWATCH');
            }
            delete self.watches[pathname];
        }

        /* Queue a new WATCH for each child we had on this secondary */
        Object.keys(children).forEach(function (child) {
            if (self.watches[child] && self.watches[child].primary) {
                delete self.watches[child].parent_watch;
                tryWatching(child);
            }
        });
    }

    function handleEvent(obj) {
        var fobj;
        var pathname = obj.pathname;
        var parent_dir;

        /* Try to avoid sending 2 identical messages when possible. */
        if (self.prev_event && isDuplicate(obj)) {
            log.trace({evt: obj}, 'ignoring duplicate event');
            return;
        }
        self.prev_event = obj;

        if (!self.watches.hasOwnProperty(pathname)) {
            log.warn({evt: obj}, 'ignoring event for unwatched file');
            return;
        }

        self.watches[pathname].last_event = obj.timestamp;

        /* remove/rename fields to match what we expose */
        fobj = filterObject(obj);

        // Send everything to the "all" channel
        self.emit('all', fobj);

        if (fobj.changes.indexOf('FILE_MODIFIED') !== -1) {
            self.emit('change', fobj);
        }
        if (fobj.changes.indexOf('FILE_DELETE') !== -1) {
            self.emit('delete', fobj);
        }

        /*
         * Whenever we get a "final" event, we're not going to get any more
         * events for this path until we start watching again.
         */
        if (self.watches[pathname] && fobj.is_final) {
            self.watches[pathname].running = false;
        }

        /*
         * If we got an event for a secondary watch, retry watching all the
         * children we're parent for.
         */
        if (self.watches[pathname] && self.watches[pathname].secondary) {
            retryAllChildren(pathname);
        }

        if (self.watches[pathname] && self.watches[pathname].primary) {
            if (fobj.is_final) {
                /*
                 * is_final means that the fswatcher is not going to rearm,
                 * possibly because the file was deleted. We attempt to re-add
                 * the watch here in this case which will cause a result and if
                 * we can't watch this file itself, we'll end up creating the
                 * appropriate secondary watch.
                 */
                if (self.watches[pathname].parent_watch) {
                    parent_dir = self.watches[pathname].parent_watch;
                    if (self.watches[parent_dir]
                        && self.watches[parent_dir].children) {

                        delete self.watches[parent_dir].children[pathname];
                    }
                    delete self.watches[pathname].parent_watch;
                }
                tryWatching(fobj.pathname);
            }
        }
    }

    self.divorceParent = function (pathname) {
        var children;
        var parent_dir;

        parent_dir = self.watches[pathname].parent_watch;
        delete self.watches[pathname].parent_watch;
        if (self.watches[parent_dir]) {
            delete self.watches[parent_dir].children[pathname];
            children = self.watches[parent_dir].children;
            if (Object.keys(children).length === 0) {
                self.watches[parent_dir].secondary = false;
            }
            if (self.watches[parent_dir].secondary === false
                && self.watches[parent_dir].primary === false) {

                if (self.watches[parent_dir].running) {
                    self.queueAction(parent_dir, 'UNWATCH', {}, function () {
                        if (self.watches[parent_dir].running) {
                            log.warn('watch for ' + parent_dir
                                + ' still running after unwatch');
                        } else {
                            delete self.watches[parent_dir];
                        }
                    });
                } else {
                    delete self.watches[parent_dir];
                }
            }
        }
    };

    function handleResponse(obj) {
        var action;
        var callback;
        var children = {};
        var err;
        var fobj;
        var parent_dir;

        if (!self.pending_actions[obj.key]) {
            log.warn({
                obj: obj,
                watch: self.watches[obj.pathname]
            }, 'no pending action for ' + obj.pathname + ' ignoring response');

            return;
        }

        log.trace({
            obj: obj,
            watch: self.watches[obj.pathname],
            pending_action: self.pending_actions[obj.key]
        }, 'handling response');

        parent_dir = path.dirname(obj.pathname);

        action = self.pending_actions[obj.key].action;
        callback = self.pending_actions[obj.key].callback;
        delete self.pending_actions[obj.key];

        if (obj.result == 'FAIL') {

            if (action === 'UNWATCH') {
                err = new Error('failed to unwatch ' + obj.pathname);
                if (!obj.message || !obj.message.match(/not watching/)) {
                    log.error({obj: obj}, err.message);
                }
                // XXX should we remove the watch here anyway?
                if (callback) {
                    callback(err);
                }
                return;
            }

            assert(action === 'WATCH');

            // XXX TODO should only do this after checking code?

            assert(obj.pathname !== parent_dir);


            // XXX what about both primary *and* secondary?
            if (self.watches[obj.pathname]
                && self.watches[obj.pathname].primary) {

                /*
                 * Attempt to watch primary failed, add secondary watch with
                 * this as child.
                 */
                if (!self.watches[parent_dir]) {
                    self.watches[parent_dir] = {
                        children: {},
                        primary: false,
                        running: false,
                        secondary: true
                    };
                }

                /* Link parent to child and vice versa. */
                self.watches[parent_dir].secondary = true;
                self.watches[parent_dir].children[obj.pathname] = true;
                self.watches[obj.pathname].parent_watch = parent_dir;

                // XXX there's a race here if someone just did unwatch but it
                // hasn't succeeded yet, just try the WATCH always?
                if (!self.watches[parent_dir].running) {
                    self.queueAction(parent_dir, 'WATCH');
                }

                /*
                 * The initial WATCH failed, but we've now queued a watch for
                 * the parent, so we'll call callback now since watch is
                 * effectively running.
                 */

                if (callback) {
                    callback();
                }
            } else if (self.watches[obj.pathname]
                && self.watches[obj.pathname].secondary) {

                if (!self.watches[parent_dir]) {
                    self.watches[parent_dir] = {
                        children: {},
                        primary: false,
                        running: false,
                        secondary: true
                    };
                }

                children = self.watches[obj.pathname].children;
                self.watches[obj.pathname].children = {};
                self.watches[obj.pathname].secondary = false;
                if (!self.watches[obj.pathname].primary) {
                    delete self.watches[obj.pathname];
                }

                /* Link parent to child and vice versa. */
                self.watches[parent_dir].secondary = true;
                Object.keys(children).forEach(function (child) {
                    self.watches[parent_dir].children[child] = true;
                    self.watches[child].parent_watch = parent_dir;
                });

                // XXX there's a race here if someone just did unwatch but it
                // hasn't succeeded yet, just try the WATCH always?
                if (!self.watches[parent_dir].running) {
                    self.queueAction(parent_dir, 'WATCH');
                }

                // XXX do we ever have callback on a secondary?
                if (callback) {
                    callback();
                }
            } else {
                // XXX received FAIL for something we're not watching? Seems
                // bad.
                log.warn({
                    pathname: obj.pathname,
                    watch: self.watches[obj.pathname]
                }, 'got FAIL result but not primary or secondary');
            }
        } else if (obj.result === 'SUCCESS') {

            if (action === 'UNWATCH') {
                log.info({obj: obj}, 'succeded to unwatch ' + obj.pathname);
                if (self.watches[obj.pathname]) {
                    self.watches[obj.pathname].running = false;
                    children = self.watches[obj.pathname].children;
                    assert(Object.keys(children).length === 0);
                }

                /* Need to call callback() *after* we've set running = false */
                if (callback) {
                    callback();
                }

                return;
            }

            /*
             * On success we'll always call callback here since we're not going
             * to send it an error object.
             */
            if (callback) {
                callback();
            }

            assert(action === 'WATCH');

            /* This flag indicates fswatcher is watching currently */
            if (self.watches[obj.pathname]) {
                self.watches[obj.pathname].running = true;
            }

            if (self.watches[obj.pathname]
                && self.watches[obj.pathname].primary) {

                /*
                 * If we're a primary we'll check for parents, if we have one
                 * we'll divorce ourselves from them now, since we're on our
                 * own.
                 */
                if (self.watches[obj.pathname].parent_watch) {
                    self.divorceParent(obj.pathname);
                }

                if (!self.watches[obj.pathname].initial) {
                    /*
                     * We're a primary and this is not an initial watch, emit
                     * create, since file was just created.
                     */
                    fobj = filterObject(obj);
                    self.emit('create', fobj);
                }
            } else if (self.watches[obj.pathname]
                && self.watches[obj.pathname].secondary
                && obj.message !== 'already watching') {

                /*
                 * When a secondary-only watch succeeds, there's nothing special
                 * to do until it gets an event.
                 *
                 * TODO: the above comment contradicts the following code.
                 */
                fs.readdir(obj.pathname, function (e, files) {
                    // XXX
                    log.trace({files: files, pathname: obj.pathname},
                        'looking at secondary files');

                    if (!self.watches[obj.pathname]
                        || !self.watches[obj.pathname].children) {

                        log.warn('secondary watch ' + obj.pathname
                            + ' has no children');
                        return;
                    }
                    children = self.watches[obj.pathname].children;

                    Object.keys(children).forEach(function (child) {
                        files.forEach(function (file) {
                            file = path.join(obj.pathname, file);

                            log.debug('checking ' + file + ' vs. ' + child);
                            if (child.length < file) {
                                /* too short to be a match */
                                return;
                            }
                            if (!self.watches[obj.pathname]) {
                                /* if watch was deleted, we're done here */
                                log.debug(obj.pathname + ' was deleted?!');
                                return;
                            }

                            if ((child.substr(0, file.length) === file)
                                && ((child.length === file.length)
                                || (child[file.length] === '/'))) {

                                log.debug(child + ' might be under ' + file
                                    + ' deleting and reparenting');

                                self.divorceParent(child);
                                tryWatching(child);
                            } else {
                                log.debug(child + ' definitely not under '
                                    + file);
                            }
                        });
                    });
                });
            } else {
                assert('OMGWTFBBQ');
            }
        }

        /* no longer initial since we've seen a response */
        if (self.watches[obj.pathname]) {
            self.watches[obj.pathname].initial = false;
        }
    }

    function nextIndex() {

        if (self.index < 4294967295) {
            self.index++;
        } else {
            self.index = 1;
        }

        return (self.index);
    }

// XXX watch_Queue is a bad name if we also unwatch
    self.watch_queue = async.queue(function (obj, callback) {
        var action = obj.action;
        var line = '';
        var pathname = obj.pathname;
        var start_timestamp = obj.start_timestamp;
        var idx;

        if (!self.watcher_pid) {
            /*
             * If watcher's not running, it should be restarting, so we add a
             * small delay and requeue. Since the next object won't be processed
             * from the queue until this one calls callback anyway, this means
             * we only delay small amounts for each object until the watcher is
             * running again at which point we'll no longer get to this delay.
             */
            setTimeout(function _requeueAfterDelay() {
                log.debug('retrying for ' + JSON.stringify(obj));
                self.watch_queue.push(obj);
                callback();
            }, 50);
            return;
        }

        idx = nextIndex();
        if (action === 'UNWATCH') {
            line = idx + ' UNWATCH ' + pathname;
            log.trace(line);
            try {
                if (self.watcher) {
                    self.watcher.stdin.write(line + '\n');
                }
                // else { XXX: We cleaned up? }
            } catch (e) {
                log.error({unwatch_err: e}, 'failed to write UNWATCH: '
                    + e.message);
            }
        } else {
            assert(action === 'WATCH');
            line = idx + ' WATCH ' + pathname;
            if (start_timestamp) {
                line = line + ' ' + start_timestamp;
            }
            log.trace(line);
            try {
                self.watcher.stdin.write(line + '\n');
            } catch (e) {
                log.error({watch_err: e}, 'failed to write WATCH: '
                    + e.message);
            }
        }

        /*
         * Every "action" should result in a response. We track actions we've
         * requested so that we can match them up when we get responses.
         */
        self.pending_actions[idx] = {action: action, pathname: pathname};
        if (obj.callback) {
            self.pending_actions[idx].callback = obj.callback;
        }

        callback();
    }, 1);

    self.watch_queue.drain = function () {
        // log.trace('watch_queue is empty');
    };

    function lineChunk(data, buffer, handler) {
        var chunk;
        var chunks;

        buffers[buffer] += data.toString();
        chunks = buffers[buffer].split('\n');

        while (chunks.length > 1) {
            chunk = chunks.shift();
            handler(chunk);
        }
        buffers[buffer] = chunks.pop(); // remainder
    }

}

util.inherits(FsWatcher, EventEmitter);

FsWatcher.prototype.watch = function (pathname, callback)
{
    var err = undefined;
    var self = this;

    var log = self.log;

    // XXX pathname must be absolute path

    if (self.watches[pathname]) {
        // This becomes a primary watch now whether it was or not before
        self.watches.primary = true;

        err = new Error('Already watching ' + pathname);
        // XXX use a code so caller can know this is not really an error
        log.warn(err);

        if (!self.watches[pathname].running) {
            self.queueAction(pathname, 'WATCH', {}, callback);
        } else {
            /*
             * We're not starting a watch (because it's already running)
             * so call callback now if set
             */
            if (callback) {
                callback();
            }
        }
    } else {
        self.watches[pathname] = {
            initial: true,
            primary: true,
            running: false,
            secondary: false
        };
        self.queueAction(pathname, 'WATCH', {}, callback);
        return; // callback will be called when we actually start watching.
    }
};

FsWatcher.prototype.unwatch = function (pathname, callback)
{
    var err = undefined;
    var log;
    var self = this;

    log = self.log;

    // XXX must be absolute path

    if (!self.watches.hasOwnProperty(pathname)) {
        // XXX use a code so caller can know this is not really an error
        err = new Error('Not watching ' + pathname);
        log.warn(err);
    } else if (!self.watches[pathname].primary) {
        // XXX use a code so caller can know this is not really an error
        err = new Error('No primary watch for ' + pathname);
        log.warn(err);
    }

    if (!err) {
        if (!self.watches[pathname].secondary) {
            /*
             * If we're not secondary, we only had primary watch so we can
             * totally remove the watch.
             */
            self.queueAction(pathname, 'UNWATCH', {}, callback);
            if (self.watches[pathname].parent_watch) {
                self.divorceParent(pathname);
            }
            delete self.watches[pathname];
        } else {
            /*
             * If we are secondary, we just remove the primary flag because
             * someone is depending on this watch as a parent.
             */
            self.watches[pathname].primary = false;
            /* we're not going to UNWATCH, so call callback now */
            if (callback) {
                callback(err);
            }
        }
    } else {
        if (callback) {
            callback(err);
        }
    }

    // XXX also remove parents who are only watching because of this
};

/*
 * Return ths list of watched files.
 */
FsWatcher.prototype.watches = function ()
{
    var self = this;

    // XXX should only return primaries?
    return Object.keys(self.watches);
};

FsWatcher.prototype.watcherPID = function ()
{
    var self = this;

    return (self.watcher_pid);
};

FsWatcher.prototype.shutdown = function ()
{
    var listeners = [];
    var self = this;
    var log = self.log;

    self.shutting_down = true;

    ['all', 'change', 'create', 'delete'].forEach(function (type) {
        listeners = self.listeners(type);
        log.debug('cleanup called w/ listeners(' + type + '): '
            + util.inspect(listeners));
        self.removeAllListeners(type);
    });

    log.debug('zoneevent watcher ' + self.watcher_pid + ' cleanup called');
    if (self.watcher) {
        self.watcher.stdout.destroy(); // so we don't send more 'data'
        self.watcher.stderr.destroy();
        self.watcher.removeAllListeners('exit'); // so don't fail on kill
        self.watcher.removeAllListeners('close'); // so don't fail on kill
        log.debug('killing watcher ' + self.watcher_pid);
        self.watcher.kill();
        self.watcher = null;
    }

    if (self.debug_ival) {
        clearInterval(self.debug_ival);
        self.debug_ival = null;
    }
};

module.exports = {
    FsWatcher: FsWatcher
};
