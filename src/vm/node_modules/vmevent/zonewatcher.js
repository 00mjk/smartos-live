/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var bunyan = require('/usr/node/node_modules/bunyan');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var path = require('path');
var spawn = cp.spawn;
var util = require('util');

var ZONEEVENT_CMD = '/usr/vm/sbin/zoneevent';
if (process.env.ZONEEVENT_CMD) {
    ZONEEVENT_CMD = process.env.ZONEEVENT_CMD;
}

function ZoneWatcher(options) {
    var self = this;
    var buffers = {stdout: '', stderr: ''};
    var log = options.log;

    self.options = options;
    self.prev_msg = {};
    self.ready = false;
    self.watcher = null; // the handle to the child process
    self.watcher_pid = null;
    self.shutting_down = false;

    assert(options.log, 'no logger passed to ZoneWatcher()');
    self.log = options.log;

    self.startWatcher = function () {
        var eobj;

        log.debug({cmdline: ZONEEVENT_CMD}, 'executing zoneevent');
        self.watcher = spawn(ZONEEVENT_CMD, [], {stdio: 'pipe'});
        self.watcher_pid = self.watcher.pid;

        self.watcher.stdout.on('data', function (data) {
            lineChunk(data, 'stdout', function (chunk) {
                handleChunk(chunk);
            });
        });

        self.watcher.stderr.on('data', function (data) {
            lineChunk(data, 'stderr', function (chunk) {
                log.trace({stderr: chunk});
            });
        });

        // doesn't take input.
        self.watcher.stdin.end();

        self.watcher.on('close', function (code, signal) {

            log.warn('zoneevent ' + self.watcher_pid + ' exited. code: ' + code
                + ' signal: ' + signal);
            self.watcher_pid = null;

            /*
             * If child closed unexpectedly (ie. it was not shutdown()): we'll
             * restart.
             */
            if (!self.shutting_down) {
                self.startWatcher();
            }
        });

        log.debug('emitting ready');
        eobj = {type: 'ready', message: 'zoneevent is running'};
        self.emit('ready', eobj);
        self.emit('all', eobj);
        self.ready = true;
    };

    function handleChunk(line) {
        var eobj;
        var prev;
        var obj;

        try {
            obj = JSON.parse(line);
        } catch (e) {
            log.debug({err: e}, 'failed to parse line');
            process.abort();
        }

        if (self.prev_msg[obj.zonename]) {
            prev = self.prev_msg[obj.zonename].obj;

            if (prev === obj) {
                console.error('duplicate! ' + JSON.stringify(obj));
                return;
            }
        }

        eobj = {
            type: 'change',
            zonename: obj.zonename,
            newstate: obj.newstate,
            timestamp_ns: obj.when
        };

        self.emit('change', eobj);
        self.emit('all', eobj);

        self.prev_msg[obj.zonename] = {
            obj: obj,
            timestamp: (obj.when / 1000000000) // or  (new Date).getTime()
        };
    }

    function lineChunk(data, buffer, handler) {
        var chunk;
        var chunks;

        buffers[buffer] += data.toString();
        chunks = buffers[buffer].split('\n');

        while (chunks.length > 1) {
            chunk = chunks.shift();
            handler(chunk);
        }
        buffers[buffer] = chunks.pop(); // remainder
    }
}

util.inherits(ZoneWatcher, EventEmitter);

ZoneWatcher.prototype.isReady = function ()
{
    var self = this;
    return (!!self.ready);
};

ZoneWatcher.prototype.start = function ()
{
    var self = this;

    return (self.startWatcher());
};

// TODO: shutdown (and start again?)
ZoneWatcher.prototype.shutdown = function ()
{
    var listeners = [];
    var self = this;
    var log = self.log;

    self.shutting_down = true;
    self.ready = false;

    [
        'all',
        'change'
    ].forEach(function (type) {
        listeners = self.listeners(type);
        log.debug('cleanup called w/ listeners(' + type + '): '
            + util.inspect(listeners));
        self.removeAllListeners(type);
    });

    log.debug('zpool watcher ' + self.watcher_pid + ' cleanup called');
    if (self.watcher) {
        self.watcher.stdout.destroy(); // so we don't send more 'data'
        self.watcher.stderr.destroy();
        self.watcher.removeAllListeners('exit'); // so don't fail on kill
        self.watcher.removeAllListeners('close'); // so don't fail on kill
        log.debug('killing watcher ' + self.watcher_pid);
        self.watcher.kill();
        self.watcher = null;
    }
};

module.exports = {
    ZoneWatcher: ZoneWatcher
};
