/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var bunyan = require('/usr/node/node_modules/bunyan');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var FsWatcher = require('vmevent/fswatcher').FsWatcher;
var fs = require('fs');
var vmload = require('/usr/vm/node_modules/vmload');
var path = require('path');
var spawn = cp.spawn;
var http = require('http');
var qs = require('querystring');
var url = require('url');
var ZoneWatcher = require('vmevent/zonewatcher').ZoneWatcher;
var ZpoolWatcher = require('vmevent/zpoolwatcher').ZpoolWatcher;

var log = bunyan.createLogger({
    level: 'trace',
    name: 'vminfod',
    streams: [ { stream: process.stderr, level: 'trace' } ],
    serializers: bunyan.stdSerializers
});

var ready;
var event_queue;
var fsw;
var vm_data;
var vmobjs;
var zoneevent;
var zpoolevent;

var LISTEN_SOCKET = '/var/run/vminfod.sock';
var REFRESH_INTERVAL = 30000; // 30 seconds
var CONFIG_FILES = [
    'metadata.json',
    'routes.json',
    'tags.json'
];

function handleFsEvent(obj)
{
    console.log('FS: ' + JSON.stringify(obj));
}

function handleZoneEvent(obj)
{
    console.log('ZONE: ' + JSON.stringify(obj));
}

function handleZpoolEvent(obj)
{
    console.log('ZPOOL: ' + JSON.stringify(obj));
}

function initQueue(callback)
{
    event_queue = async.queue(function (task, cb) {
        // figure out what to do here...
        cb();
    }, 1);
    callback();
}

function startWatchers(callback)
{
    async.series([
        function (cb) {
            fsw = new FsWatcher({log: log, dedup_ns: 2000000000});

            fsw.on('all', handleFsEvent);
            fsw.once('ready', function (obj) {
                cb();
            });

            fsw.start();
        }, function (cb) {
            fsw.watch('/etc/zones', cb);
        }, function (cb) {
            fsw.watch('/tmp/.sysinfo.json', cb);
        }, function (cb) {
            zonew = new ZoneWatcher({log: log});

            zonew.on('all', handleZoneEvent);
            zonew.once('ready', function (obj) {
                cb();
            });

            zonew.start();
        }, function (cb) {
            zpoolw = new ZpoolWatcher({log: log});

            zpoolw.on('all', handleZpoolEvent);
            zpoolw.once('ready', function (obj) {
                cb();
            });

            zpoolw.start();
        }
    ], function (err) {
        callback(err);
    });
}

function startVmWatchers(callback)
{
    var vms = Object.keys(vmobjs);

    vms.forEach(function (uuid) {
        addVMFsWatches(vmobjs[uuid].zonename);
    });

    callback();
}

function stopVmWatchers(callback)
{
    // todo: remove watches
    callback();
}

function loadVmData(callback)
{
    vmload.getZoneData(null, {log: log}, function (err, cache) {
        vm_data = cache;
        console.log('initial vm_data: ' + JSON.stringify(vm_data, null, 2));
        callback();
    });
}

function setVmobjs(callback)
{
    vmload.getVmobjs({cache: vm_data, log: log}, function (err, results) {
        vmobjs = {};

        results.forEach(function (vmobj) {
            vmobjs[vmobj.uuid] = vmobj;
        });

        console.log('initial vmobjs: ' + JSON.stringify(vmobjs, null, 2));
        callback();
    });
}

function addVMFsWatches(zonename)
{
    // todo: need to evaluate the trigger system in proptable to determine the event system.

    // function watch(pathname) {
    //     fsw.watch(pathname, function (err) {
    //         if (err) {
    //             log.warn(err, 'failed to setup watch');
    //             return;
    //         }
    //         log.debug('now watching ' + pathname);
    //     });
    // }

    // watch('/etc/zones/' + zonename + '.xml');

    // CONFIG_FILES.forEach(function (f) {
    //     watch('/zones/' + zonename + '/config/' + f);
    // });
}

function handleGet(c, args, response)
{
    log.debug('GET (' + JSON.stringify(c) + ') len: ' + c.length);

    switch (c[0]) {
    case 'data':
    case 'cache':
        // return the cache object
        response.writeHead(200, { 'Content-Type': 'application/json'});
        response.end(JSON.stringify(vm_data, null, 2), 'utf-8');
        break;
    case 'vms':
        if (c.length === 2) {
            // requesting a vmobj with uuid
            var uuid = c[1];
            var vm = vmobjs[uuid];

            if (vm === undefined) {
                response.writeHead(404, { 'Content-Type': 'application/json'});
                response.write('Unable to load VM ' + uuid);
                response.end();
            } else {
                response.writeHead(200, { 'Content-Type': 'application/json'});
                response.end(JSON.stringify(vm, null, 2), 'utf-8');
            }
        } else {
            // requesting the vmobj list
            var vms = [];

            Object.keys(vmobjs).forEach(function (uuid) {
                vms.push(vmobjs[uuid]);
            });

            response.writeHead(200, { 'Content-Type': 'application/json'});
            response.end(JSON.stringify(vms, null, 2), 'utf-8');
        }
        break;
    default:
        response.writeHead(404, { 'Content-Type': 'application/json'});
        response.write('Unsupported URL Path');
        response.end();
        break;
    }
}

function startHTTPHandler(callback)
{
    var handler = function (request, response) {
        var args;
        var c;
        var url_parts;

        url_parts = url.parse(request.url, true);
        c = url_parts.pathname.split('/');

        // remove empty /'s from front/back
        while (c.length > 0 && c[0].length === 0) {
            c.shift();
        }
        while (c.length > 0 && c[c.length - 1].length === 0) {
            c.pop();
        }

        // we might need args for filtering vmobjs... maybe
        if (url_parts.hasOwnProperty('query')) {
            args = url_parts.query;
            log.debug('url ' + request.url);
            log.debug('args ' + JSON.stringify(args));
        } else {
            args = {};
        }

        if (request.method !== 'GET') {
            // Bad request
            response.writeHead(400, {'Content-Type': 'application/json'});
            response.end();
        } else {
            if (ready !== true) {
                response.writeHead(503, {'Content-Type': 'application/json'});
                response.write('Temporarily Unavailable');
                response.end();
            } else {
                handleGet(c, args, response);
            }
        }
    };

    log.debug('LISTENING ON ' + LISTEN_SOCKET);
    // http.createServer(handler).listen(LISTEN_SOCKET, cb);
    // temporarily for testing with curl
    http.createServer(handler).listen(9090, '127.0.0.1', callback);
}

function startTimers(cb)
{
    setInterval(function () {
        reset(function (err) {
            log.debug('reset');
        });
    }, REFRESH_INTERVAL);
}

function start(cb)
{
    ready = true;
    event_queue.resume();
    cb();
}

function stop(cb)
{
    ready = false;
    event_queue.pause();
    cb();
}

function teardown(callback)
{
    async.series([
        stop,
        stopVmWatchers
    ], callback);
}

function setup(callback)
{
    async.series([
        loadVmData,
        setVmobjs,
        startVmWatchers,
        start
    ], callback);
}

function reset(callback)
{
    async.series([
        teardown,
        setup
    ], callback);
}

function main() 
{
    async.series([
        initQueue,
        startWatchers,
        setup,
        startHTTPHandler
        // startTimers
    ], function (err) {
        console.error('XXX DONE');
    });
}

main();


/*
 * TODO:
 *
 * bubble/handle errors from initialization sequence
 * events to a queue?
 * watch for dladm changes for vnics
 * watch for rctl changes
 *
 */

