/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

/*
 * The primary function of this module is to mantain an up-to-date copy of:
 *
 *   1) the complete vmobj list
 *   2) a vmload cache object.
 * 
 * Both objects are consumable from the webservice: 
 *
 *   - The complete vm list can be consumed at /vms
 *   - A single vm can be consumed at /vms/UUID
 *   - The cache can be consumed at /data or /cache
 *
 * Overview:
 *
 *   The tl;dr overview is that this module will listen for events within 3
 *   broad categories: zone state, zone config files, and zfs datasets. 
 *   When an event is fired, we will delete portions of the cache object that 
 *   are relevant to the event, then ask vmload to fill in the holes with
 *   getZoneData, which we can then update the vmobjs that were affected 
 *   by the change, and lastly inform any subscribed consumers of the specific
 *   changes to the vmobj data.
 *
 * This module is not necessarily concerned with the details of a vmobj.
 * Meaning, the structure of the vmobj, where the data is derived, and how
 * the data is transformed are not the concern of this module. This module
 * will delegate that responsibility to the vmload modules. This module is 
 * concerned with knowing when pieces of the cache object are likely 
 * out-of-date, how to re-populate those pieces, and which vmobjs will be
 * affected by the change. 
 *
 * The vmload module generates the final vmobj data from the following areas:
 *   - (1) the zone_t struct extracted from mdb
 *   - (1) the zoneadm utility
 *   - (2) the /etc/zones/UUID.xml file
 *   - (2) json files located in /zones/config/metadata*.json
 *   - (3) datasets from zfs list
 *
 * The data derived from category 1 (above) will need to be invalidated and
 * re-generated upon the reception of a zone event. Within the cache object,
 * we will delete ["last_modified"][<uuid>], ["pids"][<uuid>], and 
 * ["zoneadm_objects"][<uuid>]. Finally, we will call vmload.getVmobj(<uuid>)
 * to re-populate this data, and replace the vmobj with the corresponding uuid.
 *
 * The data derived from category 2 (above) will need to be invalidated and
 * re-generated upon the reception of a filesystem event watching the specific
 * file in question. If the file is /etc/zones/uuid.xml, we will delete 
 * ["zonexml_objects"][<uuid>]. If the file is /zones/config/metadataTYPE.json,
 * we will delete the corresponding key within ["json_objects"]["uuid"][...].
 * Finally, we will call vmload.getVmobj(<uuid>) to re-populate this data, and
 * replace the vmobj with the corresponding uuid.
 *
 * The data derived from category 3 (above) requires more work. At first, we
 * will start by listening for a zfs event. The event will notify us that a
 * dataset was created, renamed, or deleted. To minimize the zfs list, we will
 * remove all relevant pieces from within the "dataset_objects" structure, then
 * we will ask vmload-datasets directly to re-create the "dataset_objects" by
 * informing the vmload-datasets getDatasets function to only generate the 
 * objects for the specific dataset that was modified. Some of these steps are 
 * conditional to the dataset action. For instance, a create will not require 
 * us to remove properties, and likewise, a delete will not require us to 
 * rebuild the datasets structure after the pieces are removed. Finally, we 
 * will derive the uuid from the dataset name, and will call 
 * vmload.getVmobj(<uuid>) to re-populate this data, and replace the vmobj with 
 * the corresponding uuid.
 *
 * At a routine interval, we will also force-refresh the cache and regenerate 
 * the vmobj sets to ensure data integrity. When the refresh interval is fired, 
 * we will first pause the event queue, then request a new cache object. Once
 * we have received a new cache object, we can replace the current cache object
 * with the new if the two cache objects are different. Only if the two objects
 * are different, we will iterate through all vmobjs and generate a new vmobj 
 * from the new cache and report any deltas along the way. Finally, after all 
 * vmobjs have been updated, we will resume the queue. It is possible that 
 * resuming the events in the paused queue will cause some events to replay 
 * that will have no effect in the final datasets.
 * 
 * A new vmobj is created when a zone event is received for a uuid that we're
 * not currently watching, which will then register observers for relevant 
 * config files.
 *
 * A vmobj is removed when the watched /etc/zones/<uuid>.xml receives the 
 * DELETE event. At this point, we will also remove all watchers that were 
 * setup for that vmobj.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var bunyan = require('/usr/node/node_modules/bunyan');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var FsWatcher = require('vmevent/fswatcher').FsWatcher;
var fs = require('fs');
var vmload = require('/usr/vm/node_modules/vmload');
var path = require('path');
var spawn = cp.spawn;
var http = require('http');
var qs = require('querystring');
var url = require('url');
var ZoneWatcher = require('vmevent/zonewatcher').ZoneWatcher;
var ZpoolWatcher = require('vmevent/zpoolwatcher').ZpoolWatcher;

var log = bunyan.createLogger({
    level: 'trace',
    name: 'vminfod',
    streams: [ { stream: process.stderr, level: 'trace' } ],
    serializers: bunyan.stdSerializers
});

var event_queue;
var locks;
var fsw;
var vm_data;
var vmobjs;
var zoneevent;
var zpoolevent;

var LISTEN_SOCKET = '/var/run/vminfod.sock';
var REFRESH_INTERVAL = 30000; // 30 seconds
var CONFIG_FILES = [
    'metadata.json',
    'routes.json',
    'tags.json'
];

function handleFsEvent(obj)
{
    console.log('FS: ' + JSON.stringify(obj));
}

/*
 * handleZoneEvent() is a callback for a ZoneWatcher
 *
 * Process:
 *  
 *   First we extract the zonename property from the event, then check to see
 *   if there is a lock set. If the lock is set, it means another event is
 *   currently in process and there is no need to run it again. If the lock is
 *   not set, we aquire a lock and then see if we have any vmobjs registered 
 *   with that zonename. If not, then this must be a vm create, which we will:
 *     1) fetch the vmobj from vmload.getVmobj
 *     2) register observers
 *     3) inform subscribers of the new vmobj
 *   If this is a vm that we already know about, we will:
 *     1) invalidate the relevant pieces of the vm_data
 *     2) refresh the vmobj by calling refreshVmobj
 */
function handleZoneEvent(obj)
{
    console.log('ZONE: ' + JSON.stringify(obj));
 
    if (obj.type !== 'change') {
        return;
    }

    var zonename = obj.zonename;

    var lock = zonename + '-zone-event';
    if (locks.hasOwnProperty(lock) && locks[lock] === true ) {
        // someone else is already doing this
        return;
    }

    // aquire lock
    locks[lock] = true;

    var vmobj = vmobjs[zonename];

    if (vmobj === undefined) {
        // a new vm!
        // var opts = {log: log, cache: vm_data};
        // temporarily without the cache (until our zpool watcher is setup)
        var opts = {log: log};
        vmload.getVmobj(zonename, opts, function (err, vmobj) {
            if (err) {
                log.error('failed to load vmobj for ' + zonename);
                // unlock
                delete locks[lock];
            } else {
                vmobjs[zonename] = vmobj;
                startVmWatchers(zonename, function (err) {
                    // todo: notify subscribers
                    console.log('new vmobj: ' + JSON.stringify(vmobj));
                    // unlock
                    delete locks[lock];
                });
            }
        });
    } else {
        console.log('VM_DATA: ' + JSON.stringify(vm_data, null, 2));

        // remove pieces of the cache that might have been affected
        var contexts = [
            vm_data['zoneadm_objects'],
            vm_data['zoneinfo_objects'],
            vm_data['pids'],
            vm_data['last_exited'],
            vm_data['last_modified']
        ];

        contexts.forEach(function (context) {
            if (context !== undefined && context.hasOwnProperty(zonename)) {
                delete context[zonename];
            }
        });

        refreshVmobj(zonename, function (err) {
            // unlock
            delete locks[lock];
        });
    }
}

/*
 * refreshVmobj() refreshes the cached vmobj and reports any changes
 *
 * Process:
 *     1) refresh the vm_data cache by calling vmload.getZoneData
 *     2) request a new vmobj by calling vmload.getVmobj
 *     3) analyze vmobj delta
 *     4) if different:
 *       4a) replace the vmobj with the new vmobj
 *       4b) log the delta
 *       4c) inform any subscribers of the delta
 */
function refreshVmobj(uuid, callback)
{
    // todo: there are multiple event sources that drop into here. We may want
    // to serialize these requests behind a uuid. Without a serializer, we
    // shouldn't have any problems with data integrity. I'll have to see if
    // this is a performance problem before implementing a queue.

    async.waterfall([
        // refresh vm_data cache
        function (cb) {
            var opts = {log: log, cache: vm_data};
            vmload.getZoneData(uuid, opts, function (err, cache) {
                // we don't care about cache here because we provided a cache
                // object that was transformed by reference. So, cache in this
                // case is just a reference to vm_data, which we already store
                // globally.

                // todo: logging?
                cb();
            });
        }, 
        // request a new vmobj
        function (cb) {
            var opts = {log: log, cache: vm_data};
            vmload.getVmobj(uuid, opts, function (err, vmobj) {
                if (err) {
                    log.error('failed to getVmobj for ' + uuid + ': ' + err.message);
                    cb(err);
                } else {
                    // pass the new vmobj down the stream
                    cb(null, vmobj);
                }
            });
        },
        // analyze delta, update live copy
        function (vmobj, cb) {
            // todo: how do we actually want to catalog changes?
            // todo: Might be worth looking into 
            //   https://www.npmjs.com/package/deep-diff to detect changes

            // for time being, let's just override the existing
            var meta = {
                old: JSON.stringify(vmobjs[uuid]),
                new: JSON.stringify(vmobj)
            };
            log.debug(meta, 'replacing vmobj for ' + uuid);

            vmobjs[uuid] = vmobj;

            cb(null, []);
        },
        // publish changes
        function (changes, cb) {
            // todo: submit changes to a publish queue
            cb();
        }
    ], function (err) {
        if (err) {
            console.log('refreshVmobj error: ' + err.message);
        }

        console.log('refreshVmobj success');

        callback();
    });
}

function handleZpoolEvent(obj)
{
    console.log('ZPOOL: ' + JSON.stringify(obj));
}

function initQueue(callback)
{
    event_queue = async.queue(function (task, cb) {
        // figure out what to do here...
        cb();
    }, 1);
    callback();
}

/*
 * initLocks() initializes the locks datastructure
 *
 * Currently, this is a function with a callback assuming that over time
 * we might need to do more to initialize this, and we can do so without 
 * having to blowup the global initialization sequence.
 */
function initLocks(callback)
{
    locks = {};
    callback();
}

/*
 * startWatchers() starts global watchers
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will:
 *   1) Create a FsWatcher object
 *   2) Watch for changes to /tmp/.sysinfo.json
 *   3) Create a ZoneWatcher
 *   4) Create a ZpoolWatcher
 */
function startWatchers(callback)
{
    async.series([
        function (cb) {
            fsw = new FsWatcher({log: log, dedup_ns: 2000000000});

            fsw.on('all', handleFsEvent);
            fsw.once('ready', function (obj) {
                cb();
            });

            fsw.start();
        }, function (cb) {
            fsw.watch('/tmp/.sysinfo.json', cb);
        }, function (cb) {
            zonew = new ZoneWatcher({log: log});

            zonew.on('all', handleZoneEvent);
            zonew.once('ready', function (obj) {
                cb();
            });

            zonew.start();
        }, function (cb) {
            zpoolw = new ZpoolWatcher({log: log});

            zpoolw.on('all', handleZpoolEvent);
            zpoolw.once('ready', function (obj) {
                cb();
            });

            zpoolw.start();
        }
    ], function (err) {
        callback(err);
    });
}

/*
 * startVmWatchers() starts the watchers for a VM
 *
 * Arguments:
 *   'uuid' - a specific vm uuid to start watchers on
 *   'callback' - will be called with (err)
 *
 *   'uuid' argument is optional, and when omitted will start watchers
 *   for all vms.
 */
function startVmWatchers(uuid, callback)
{
    if (arguments.length === 1) {
        callback = uuid;
        uuid = undefined;
    }

    if (uuid === undefined) {
        var vms = Object.keys(vmobjs);

        vms.forEach(function (uuid) {
            addVMFsWatches(vmobjs[uuid].zonename);
        });
    } else {
        addVMFsWatches(vmobjs[uuid].zonename);
    }

    callback();
}

/*
 * stopVmWatchers() stops the watchers for a VM
 *
 * Arguments:
 *   'uuid' - a specific vm uuid to stop watchers on
 *   'callback' - will be called with (err)
 *
 *   'uuid' argument is optional, and when omitted will stop watchers
 *   for all vms.
 */
function stopVmWatchers(uuid, callback)
{
    if (arguments.length === 1) {
        callback = uuid;
        uuid = undefined;
    }

    if (uuid === undefined) {
        var vms = Object.keys(vmobjs);

        vms.forEach(function (uuid) {
            removeVMFsWatches(vmobjs[uuid].zonename);
        });
    } else {
        removeVMFsWatches(vmobjs[uuid].zonename);
    }

    callback();
}

/*
 * addVMFsWatches() creates filesystem watchers for a given vm
 *
 * Arguments:
 *   'zonename' - a zonename for a vm to use in the watcher path
 *
 * This function will:
 *   1) Create a watcher for /etc/zones/<zonename>.xml
 *   2) Create watchers for config files in /zones/<zonename>/config/*.json
 *
 */
function addVMFsWatches(zonename)
{
    function watch(pathname) {
        fsw.watch(pathname, function (err) {
            if (err) {
                log.warn(err, 'failed to setup watch');
                return;
            }
            log.debug('now watching ' + pathname);
        });
    }

    watch('/etc/zones/' + zonename + '.xml');

    CONFIG_FILES.forEach(function (f) {
        watch('/zones/' + zonename + '/config/' + f);
    });
}

/*
 * removeVMFsWatches() removes filesystem watchers for a given vm
 *
 * Arguments:
 *   'zonename' - a zonename for a vm to use in the watcher path
 *
 * This function will:
 *   1) Remove the watcher for /etc/zones/<zonename>.xml
 *   2) Remove watchers for config files in /zones/<zonename>/config/*.json
 *
 */
function removeVMFsWatches(zonename)
{
    function unwatch(pathname) {
        fsw.watch(pathname, function (err) {
            if (err) {
                log.warn(err, 'failed to remove watch');
                return;
            }
            log.debug('now watching ' + pathname);
        });
    }

    watch('/etc/zones/' + zonename + '.xml');

    CONFIG_FILES.forEach(function (f) {
        watch('/zones/' + zonename + '/config/' + f);
    });
}

/*
 * setVmData() sets the initial vm_data
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will request a cache object from loadVmData and set vm_data
 *
 */
function setVmData(callback)
{
    loadVmData(function (err, cache) {
        vm_data = cache;
        console.log('initial vm_data: ' + JSON.stringify(vm_data, null, 2));
        callback();
    });
}

/*
 * loadVmData() loads a cache object from vmload.getZoneData
 *
 * Arguments:
 *   'callback' - will be called with (err, cache)
 *
 * This function will load a cache object from vmload.getZoneData
 * passing a nocache: true flag to ensure the cache object is generated
 * from raw data.
 *
 */
function loadVmData(callback)
{
    var opts = {log: log, nocache: true};
    vmload.getZoneData(null, opts, callback);
}

/*
 * setVmobjs() sets the initial vmobjs data
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will request vmobjs from vmload.getVmobjs, using the cache
 * object set in vm_cache. The result will then be converted from an array
 * into a hash where the key is the vm uuid and the value is the vmobj.
 *
 */
function setVmobjs(callback)
{
    vmload.getVmobjs({cache: vm_data, log: log}, function (err, results) {
        vmobjs = {};

        results.forEach(function (vmobj) {
            vmobjs[vmobj.uuid] = vmobj;
        });

        console.log('initial vmobjs: ' + JSON.stringify(vmobjs, null, 2));
        callback();
    });
}

function handleGet(c, args, response)
{
    log.debug('GET (' + JSON.stringify(c) + ') len: ' + c.length);

    switch (c[0]) {
    case 'data':
    case 'cache':
        // return the cache object
        response.writeHead(200, { 'Content-Type': 'application/json'});
        response.end(JSON.stringify(vm_data, null, 2), 'utf-8');
        break;
    case 'vms':
        if (c.length === 2) {
            // requesting a vmobj with uuid
            var uuid = c[1];
            var vm = vmobjs[uuid];

            if (vm === undefined) {
                response.writeHead(404, { 'Content-Type': 'application/json'});
                response.write('Unable to load VM ' + uuid);
                response.end();
            } else {
                response.writeHead(200, { 'Content-Type': 'application/json'});
                response.end(JSON.stringify(vm, null, 2), 'utf-8');
            }
        } else {
            // requesting the vmobj list
            var vms = [];

            Object.keys(vmobjs).forEach(function (uuid) {
                vms.push(vmobjs[uuid]);
            });

            response.writeHead(200, { 'Content-Type': 'application/json'});
            response.end(JSON.stringify(vms, null, 2), 'utf-8');
        }
        break;
    default:
        response.writeHead(404, { 'Content-Type': 'application/json'});
        response.write('Unsupported URL Path');
        response.end();
        break;
    }
}

function startHTTPHandler(callback)
{
    var handler = function (request, response) {
        var args;
        var c;
        var url_parts;

        url_parts = url.parse(request.url, true);
        c = url_parts.pathname.split('/');

        // remove empty /'s from front/back
        while (c.length > 0 && c[0].length === 0) {
            c.shift();
        }
        while (c.length > 0 && c[c.length - 1].length === 0) {
            c.pop();
        }

        // we might need args for filtering vmobjs... maybe
        if (url_parts.hasOwnProperty('query')) {
            args = url_parts.query;
            log.debug('url ' + request.url);
            log.debug('args ' + JSON.stringify(args));
        } else {
            args = {};
        }

        if (request.method !== 'GET') {
            // Bad request
            response.writeHead(400, {'Content-Type': 'application/json'});
            response.end();
        } else {
            handleGet(c, args, response);
        }
    };

    log.debug('LISTENING ON ' + LISTEN_SOCKET);
    // http.createServer(handler).listen(LISTEN_SOCKET, cb);
    // temporarily for testing with curl
    http.createServer(handler).listen(9090, '127.0.0.1', callback);
}

function reset(callback)
{
    callback();
}

function startTimers(callback)
{
    setInterval(function () {
        reset(function (err) {
            log.debug('reset');
        });
    }, REFRESH_INTERVAL);

    callback();
}

function main() 
{
    async.series([
        initQueue,
        initLocks,
        startWatchers,
        setVmData,
        setVmobjs,
        startVmWatchers,
        startHTTPHandler,
        startTimers
    ], function (err) {
        console.error('XXX DONE');
    });
}

main();


/*
 * TODO:
 *
 * bubble/handle errors from initialization sequence
 * custom dataset/zfs logic
 *
 */

