/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var bunyan = require('/usr/node/node_modules/bunyan');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var path = require('path');
var spawn = cp.spawn;
var util = require('util');

function ZpoolWatcher(options) {
    var self = this;
    var buffers = {stdout: '', stderr: ''};
    var log = options.log;

    self.options = options;
    self.ready = false;
    self.watcher = null; // the handle to the child process
    self.watcher_pid = null;
    self.shutting_down = false;

    assert(options.log, 'no logger passed to ZpoolWatcher()');
    self.log = options.log;

    self.startWatcher = function () {
        var cmd = '/usr/sbin/dtrace';
        // This ugly command gives us the same data as 'zpool history', but as a
        // stream. This way we can catch events as they happen.
        var cmdargs = ['-n',
            'fbt::spa_history_log_sync:entry '
            + '{ '
                + 'self->tracing = 1; '
            + '} '
            + 'fbt::spa_history_log_sync:return '
            + '/self->tracing/ '
            + '{ '
                + 'self->tracing = 0; '
            + '} '
            + 'fbt::fnvlist_add_uint64:entry '
            + '/self->tracing && args[1] == "history time"/ '
            + '{ '
                + 'self->timestamp = args[2]; '
            + '} '
            + 'fbt::zfs_dbgmsg:entry '
            + '/self->tracing && args[0] == "txg %lld %s %s (id %llu) %s"/ '
            + '{ '
                + 'printf("%u %s %s %s\\n", self->timestamp, '
                + 'stringof(arg2), stringof(arg3), stringof(arg5)); '
            + '}'
        ];
        var cmdline;

        cmdline = cmd + ' ' + cmdargs.join(' ');
        log.debug({cmdline: cmdline}, 'executing dtrace');
        self.watcher = spawn(cmd, cmdargs, {stdio: 'pipe'});
        self.watcher_pid = self.watcher.pid;

        self.watcher.stdout.on('data', function (data) {
            lineChunk(data, 'stdout', function (chunk) {
                handleChunk(chunk);
            });
        });

        self.watcher.stderr.on('data', function (data) {
            lineChunk(data, 'stderr', function (chunk) {
                var eobj;

                if (chunk.match(/^.* matched 4 probes/)) {
                    self.ready = true;
                    eobj = {type: 'ready', message: 'dtrace is running'};
                    self.emit('ready', eobj);
                    self.emit('all', eobj);
                    return;
                }
                log.trace({stderr: chunk});
            });
        });

        // doesn't take input.
        self.watcher.stdin.end();

        self.watcher.on('close', function (code, signal) {

            log.warn('dtrace ' + self.watcher_pid + ' exited. code: ' + code
                + ' signal: ' + signal);
            self.watcher_pid = null;

            /*
             * If child closed unexpectedly (ie. it was not shutdown()): we'll
             * restart.
             */
            if (!self.shutting_down) {
                self.startWatcher();
            }
        });
    };

    function handleChunk(line) {
        var match;
        var evt;

        /*
         * eg.
         *
         *  1397659410 \
         *      set \
         *      zones/cc32d416-57f4-463b-a054-e1422a4f23de/data \
         *      zoned=1
         *
         */

        if (line.match(/^\ *CPU/) || line.length === 0) {
            // ignore empty lines and header
            return;
        }

        match = line.match(
            /^\ *[0-9]*\ *[0-9]*\ *[a-z_\:]* ([0-9]*) ([^\ ]*) ([^\ ]*)(.*)$/);
        assert(match, '[' + line + ']: doesn\'t match expected format');

        evt = {
            timestamp: Number(match[1]),
            action: match[2],
            dsname: match[3],
            extra: {}
        };

        if (match[4].length > 0) {
            match[4].split(' ').forEach(function (opt) {
                var parts;
                var number;

                if (opt.length === 0) {
                    return;
                }

                /* JSSTYLED */
                if (opt.match(/=/)) {
                    parts = opt.split('=');
                    assert(parts.length === 2, '[' + opt
                        + '] has invalid parts');

                    /*
                     * Some numbers are magic. For example:
                     *
                     *   extra: { compression: 15 }
                     *
                     * where the number here for 'compression' is the
                     * index in zio_compress_table in:
                     *
                     *   uts/common/fs/zfs/zio_compress.c
                     *
                     * which you can also read out through:
                     *
                     *   mdb -k -e 'zio_compress_table::print'
                     *
                     */
                    number = Number(parts[1]);
                    if (isNaN(number)) {
                        evt.extra[parts[0]] = parts[1];
                    } else {
                        evt.extra[parts[0]] = number;
                    }
                } else {
                    console.error('skipping: [' + opt + ']'); // XXX log
                }
            });
        }

        evt.type = evt.action;
        log.debug({evt: evt}, 'parsed event');

        // action is 'create','destroy','snapshot',etc.
        self.emit(evt.action, evt);
        self.emit('all', evt);
    }

    function lineChunk(data, buffer, handler) {
        var chunk;
        var chunks;

        buffers[buffer] += data.toString();
        chunks = buffers[buffer].split('\n');

        while (chunks.length > 1) {
            chunk = chunks.shift();
            handler(chunk);
        }
        buffers[buffer] = chunks.pop(); // remainder
    }
};

util.inherits(ZpoolWatcher, EventEmitter);

ZpoolWatcher.prototype.start = function () {
    var self = this;

    self.startWatcher();
}

// TODO: shutdown (and start again?)
ZpoolWatcher.prototype.shutdown = function ()
{
    var listeners = [];
    var self = this;
    var log = self.log;

    self.shutting_down = true;

    [
        'all',
        'create',
        'destroy',
        'ready',
        'set',
        'snapshot'
    ].forEach(function (type) {
        listeners = self.listeners(type);
        log.debug('cleanup called w/ listeners(' + type + '): '
            + util.inspect(listeners));
        self.removeAllListeners(type);
    });

    log.debug('zpool watcher ' + self.watcher_pid + ' cleanup called');
    if (self.watcher) {
        self.watcher.stdout.destroy(); // so we don't send more 'data'
        self.watcher.stderr.destroy();
        self.watcher.removeAllListeners('exit'); // so don't fail on kill
        self.watcher.removeAllListeners('close'); // so don't fail on kill
        log.debug('killing watcher ' + self.watcher_pid);
        self.watcher.kill();
        self.watcher = null;
    }
};

module.exports = {
    ZpoolWatcher: ZpoolWatcher
};
