/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

/*
 * The primary function of this module is to mantain an up-to-date copy of:
 *
 *   1) the complete vmobj list
 *   2) a vmload cache object.
 *
 * Both objects are consumable from the webservice:
 *
 *   - The complete vm list can be consumed at /vms
 *   - A single vm can be consumed at /vms/UUID
 *   - The cache can be consumed at /data or /cache
 *
 * Overview:
 *
 *   The tl;dr overview is that this module will listen for events within 3
 *   broad categories: zone state, zone config files, and zfs datasets.
 *   When an event is fired, we will delete portions of the cache object that
 *   are relevant to the event, then ask vmload to fill in the holes with
 *   getZoneData, which we can then update the vmobjs that were affected
 *   by the change, and lastly inform any subscribed consumers of the specific
 *   changes to the vmobj data.
 *
 * This module is not necessarily concerned with the details of a vmobj.
 * Meaning, the structure of the vmobj, where the data is derived, and how
 * the data is transformed are not the concern of this module. This module
 * will delegate that responsibility to the vmload modules. This module is
 * concerned with knowing when pieces of the cache object are likely
 * out-of-date, how to re-populate those pieces, and which vmobjs will be
 * affected by the change.
 *
 * The vmload module generates the final vmobj data from the following areas:
 *   - (1) the zone_t struct extracted from mdb
 *   - (1) the zoneadm utility
 *   - (2) the /etc/zones/UUID.xml file
 *   - (2) json files located in /zones/config/metadata*.json
 *   - (3) datasets from zfs list
 *
 * The data derived from category 1 (above) will need to be invalidated and
 * re-generated upon the reception of a zone event. Within the cache object,
 * we will delete ["last_modified"][<uuid>], ["pids"][<uuid>], and
 * ["zoneadm_objects"][<uuid>]. Finally, we will call vmload.getVmobj(<uuid>)
 * to re-populate this data, and replace the vmobj with the corresponding uuid.
 *
 * The data derived from category 2 (above) will need to be invalidated and
 * re-generated upon the reception of a filesystem event watching the specific
 * file in question. If the file is /etc/zones/uuid.xml, we will delete
 * ["zonexml_objects"][<uuid>]. If the file is /zones/config/metadataTYPE.json,
 * we will delete the corresponding key within ["json_objects"]["uuid"][...].
 * Finally, we will call vmload.getVmobj(<uuid>) to re-populate this data, and
 * replace the vmobj with the corresponding uuid.
 *
 * The data derived from category 3 (above) requires more work. At first, we
 * will start by listening for a zfs event. The event will notify us that a
 * dataset was created, renamed, or deleted. To minimize the zfs list, we will
 * remove all relevant pieces from within the "dataset_objects" structure, then
 * we will ask vmload-datasets directly to re-create the "dataset_objects" by
 * informing the vmload-datasets getDatasets function to only generate the
 * objects for the specific dataset that was modified. Some of these steps are
 * conditional to the dataset action. For instance, a create will not require
 * us to remove properties, and likewise, a delete will not require us to
 * rebuild the datasets structure after the pieces are removed. Finally, we
 * will derive the uuid from the dataset name, and will call
 * vmload.getVmobj(<uuid>) to re-populate this data, and replace the vmobj with
 * the corresponding uuid.
 *
 * At a routine interval, we will also force-refresh the cache and regenerate
 * the vmobj sets to ensure data integrity. When the refresh interval is fired,
 * we will first pause the event queue, then request a new cache object. Once
 * we have received a new cache object, we can replace the current cache object
 * with the new if the two cache objects are different. Only if the two objects
 * are different, we will iterate through all vmobjs and generate a new vmobj
 * from the new cache and report any deltas along the way. Finally, after all
 * vmobjs have been updated, we will resume the queue. It is possible that
 * resuming the events in the paused queue will cause some events to replay
 * that will have no effect in the final datasets.
 *
 * A new vmobj is created when a zone event is received for a uuid that we're
 * not currently watching, which will then register observers for relevant
 * config files.
 *
 * A vmobj is removed when the watched /etc/zones/<uuid>.xml receives the
 * DELETE event. At this point, we will also remove all watchers that were
 * setup for that vmobj.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var bunyan = require('/usr/node/node_modules/bunyan');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var FsWatcher = require('vmevent/fswatcher').FsWatcher;
var fs = require('fs');
var vmload = require('/usr/vm/node_modules/vmload');
var getZoneRecords = require('/usr/vm/node_modules/vmload/vmload-zoneadm')
    .getZoneRecords;
var getDatasets = require('/usr/vm/node_modules/vmload/vmload-datasets')
    .getDatasets;
var path = require('path');
var spawn = cp.spawn;
var http = require('http');
var qs = require('querystring');
var url = require('url');
var ZoneWatcher = require('vmevent/zonewatcher').ZoneWatcher;
var ZpoolWatcher = require('vmevent/zpoolwatcher').ZpoolWatcher;
var Queue = require('./queue');

var CONFIG_FILES = [
    'metadata.json',
    'routes.json',
    'tags.json'
];

var VMInfo = module.exports = function (options) {
    // configurable options
    this.log = options.log;

    assert(this.log, 'must provide a logger');

    // set default port
    if (options.hasOwnProperty('port')) {
        this.port = options.port;
    } else {
        this.port = 9090;
    }

    // set default refresh interval
    if (options.hasOwnProperty('refresh_interval')) {
        this.refresh_interval = options.refresh_interval;
    } else {
        this.refresh_interval = 300000; // 5 minutes
    }
};

// todo: finalize boot sequence once wrapper complete
VMInfo.prototype.start = function (callback) {
    var self = this;

    async.series([
        // init queue
        function (cb) {
            var opts = {workers: 1, paused: true};
            self.event_queue = new Queue(opts);
            cb();
        },
        // start global watchers
        function (cb) {
            self.startWatchers(cb);
        },
        // start vm watchers
        function (cb) {
            self.startVmWatchers(cb);
        },
        // set vm_data
        function (cb) {
            self.setVmData(cb);
        },
        // set vmobjs data
        function (cb) {
            self.setVmobjs(cb);
        },
        // resume queue
        function (cb) {
            self.event_queue.resume();
            cb();
        },
        // start http server
        function (cb) {
            self.startHTTPHandler(cb);
        },
        // start refresh timers
        function (cb) {
            self.startTimers(cb);
        }
    ], function (err) {
        if (err) {
            self.log.error('failed to complete boot sequence');
            throw err;
        } else {
            self.log.info('boot sequence complete');
        }

        if (callback) {
            callback();
        }
    });
};

VMInfo.prototype.stop = function (callback) {
    if (callback) {
        callback();
    }
};

VMInfo.prototype.vmDatasets = function () {
    if (this.vm_data_tmp !== undefined) {
        return ([this.vm_data, this.vm_data_tmp]);
    } else {
        return ([this.vm_data]);
    }
};

VMInfo.prototype.handleFsEvent = function (obj) {
    var self = this;
    var zonexml_re = /\/etc\/zones\/(.+)\.xml/;
    var metadata_re = /\/zones\/(.+)\/config\/.+\.json/;
    var matches;
    var zonename;
    var contexts;

    self.log.debug('FS_EVENT: ' + JSON.stringify(obj));

    if (obj.type === 'ready') {
        return;
    }

    self.event_queue.enqueue(function (callback) {
        if (zonexml_re.test(obj.pathname)) {
            matches = zonexml_re.exec(obj.pathname);
            zonename = matches[1];

            // short-circuit if this vmobj doesn't exist
            if (!self.vmobjs.hasOwnProperty(zonename)) {
                self.log.debug('vmobj doesn\'t exist for ' + zonename);
                callback();
                return;
            }

            if (obj.type == 'delete') {
                self.log.debug(obj.pathname + ' deleted');
                // the show is over! teardown!
                async.series([
                    // unregister events
                    function (cb) {
                        self.stopVmWatchers(zonename, cb);
                    },
                    // delete vmobj
                    function (cb) {
                        delete (self.vmobjs)[zonename];
                        cb();
                    },
                    // clean vm_data
                    function (cb) {
                        self.vmDatasets().forEach(function (data) {
                            for (var key in data) {
                                if (data[key].hasOwnProperty(zonename)) {
                                    delete (data[key])[zonename];
                                }
                            }
                        });
                        cb();
                    }
                ], function () {
                    self.log.info('stopped watching ' + zonename);
                    callback();
                });
            } else {
                self.log.debug(obj.pathname + ' modified');
                // clear the missing pieces and refresh
                contexts = [
                    'zonexml_objects'
                ];

                self.vmDatasets().forEach(function (data) {
                    contexts.forEach(function (context) {
                        if (data.hasOwnProperty(context)
                            && data[context].hasOwnProperty(zonename)) {

                            delete (data[context])[zonename];
                        }
                    });
                });

                self.refreshVmobj(zonename, callback);
            }

        } else if (metadata_re.test(obj.pathname)) {
            matches = metadata_re.exec(obj.pathname);
            zonename = matches[1];

            self.log.debug(obj.pathname + ' modified');
            // short-circuit if this vmobj doesn't exist
            if (!self.vmobjs.hasOwnProperty(zonename)) {
                self.log.debug('vmobj doesn\'t exist for ' + zonename);
                callback();
                return;
            }

            // clear the missing pieces and refresh
            contexts = [
                'json_objects'
            ];

            self.vmDatasets().forEach(function (data) {
                contexts.forEach(function (context) {
                    if (data.hasOwnProperty(context)
                        && data[context].hasOwnProperty(zonename)) {

                        delete (data[context])[zonename];
                    }
                });
            });

            self.refreshVmobj(zonename, callback);
        } else {
            callback();
        }
        // todo: handle sysinfo
    });
};

/*
 * handleZoneEvent() is a callback for a ZoneWatcher
 *
 * Process:
 *
 *   First we extract the zonename property from the event, then see if we
 *   have any vmobjs registered with that zonename. If not, then this must be
 *   a vm create, which we will:
 *     1) fetch the vmobj from vmload.getVmobj
 *     2) register observers
 *     3) inform subscribers of the new vmobj
 *   If this is a vm that we already know about, we will:
 *     1) invalidate the relevant pieces of the vm_data
 *     2) refresh the vmobj by calling refreshVmobj
 */
VMInfo.prototype.handleZoneEvent = function (obj) {
    var self = this;
    var zonename = obj.zonename;

    self.log.debug('ZONE_EVENT: ' + JSON.stringify(obj));

    // we're only interested in change events
    if (obj.type !== 'change') {
        return;
    }

    self.event_queue.enqueue(function (cb) {
        self.log.debug('handling zone event for ' + zonename);

        if (!self.vmobjs.hasOwnProperty(zonename)) {
            self.log.debug('preparing to register and watch ' + zonename);
            // a new vm!
            var opts = {log: self.log, cache: self.vm_data};
            vmload.getVmobj(zonename, opts, function (error, vmobj) {
                if (error) {
                    self.log.error('failed to load vmobj for ' + zonename
                        + ': ' + error.message);
                    cb();
                } else {
                    self.vmobjs[zonename] = vmobj;
                    self.startVmWatchers(zonename, function (err) {
                        self.log.info('started watching ' + zonename);
                        // todo: notify subscribers
                        cb();
                    });
                }
            });
        } else {
            // remove pieces of the cache that might have been affected
            var contexts = [
                'zoneadm_objects',
                'zoneinfo_objects',
                'zonexml_objects',
                'pids',
                'last_exited',
                'last_modified'
            ];

            self.vmDatasets().forEach(function (data) {
                contexts.forEach(function (context) {
                    if (data.hasOwnProperty(context)
                        && data[context].hasOwnProperty(zonename)) {

                        delete (data[context])[zonename];
                    }
                });
            });

            self.refreshVmobj(zonename, cb);
        }
    });
};

/*
 * handleZpoolEvent() is a callback for a zpool watcher
 *
 * Process:
 *
 *   When type is clone or create:
 *     - fetch zpool data
 *     - merge into vm_cache
 *     - refresh vmobj
 *
 *   When type is set:
 *     - unset vm_data pieces
 *     - fetch zpool data
 *     - merge into vm_cache
 *     - refresh vmobj
 *
 *   When type is destroy:
 *     - unset vm_data
 *     - refresh vmobj
 *
 */
VMInfo.prototype.handleZpoolEvent = function (obj) {
    var self = this;
    var sections = ['datasets', 'mountpoints', 'snapshots'];
    var name = obj.dsname;

    self.log.debug('ZPOOL_EVENT: ' + JSON.stringify(obj));

    if (obj.type == 'ready') {
        return;
    }

    function expire() {
        self.vmDatasets().forEach(function (data) {
            var ds_objects = data.dataset_objects;
            sections.forEach(function (section) {
                if (ds_objects.hasOwnProperty(section)) {
                    if (section === 'mountpoints') {
                        for (var key in ds_objects[section]) {
                            if (ds_objects[section][key] == name) {
                                delete (ds_objects[section])[key];
                            }
                        }
                    } else {
                        if (ds_objects[section].hasOwnProperty(name)) {
                            delete (ds_objects[section])[name];
                        }
                    }
                }
            });
        });
    }

    function fetch(cb) {
        var opts = {log: self.log, dataset: name};
        getDatasets(opts, function (err, results) {
            if (err) {
                self.log.warn('failed to fetch datasets');
            }
            cb(err, results);
        });
    }

    function copy(cache) {
        self.vmDatasets().forEach(function (data) {
            sections.forEach(function (section) {
                for (var key in cache[section]) {
                    if (!data.hasOwnProperty('dataset_objects')) {
                        data.dataset_objects = {};
                    }
                    if (!data.dataset_objects.hasOwnProperty(section)) {
                        data.dataset_objects[section] = {};
                    }
                    data.dataset_objects[section][key] = cache[section][key];
                }
            });
        });
    }

    // we put all zfs events in the queue so that we can
    // pause the operations during a hard-refresh and replay
    // them on the both datasets. This has no direct impact
    // to the order of operations because vmload will serialize
    // all zfs operations anyway.
    self.event_queue.enqueue(function (cb) {
        self.log.debug('handling zfs event for ' + name);

        if (/clone|create/.test(obj.type)) {
            fetch(function (err, cache) {
                if (err) {
                    cb();
                    return;
                } else {
                    copy(cache);
                }
            });
        } else if (obj.type == 'set') {
            expire();
            fetch(function (err, cache) {
                if (err) {
                    cb();
                    return;
                } else {
                    copy(cache);
                }
            });
        } else if (obj.type == 'destroy') {
            expire();
        }

        // todo: if the zonename isn't a uuid, this won't work
        var uuid_re = new RegExp('zones\/.*('
            + '[a-f0-9]{8}-'
            + '[a-f0-9]{4}-'
            + '4[a-f0-9]{3}-'
            + '[89aAbB][a-f0-9]{3}-'
            + '[a-f0-9]{12})'
        );

        if (uuid_re.test(name)) {
            var uuid = uuid_re.exec(name)[1];

            // if we happen to grab an image uuid here,
            // the refreshVmobj will return immediately
            self.log.debug('refreshing vmobj ' + uuid + ' after zfs event');
            self.refreshVmobj(uuid, cb);
        } else {
            cb();
        }
    });
};

/*
 * refreshVmobj() refreshes the cached vmobj and reports any changes
 *
 * Process:
 *     1) refresh the vm_data cache by calling vmload.getZoneData
 *     2) request a new vmobj by calling vmload.getVmobj
 *     3) analyze vmobj delta
 *     4) if different:
 *       4a) replace the vmobj with the new vmobj
 *       4b) log the delta
 *       4c) inform any subscribers of the delta
 */
VMInfo.prototype.refreshVmobj = function (zonename, callback) {
    var self = this;

    // short-circuit if this vmobj doesn't exist
    if (!self.vmobjs.hasOwnProperty(zonename)) {
        self.log.debug('cannot refresh vmobj, doesn\'t exist');
        callback();
        return;
    }

    async.waterfall([
        // refresh vm_data cache
        function (cb) {
            self.log.debug('refreshing zoneData for ' + zonename);
            var opts = {log: self.log, cache: self.vm_data};
            vmload.getZoneData(zonename, opts, function (err, cache) {
                // we don't care about cache here because we provided a cache
                // object that was transformed by reference. So, cache in this
                // case is just a reference to vm_data, which we already store
                // globally. The idea here is that we just fill in the holes
                // that we previously created.

                if (err) {
                    self.log.error('unable to refresh vmobj for ' + zonename
                        + ', failed to getZoneData');
                }

                cb(err);
            });
        },
        // request a new vmobj
        function (cb) {
            self.log.debug('requesting new vmobj for ' + zonename);
            var opts = {log: self.log, cache: self.vm_data};
            vmload.getVmobj(zonename, opts, function (err, vmobj) {
                if (err) {
                    self.log.error('unable to refresh vmobj for ' + zonename
                        + ', failed to getVmobj');
                    cb(err);
                } else {
                    // pass the new vmobj down the stream
                    cb(null, vmobj);
                }
            });
        },
        // analyze delta, update live copy
        function (vmobj, cb) {
            // for time being, let's just override the existing
            self.vmobjs[zonename] = vmobj;

            cb(null, []);
        },
        // publish changes
        function (changes, cb) {
            // todo: submit changes to a publish queue
            cb();
        }
    ], callback);
};

/*
 * startWatchers() starts global watchers
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will:
 *   1) Create a FsWatcher object
 *   2) Watch for changes to /tmp/.sysinfo.json
 *   3) Create a ZoneWatcher
 *   4) Create a ZpoolWatcher
 */
VMInfo.prototype.startWatchers = function (callback) {
    var self = this;

    async.series([
        function (cb) {
            self.fsw = new FsWatcher({log: self.log, dedup_ns: 2000000000});

            self.fsw.on('all', function (obj) {
                self.handleFsEvent(obj);
            });
            self.fsw.once('ready', function (obj) {
                self.log.debug('filesystem watcher ready');
                cb();
            });

            self.fsw.start();
        }, function (cb) {
            self.fsw.watch('/tmp/.sysinfo.json', cb);
        }, function (cb) {
            self.zonew = new ZoneWatcher({log: self.log});

            self.zonew.on('all', function (obj) {
                self.handleZoneEvent(obj);
            });
            self.zonew.once('ready', function (obj) {
                self.log.debug('zone event watcher ready');
                cb();
            });

            self.zonew.start();
        }, function (cb) {
            self.zpoolw = new ZpoolWatcher({log: self.log});

            self.zpoolw.on('all', function (obj) {
                self.handleZpoolEvent(obj);
            });
            self.zpoolw.once('ready', function (obj) {
                this.log.debug('zpool watcher ready');
                cb();
            });

            self.zpoolw.start();
        }
    ], function () {
        self.log.info('global watchers ready');
        callback();
    });
};

/*
 * startVmWatchers() starts the watchers for a VM
 *
 * Arguments:
 *   'zonename' - a specific vm zonename to start watchers on
 *   'callback' - will be called with (err)
 *
 *   'zonename' argument is optional, and when omitted will start watchers
 *   for all vms.
 */
VMInfo.prototype.startVmWatchers = function (zonename, callback) {
    var self = this;

    if (arguments.length === 1) {
        callback = zonename;
        zonename = undefined;
    }

    if (zonename === undefined) {
        async.waterfall([
            // load zone records
            function (cb) {
                getZoneRecords(null, {log: self.log}, function (err, records) {
                    if (err) {
                        self.log.debug('failed to load zone records: '
                            + err.message);
                    }
                    cb(err, records);
                });
            },
            // start watchers
            function (records, cb) {
                for (var uuid in records) {
                    self.addVMFsWatches(records[uuid].zonename);
                }
                cb();
            }
        ], function (err) {
            if (err) {
                self.log.error('failed to start vm watchers');
            }
            callback(err);
        });
    } else {
        self.addVMFsWatches(self.vmobjs[zonename].zonename);
        callback();
    }
};

/*
 * stopVmWatchers() stops the watchers for a VM
 *
 * Arguments:
 *   'zonename' - a specific vm zonename to stop watchers on
 *   'callback' - will be called with (err)
 *
 *   'zonename' argument is optional, and when omitted will stop watchers
 *   for all vms.
 */
VMInfo.prototype.stopVmWatchers = function (zonename, callback) {
    if (arguments.length === 1) {
        callback = zonename;
        zonename = undefined;
    }

    if (zonename === undefined) {
        for (zonename in this.vmobjs) {
            this.removeVMFsWatches(zonename);
        }
    } else {
        this.removeVMFsWatches(this.vmobjs[zonename].zonename);
    }

    callback();
};

/*
 * addVMFsWatches() creates filesystem watchers for a given vm
 *
 * Arguments:
 *   'zonename' - a zonename for a vm to use in the watcher path
 *
 * This function will:
 *   1) Create a watcher for /etc/zones/<zonename>.xml
 *   2) Create watchers for config files in:
 *     /zones/<zonename>/config/CONFIG.json
 *
 */
VMInfo.prototype.addVMFsWatches = function (zonename) {
    var self = this;

    self.log.trace('adding vm fs watchers for ' + zonename);

    function watch(pathname) {
        self.fsw.watch(pathname, function (err) {
            if (err) {
                self.log.warn(err, 'failed to setup watch');
                return;
            }
            self.log.debug('now watching ' + pathname);
        });
    }

    watch('/etc/zones/' + zonename + '.xml');

    CONFIG_FILES.forEach(function (f) {
        watch('/zones/' + zonename + '/config/' + f);
    });
};

/*
 * removeVMFsWatches() removes filesystem watchers for a given vm
 *
 * Arguments:
 *   'zonename' - a zonename for a vm to use in the watcher path
 *
 * This function will:
 *   1) Remove the watcher for /etc/zones/<zonename>.xml
 *   2) Remove watchers for config files in:
 *     /zones/<zonename>/config/CONFIG.json
 *
 */
VMInfo.prototype.removeVMFsWatches = function (zonename) {
    var self = this;

    self.log.trace('removing vm fs watchers for ' + zonename);

    function unwatch(pathname) {
        self.fsw.unwatch(pathname, function (err) {
            if (err) {
                self.log.warn(err, 'failed to remove watch');
                return;
            }
            self.log.debug('now watching ' + pathname);
        });
    }

    unwatch('/etc/zones/' + zonename + '.xml');

    CONFIG_FILES.forEach(function (f) {
        unwatch('/zones/' + zonename + '/config/' + f);
    });
};

/*
 * setVmData() sets the initial vm_data
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will request a cache object from loadVmData and set vm_data
 *
 */
VMInfo.prototype.setVmData = function (callback) {
    var self = this;

    self.loadVmData(function (err, cache) {
        if (err) {
            self.log.error('failed to set initial vm_data');
        } else {
            self.log.debug('setting initial vm_data: ' + cache);
            self.vm_data = cache;
        }
        callback(err);
    });
};

/*
 * loadVmData() loads a cache object from vmload.getZoneData
 *
 * Arguments:
 *   'callback' - will be called with (err, cache)
 *
 * This function will load a cache object from vmload.getZoneData
 * passing a nocache: true flag to ensure the cache object is generated
 * from raw data.
 *
 */
VMInfo.prototype.loadVmData = function (callback) {
    var self = this;
    var opts = {log: self.log, nocache: true};
    vmload.getZoneData(null, opts, function (err, cache) {
        if (err) {
            self.log.debug('failed vmload.getZoneData: ' + err.message);
        }
        callback(err, cache);
    });
};

/*
 * setVmobjs() sets the initial vmobjs data
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will request vmobjs from vmload.getVmobjs, using the cache
 * object set in vm_cache. The result will then be converted from an array
 * into a hash where the key is the vm uuid and the value is the vmobj.
 *
 */
VMInfo.prototype.setVmobjs = function (callback) {
    var self = this;
    var opts = {cache: self.vm_data, log: self.log};
    vmload.getVmobjs(opts, function (err, results) {
        if (err) {
            self.log.debug('failed vmload.getVmobjs: ' + err.message);
            self.log.error('failed to set vmobjs');
        } else {
            self.vmobjs = {};

            results.forEach(function (vmobj) {
                self.vmobjs[vmobj.zonename] = vmobj;
            });
        }
        callback(err);
    });
};

VMInfo.prototype.handleGet = function (c, args, response) {
    var self = this;

    this.log.debug('GET (' + JSON.stringify(c) + ') len: ' + c.length);

    switch (c[0]) {
    case 'data':
        // return the vm_data object
        response.writeHead(200, { 'Content-Type': 'application/json'});
        response.end(JSON.stringify(self.vm_data, null, 2), 'utf-8');
        break;
    case 'vms':
        if (c.length === 2) {
            // requesting a vmobj with zonename
            var zonename = c[1];
            var vm = self.vmobjs[zonename];

            if (vm === undefined) {
                response.writeHead(404, { 'Content-Type': 'application/json'});
                response.write('Unable to load VM ' + zonename);
                response.end();
            } else {
                response.writeHead(200, { 'Content-Type': 'application/json'});
                response.end(JSON.stringify(vm, null, 2), 'utf-8');
            }
        } else {
            // requesting the vmobj list
            var vms = [];

            for (zonename in self.vmobjs) {
                vms.push(self.vmobjs[zonename]);
            }

            response.writeHead(200, { 'Content-Type': 'application/json'});
            response.end(JSON.stringify(vms, null, 2), 'utf-8');
        }
        break;
    default:
        response.writeHead(404, { 'Content-Type': 'application/json'});
        response.write('Unsupported URL Path');
        response.end();
        break;
    }
};

VMInfo.prototype.startHTTPHandler = function (callback) {
    var self = this;
    var ip;
    var ips = ['127.0.0.1'];

    var handler = function (request, response) {
        var args;
        var c;
        var url_parts;

        url_parts = url.parse(request.url, true);
        c = url_parts.pathname.split('/');

        // remove empty /'s from front/back
        while (c.length > 0 && c[0].length === 0) {
            c.shift();
        }
        while (c.length > 0 && c[c.length - 1].length === 0) {
            c.pop();
        }

        // we might need args for filtering vmobjs... maybe
        if (url_parts.hasOwnProperty('query')) {
            args = url_parts.query;
            self.log.debug('url ' + request.url);
            self.log.debug('args ' + JSON.stringify(args));
        } else {
            args = {};
        }

        if (request.method !== 'GET') {
            // Bad request
            response.writeHead(400, {'Content-Type': 'application/json'});
            response.end();
        } else {
            self.handleGet(c, args, response);
        }
    };

    for (ip in ips) {
        ip = ips[ip];
        self.log.debug('LISTENING ON ' + ip + ':' + self.port);
        http.createServer(handler).listen(self.port, ip);
    }

    callback();
};

/*
 * reset() hard reset the data to ensure integrity
 *
 * This function will:
 *   1- pause the event queue
 *   2- fetch new vm_data
 *   3- fast-forward the event queue
 *   4- compare datasets
 *   5- replace vm_data with vm_data_tmp if the sets are different
 *   6- refresh vmobjs if the sets are different
 *   7- resume the event queue
 */
VMInfo.prototype.reset = function (callback) {
    var self = this;

    async.series([
        // pause the queue
        function (cb) {
            self.log.debug('pausing the event queue');
            self.event_queue.pause(cb);
        },
        // fetch new data
        function (cb) {
            self.loadVmData(function (err, results) {
                if (err) {
                    this.log.error('failed to fetch new vm_data');
                } else {
                    self.vm_data_tmp = results;
                }
                cb(err);
            });
        },
        // fast-forward the queue
        function (cb) {
            var now = (new Date()).toISOString();
            self.log.debug('fast-forwarding the queue to ' + now);
            self.event_queue.fastForward(now, cb);
        },
        // compare/update vmobjs
        function (cb) {
            cb();
        },
        // resume the queue
        function (cb) {
            self.log.debug('resuming the event queue');
            self.vm_data_tmp = undefined;
            self.event_queue.resume();
            cb();
        }
    ], callback);
};

VMInfo.prototype.startTimers = function (callback) {
    var self = this;

    setTimeout(function () {
        self.log.info('preparing to refresh data');
        self.reset(function (err) {
            self.startTimers();
        });
    }, self.refresh_interval);

    if (callback) {
        callback();
    }
};
