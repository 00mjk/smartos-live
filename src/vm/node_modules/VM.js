#!/usr/bin/node
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2011 Joyent Inc., All rights reserved.
 *
 *
 * Exported functions:
 *
 * console(uuid, callback)
 * create(properties, callback)
 * delete(uuid, callback)
 * info(uuid, types, callback)
 * load([zonename|uuid], callback)
 * lookup(match, callback)
 * reboot(uuid, options={[force=true]}, callback)
 * start(uuid, extra, callback)
 * stop(uuid, options={[force=true]}, callback)
 * sysrq(uuid, req=[nmi|screenshot], options={}, callback)
 * update(uuid, properties, callback)
 *
 * Exported variables:
 *
 * logger - a function which takes (priority, message, <Error Obj>)
 * INFO_TYPES - list of supported types for the info command
 * SYSRQ_TYPES - list of supported requests for sysrq
 */


var async = require('async');
var cp = require('child_process');
var execFile = cp.execFile;
var fs = require('fs');
var httpu = require('httpu');
var net = require('net');
var path = require('path');
var spawn = cp.spawn;
var sprintf = require('sprintf').sprintf;
var system = require('system');

// The numbers match the syslog levels + TRACE which I added.
var LOG_LEVELS = {
    'EMERG': 0,  // Emergency: system is unusable
    'ALERT': 1,  // Alert: action must be taken immediately
    'CRIT': 2,   // Critical: critical conditions
    'ERROR': 3,  // Error: error conditions
    'WARN': 4,   // Warning: warning conditions
    'NOTICE': 5, // Notice: normal but significant condition
    'INFO': 6,   // Informational: informational messages
    'DEBUG': 7,  // Debug: debug-level messages
    'TRACE': 8   // Trace: log everything we know how
};

var VMADMD_SOCK = '/tmp/vmadmd.http';

/*

zone states from libzonecfg/common/zonecfg_impl.h

#define ZONE_STATE_STR_CONFIGURED       "configured"
#define ZONE_STATE_STR_INCOMPLETE       "incomplete"
#define ZONE_STATE_STR_INSTALLED        "installed"
#define ZONE_STATE_STR_READY            "ready"
#define ZONE_STATE_STR_MOUNTED          "mounted"
#define ZONE_STATE_STR_RUNNING          "running"
#define ZONE_STATE_STR_SHUTTING_DOWN    "shutting_down"
#define ZONE_STATE_STR_DOWN             "down"

*/

exports.logger = mlogger;
exports.loglevel = 'INFO';

var VM = this;

// The default logger
function mlogger(priority, message, err)
{
    var now = new Date;
    var args = [];

    now = now.toISOString();

    if (LOG_LEVELS[priority] > LOG_LEVELS[VM.loglevel]) {
        return;
    }

    process.stderr.write(now + ' -- ' + process.pid + ' -- ' +
        priority + ' ' + message + '\n');
    if (err && err.hasOwnProperty('stack')) {
        lines = err.stack.split('\n');
        for (line in lines) {
            line = rtrim(lines[line]);
            if (line.length > 0) {
                process.stderr.write(now + ' -- ' + process.pid + ' -- ' +
                    priority + ' ' + line + '\n');
            }
        }
    }
}

function ltrim(str, chars)
{
    chars = chars || "\\s";
    str = str || "";
    return str.replace(new RegExp("^[" + chars + "]+", "g"), "");
}

function rtrim(str, chars)
{
    chars = chars || "\\s";
    str = str || "";
    return str.replace(new RegExp("[" + chars + "]+$", "g"), "");
}

function trim(str, chars)
{
    return ltrim(rtrim(str, chars), chars);
}

function isUUID(str)
{
    if (str.length === 36 &&
        str[8] === '-' && str[13] === '-' &&
        str[18] === '-' && str[23] === '-') {

        return true;
    } else {
        return false;
    }
}

// XXX deleteme
function indexSort(a, b)
{
    return a.index - b.index;
}

function fixBoolean(str)
{
    if (str === 'true') {
        return true;
    } else if (str === 'false') {
        return false;
    } else {
        return str;
    }
}

// IMPORTANT:
//
//  Some of these properties get translated below into backward compatible
//  names.
//
var GLOBAL_PROPS = [
    'autoboot',
    'brand',
    'limitpriv',
    'zonename',
    'zonepath',
    'ram',
    'vm-autoboot',
    'transition',
    'never-booted',
    'vcpus',
    'cpu-type',
    'cpu-shares',
    'create-timestamp',
    'owner-uuid',
    'billing-id',
    'package-name',
    'package-version',
    'hostname',
    'dns-domain',
    'resolvers',
    'tmpfs',
    'default-gateway',
    'qemu-opts',
    'qemu-extra-opts',
    'alias',
    'boot'
];

var NET_PROPS = [
    'global-nic',
    'mac-addr',
    'physical',
    'vlan-id',
    'index',
    'model',
    'ip',
    'netmask',
    'gateway'
];

var UPDATABLE_NIC_PROPS = [
    'nic_tag',
    'blocked_outgoing_ports',
    'mac',
    'gateway',
    'ip',
    'model',
    'netmask',
    'vlan_id'
];

var DISK_PROPS = [
    'index',
    'model',
    'boot',
    'match',
    'zpool',
    'media',
    'image-uuid',
    'image-name',
    'image-size',
    'size'
];

var UPDATABLE_DISK_PROPS = [
    'boot',
    'model',
    'index'
];

// Note: this doesn't include 'state' because of 'stopping' which is a virtual
// state and therefore lookups would be wrong (because they'd search on real
// state).
var QUICK_LOOKUP = [
    'zoneid',
    'zonename',
    'zonepath',
    'uuid',
    'brand',
    'ip_type'
];

exports.INFO_TYPES = [
    'all',
    'version',
    'chardev',
    'block',
    'blockstats',
    'cpus',
    'pci',
    'kvm',
    'vnc'
];

exports.SYSRQ_TYPES = [
    'nmi',
    'screenshot'
];

function parseConfig(input)
{
    var result = {};
    var obj;
    var line, lines;
    var section;
    var kv, key, value;
    var tmp;
    var attr, nic, disk;
    var nets = [], attrs = [], devices = [], rctls = [];
    var props = {};
    var matches;
    var fields;

    VM.logger('DEBUG', 'parseConfig() parsing zonecfg output.');

    lines = input.split('\n');
    for (line in lines) {
        if (lines.hasOwnProperty(line)) {
            line = rtrim(lines[line]);
            if (line[0] === '\t') {
                line = ltrim(line);
                kv = line.split(':');
                key = trim(kv[0], "\\s\\[");
                value = trim(kv.slice(1).join(':'), "\\s\\]\\\"");

                if (key === "property") {
                    // handle form: "property": "(name=model,value=\"virtio\")"
                    matches = value.match(/name=([^,]+),value=\"([^\"]+)\"/);
                    if (matches) {
                        key = matches[1];
                        value = matches[2];
                    } else {
                        continue;
                    }
                }

                value = fixBoolean(value);

                switch (section) {
                case 'net':
                    obj = nets[nets.length - 1];
                    obj[key] = value;
                    break;
                case 'device':
                    obj = devices[devices.length - 1];
                    obj[key] = value;
                    break;
                case 'attr':
                    obj = attrs[attrs.length - 1];
                    obj[key] = value;
                    break;
                case 'rctl':
                    obj = rctls[rctls.length - 1];
                    obj[key] = value;
                    break;
                case 'default':
                    VM.logger('DEBUG', 'parseConfig() ignoring line ' +
                        line);
                    break;
                }
            } else {
                kv = line.split(':');
                key = trim(kv[0], "\\s\\[");
                value = fixBoolean(trim(kv.slice(1).join(':'), "\\s\\]"));

                if (key === "") {
                    continue;
                }
                if (value === "") {
                    // start of a new section is a key with no value
                    section = key;
                    switch (section) {
                    case 'net':
                        nets.push({});
                        break;
                    case 'device':
                        devices.push({});
                        break;
                    case 'attr':
                        attrs.push({});
                        break;
                    case 'rctl':
                        rctls.push({});
                        break;
                    case 'capped-memory':
                    case 'bootargs':
                    case 'pool':
                    case 'limitpriv':
                    case 'scheduling-class':
                    case 'hostid':
                    case 'fs-allowed':
                        // ignore these for now
                        break;
                    default:
                        VM.logger('DEBUG', 'parseConfig() ignoring ' +
                            'section type "' + section + '"');
                        break;
                    }
                } else {
                    // not section header, but top-level key
                    section = null;
                    props[key] = value;
                }
            }
        }
    }

    for (obj in props) {
        if (props.hasOwnProperty(obj)) {
            if (GLOBAL_PROPS.indexOf(obj) !== -1) {
                if (obj === 'zonename') {
                    result.zonename = props[obj];
                } else if (obj === 'autoboot') {
                    result.zone_autoboot = props[obj];
                } else if (obj === 'cpu-shares') {
                    result.cpu_shares = Number(props[obj]);
                } else {
                    result[obj] = fixBoolean(props[obj]);
                }
            } else if (VM.DEBUG) {
                VM.logger('DEBUG', 'parseConfig() ignoring unknown zone ' +
                    'prop: ' + obj);
            }
        }
    }

    for (rctl in rctls) {
        if (rctls.hasOwnProperty(rctl)) {
            key = rctls[rctl].name;
            value = rctls[rctl].value.match(/limit=([^,]+),/)[1];
            switch (key) {
            case 'zone.cpu-cap':
                result['cpu_cap'] = Number(value);
                break;
            case 'zone.zfs-io-priority':
                result['zfs_io_priority'] = Number(value);
                break;
            case 'zone.max-lwps':
                result['max_lwps'] = Number(value);
                break;
            case 'zone.max-physical-memory':
                result['max_physical_memory'] = value / (1024 * 1024);
                break;
            case 'zone.max-locked-memory':
                result['max_locked_memory'] = value / (1024 * 1024);
                break;
            case 'zone.max-swap':
                result['max_swap'] = value / (1024 * 1024);
                break;
            }
        }
    }

    for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
            if (GLOBAL_PROPS.indexOf(attrs[attr].name) !== -1) {
                key = attrs[attr].name;
                if (key === 'vm-autoboot') {
                    key = 'autoboot';
                } else if (key === 'capped-cpu') {
                    key = 'capped_cpu';
                } else if (key === 'owner-uuid') {
                    key = 'owner_uuid';
                } else if (key === 'create-timestamp') {
                    key = 'create_timestamp';
                } else if (key === 'never-booted') {
                    key = 'never_booted';
                } else if (key === 'billing-id') {
                    key = 'billing_id';
                } else if (key === 'package-name') {
                    key = 'package_name';
                } else if (key === 'package-version') {
                    key = 'package_version';
                } else if (key === 'cpu-type') {
                    key = 'cpu_type';
                } else if (key === 'dns-domain') {
                    key = 'dns_domain';
                } else if (key === 'alias') {
                    key = 'alias';
                } else if (key === 'qemu-opts') {
                    key = 'qemu_opts';
                } else if (key === 'qemu-extra-opts') {
                    key = 'qemu_extra_opts';
                }

                if (key === 'resolvers') {
                  if (key != '') {
                      result[key] = attrs[attr].value.split(',');
                  }
                } else if ([
                    'alias',
                    'qemu_opts',
                    'qemu_extra_opts'
                    ].indexOf(key) !== -1) {

                    result[key] = new Buffer(attrs[attr].value,
                        'base64').toString('ascii');
                } else if ([
                    'ram',
                    'tmpfs',
                    'vcpus'
                    ].indexOf(key) !== -1) {

                    result[key] = Number(attrs[attr].value);
                } else {
                    result[key] = fixBoolean(attrs[attr].value);
                }
            } else {
                VM.logger('DEBUG', 'parseConfig() ignoring unknown zone ' +
                    'prop: ' + attrs[attr].name);
            }
        }
    }

    result.nics = [];
    nets.sort(function (a, b) { return a.index - b.index; });
    for (nic in nets) {
        if (nets.hasOwnProperty(nic)) {
            tmp = {};
            for (obj in nets[nic]) {
                if (nets[nic].hasOwnProperty(obj)) {
                    if (NET_PROPS.indexOf(obj) !== -1) {
                        key = obj;
                        if (key === 'global-nic') {
                            tmp['nic_tag'] = nets[nic][obj];
                        } else if (key === 'mac-addr') {
                            tmp['mac'] = fixMac(nets[nic][obj]);
                        } else if (key === 'vlan-id') {
                            tmp['vlan_id'] = Number(nets[nic][obj]);
                        } else if (key === 'index') {
                            tmp['index'] = Number(nets[nic][obj]);
                        } else {
                            tmp[key] = fixBoolean(nets[nic][obj]);
                        }
                    } else {
                        VM.logger('DEBUG', 'parseConfig() ignoring ' +
                            'unknown nic prop: ' + obj);
                    }
                }
            }
            result.nics.push(tmp);
        }
    }

    result.disks = [];
    devices.sort(function (a, b) { return a.index - b.index; });
    for (disk in devices) {
        if (devices.hasOwnProperty(disk)) {
            tmp = {};
            for (obj in devices[disk]) {
                if (devices[disk].hasOwnProperty(obj)) {
                    if (DISK_PROPS.indexOf(obj) !== -1) {
                        if (obj === 'match') {
                            tmp.path = devices[disk][obj];
                            tmp.zpool = path.basename(path.dirname(tmp.path));
                            tmp.zfs_filesystem = tmp.zpool + '/' +
                                path.basename(tmp.path);
                        } else if (obj === 'image-size' || obj === 'size' ||
                            obj === 'index') {

                            tmp[obj.replace('-','_')] = Number(devices[disk][obj]);
                        } else {
                            tmp[obj.replace('-','_')] = fixBoolean(devices[disk][obj]);
                        }
                    } else {
                        VM.logger('DEBUG', 'parseConfig() ignoring ' +
                            'unknown disk prop: ' + obj);
                    }
                }
            }
            result.disks.push(tmp);
        }
    }

    if (result.hasOwnProperty('zonepath')) {
        result.zfs_storage_pool_name = result.zonepath.split('/')[1];
    }

    // transition overrides state if it's set
    if (result.hasOwnProperty('transition')) {
        fields = rtrim(result.transition).split(':');
        if (fields.length === 3) {
            delete result.transition;
            result.state = fields[0];
            result.transition_to = fields[1];
            result.transition_expire = fields[2];
        } else {
            VM.logger('DEBUG', 'parseConfig() ignoring bad value for ' +
                'transition "' + result.transition + '"');
        }
    }

    if (result.brand === 'joyent') {
        if (result.hasOwnProperty('zone_autoboot')) {
            result.autoboot = result.zone_autoboot;
        }

        // joyent zones don't have disks.
        delete result.disks;
    }
    delete result.zone_autoboot;

    VM.logger('DEBUG', 'parseConfig() finished parsing data for vm ' +
        result.uuid);

    return result;
}

function setQuota(zonepath, quota, callback)
{
    var dataset;

    if (!zonepath || zonepath[0] !== '/') {
        callback(new Error('Invalid zonepath: "' + zonepath + '"'));
    }
    dataset = zonepath.substr(1);

    zfs(['set', 'quota=' + quota.toString() + 'g', dataset], function (err, fds) {
        if (err) {
            VM.logger('ERROR', 'setQuota() cmd failed: ' + fds.stderr);
            return callback(new Error(rtrim(fds.stderr)));
        }
        return callback();
    });
}

/*
 * TODO:
 *
 * When loading quota for lots of machines, we should be able to do:
 *
 * zfs get -o name,value -p -H volsize
 *
 * once just pull the values out of that list.
 *
 */
function loadDiskQuotas(m, callback)
{
    function loader(disk, cb)
    {
        if (disk.hasOwnProperty('zfs_filesystem')) {
            args = ['get', '-o', 'value', '-p', '-H', 'volsize',
                disk.zfs_filesystem];

            zfs(args, function (err, fds) {
                var quota;
                if (err) {
                    if (!fds.stderr.match(/dataset does not exist/)) {
                        VM.logger('ERROR', 'loadDiskQuotas() cmd failed: "'
                            + rtrim(fds.stderr) + '"');
                        return cb(new Error(rtrim(fds.stderr)));
                    }
                    return cb(new Error('dataset does not exist'));
                }
                disk.size = rtrim(fds.stdout) / (1024 * 1024);
                return cb();
            });
        } else {
            return cb(new Error('could not find zfs_filesystem in ' +
                JSON.stringify(disk)));
        }
    }

    async.forEach(m.disks, loader, function (err) {
        if (err) {
            VM.logger('ERROR', 'Unable to load disks for ' + m.uuid, err);
            return callback(err);
        }
        return callback();
    });
}

/*
 * TODO:
 *
 * When loading quota for lots of machines, we should be able to do:
 *
 * zfs get -o name, -p -H quota
 *
 * once and just pull the values out of that list.
 *
 */
function loadDatasetQuota(m, callback)
{
    path.exists(m.zonepath, function (exists) {
        if (exists) {
            dataset = m.zonepath.substr(1);
            args = ['get', '-o', 'value', '-p', '-H', 'quota', dataset];

            zfs(args, function (err, fds) {
                var quota;
                if (err) {
                    if (!fds.stderr.match(/dataset does not exist/)) {
                        VM.logger('ERROR', 'loadDatasetQuota() cmd failed: "'
                            + rtrim(fds.stderr) + '"');
                        return callback(new Error(rtrim(fds.stderr)));
                    }
                    return callback(new Error('dataset does not exist'));
                }
                quota = rtrim(fds.stdout) / (1024 * 1024 * 1024);
                if (quota > 0) {
                    m.quota = quota;
                }
                return callback();
            });
        } else {
            normal_states = ['installed', 'running', 'shutting_down'];

            // only log this if the vm *should* have a dataset
            if (normal_states.indexOf(m.state) !== -1) {
                VM.logger('ERROR', 'loadQuotas() ' + m.zonepath +
                    ' does not exist');
            }
            return callback(new Error('dataset does not exist'));
        }
    });
}

function loadQuotas(m, callback)
{
    var disk;
    var args;
    var dataset;
    var normal_states;


    async.series([
        function (cb)
        {
            if (m.hasOwnProperty('disks')) {
                return loadDiskQuotas(m, cb);
            } else {
                return cb();
            }
        },
        function (cb)
        {
            if (m.zonepath && m.zonepath[0] === '/') {
                return loadDatasetQuota(m, cb);
            } else {
                VM.logger('ERROR', 'loadQuotas() bad zonepath for ' + m.uuid);
                return cb(new Error('Unable to determine zonepath for quota'));
            }
        }
    ],
    function (err, results)
    {
        return callback(err);
    });
}

function loadTags(vmcfg, callback)
{
    var filename;

    if (vmcfg.zonepath) {
        filename = vmcfg.zonepath + '/config/tags.json';
        VM.logger('DEBUG', 'loadTags() loading tags from ' + filename);
        path.exists(filename, function (exists) {
            if (exists) {
                fs.readFile(filename, function (error, data) {
                    var tags;
                    if (error) {
                        VM.logger('ERROR', 'loadTags() failed to load tags'
                            + ' from ' + filename, error);
                        return callback(error);
                    }
                    try {
                        tags = JSON.parse(data.toString());
                    } catch (e) {
                        tags = {};
                    }
                    return callback(null, tags);
                });
            } else {
                return callback(null, {});
            }
        });
    } else {
        return callback(null, {});
    }
}

function loadMetadata(vmcfg, callback)
{
    var filename;

    if (vmcfg.zonepath) {
        filename = vmcfg.zonepath + '/config/metadata.json';
        VM.logger('DEBUG', 'loadMetadata() loading metadata from ' +
            filename);
        path.exists(filename, function (exists) {
            if (exists) {
                fs.readFile(filename, function (error, data) {
                    var metadata;
                    if (error) {
                        VM.logger('ERROR', 'loadMetadata() failed to ' +
                            'load metadata from ' + filename, error);
                        return callback(error);
                    }
                    try {
                        metadata = JSON.parse(data.toString());
                    } catch (e) {
                        metadata = {};
                    }

                    loadTags(vmcfg, function (err, tags) {
                        if (err) {
                            return callback(null, metadata, {});
                        } else {
                            return callback(null, metadata, tags);
                        }
                    });
                });
            } else {
                return callback(null, {});
            }
      });
    } else {
        return callback(null, {});
    }
}

function getZoneRecords(zonekey, callback)
{
    var cmd;
    var args = [];
    var results = [];

    if (zonekey) {
        // this gives us zone info if zonekey is *either* a zonename or uuid
        if (isUUID(zonekey)) {
            args.push('-z');
            args.push(zonekey);
            args.push('-u');
            args.push(zonekey);
        } else {
            args.push('-z');
            args.push(zonekey);
        }
    }
    args.push('list');
    args.push('-p');
    if (!zonekey) {
        args.push('-c');
    }

    zoneadm(args, function (err, fds) {
        var lines;
        var fields;
        if (err) {
            VM.logger('ERROR', 'getZoneRecords() zoneadm "' +
                args.join(',') + '" failed', err);
            return callback(new Error(rtrim(fds.stderr)));
        }

        lines = fds.stdout.split('\n');
        for (line in lines) {
            fields = rtrim(lines[line]).split(':');
            if (fields.length === 8) {
                results.push({
                    'zoneid': fields[0],
                    'zonename': fields[1],
                    'state': fields[2],
                    'zonepath': fields[3],
                    'uuid': fields[4],
                    'brand': fields[5],
                    'ip_type': fields[6]
                });
            } else {
                VM.logger('DEBUG', 'getZoneRecords() ignoring line: ' +
                    lines[line]);
            }
        }
        return callback(null, results);
    });
}

function loadVM(zonekey, extra, callback)
{
    var cmd;
    var vmobj;
    var err;

    getZoneRecords(zonekey, function (error, info) {
        if (error) {
            VM.logger('ERROR', 'VM.load() failed to get zone record' +
                ' for ' + zonekey, error);
            return callback(error);
        }
        if (!info || info.length !== 1) {
            err = new Error('VM.load() empty info when getting record ' +
                'for vm ' + zonekey);
            VM.logger('ERROR', err.message, err);
            return callback(err);
        }
        info = info[0];

        zonecfg(['-z', info.zonename, 'info'], function (err, fds) {
            if (err) {
                return callback(new Error(rtrim(fds.stderr)));
            }

            vmobj = parseConfig(fds.stdout);

            // add the bits we can only find from zoneadm list
            vmobj.uuid = info.uuid;

            // In the case of 'configured' zones, we might only have zonename
            // because uuid isn't set yet.  Because of that case, we set uuid
            // to zonename if it is in UUID form.
            if ((!vmobj.uuid || vmobj.uuid.length === 0) &&
                isUUID(vmobj.zonename)) {

                vmobj.uuid = vmobj.zonename;
            }

            if (info.zoneid !== '-') {
                vmobj.zoneid = info.zoneid;
            }

            // state could already be set here if it was overriden by a
            // transition that's in progress.
            if (vmobj.hasOwnProperty('state')) {
                vmobj.real_state = info.state;
            } else if (info.state === 'installed') {
                vmobj.state = 'stopped';
            } else {
                vmobj.state = info.state;
            }

            loadMetadata(vmobj, function (err, metadata, tags) {
                if (err) {
                    return callback(new Error('Unable to add metadata:' +
                        err.toSring()));
                }
                loadQuotas(vmobj, function(err) {
                    if (err) {
                        if (err.message === 'dataset does not exist') {
                            VM.logger('DEBUG', 'saw "dataset does not ' +
                                'exist" for ' + vmobj.uuid, err);
                            quota = -1;
                        } else {
                            VM.logger('DEBUG', 'the error is: ' +
                                err.message, err);
                            return callback(new Error('Cannot determine ' +
                                'quota: ' + err.toString()));
                        }
                    }
                    for (k in metadata) {
                        vmobj[k] = metadata[k];
                    }
                    if (!vmobj.hasOwnProperty('customer_metadata')) {
                        vmobj.customer_metadata = {};
                    }
                    if (tags) {
                        vmobj.tags = tags;
                    } else {
                        vmobj.tags = {};
                    }
                    return callback(null, vmobj);
                });
            });
        });
    });
};

// zonekey can be either a zonename or uuid
exports.load = function(zonekey, callback)
{
    // This is a wrapper so that other internal functions here (such as lookup)
    // can do smart things like check the quota for each VM with a separate call
    // to zfs get.
    return loadVM(zonekey, {}, callback);
};

function forEach(func, callback)
{
    zoneadm(['list', '-c'], function (err, fds) {
        var idx, zone, zones;
        if (err) {
            return callback(rtrim(fds.stderr));
        }
        zones = rtrim(fds.stdout).split('\n');

        // remove global
        idx = zones.indexOf('global');
        if (idx !== -1) {
            zones.splice(idx, 1);
        }

        async.forEach(zones, func, function(err) {
            return callback(err);
        });
    });
};

function fixMac(str)
{
    var octet;
    var octets = str.split(':');
    var fixed = [];

    for (octet in octets) {
        if (octets.hasOwnProperty(octet)) {
            fixed.push(sprintf("%02x", parseInt(octets[octet], 16)));
        }
    }

    return fixed.join(':');
}

function matcher(zone, search)
{
    var matches;
    var d, n;
    var target;
    var found;
    var parameters_matched = 0;
    var regex;


    for (k in search) {
        found = false;
        regex = false;

        target = search[k];
        if (target[0] === '~') {
            regex = true;
            target = new RegExp(target.substr(1), 'i');
        }

        if (matches = k.match(/^(nic|disk)\.(.*)$/)) {
            if (matches[1] === 'nic') {
                for (n in zone.nics) {
                    if (zone.nics.hasOwnProperty(n)) {
                        if (!regex && matches[2] === 'mac') {
                            target = fixMac(target);
                        }
                        if (regex && zone.nics[n][matches[2]].match(target)) {
                            found = true;
                        } else if (zone.nics[n][matches[2]] === target) {
                            found = true;
                        }
                    }
                }
            } else { // disk
                for (d in zone.disks) {
                    if (zone.disks.hasOwnProperty(d)) {
                        if (regex && zone.disks[n][matches[2]].match(target)) {
                            found = true;
                        } else if (zone.disks[n][matches[2]] === target) {
                            found = true;
                        }
                    }
                }
            }
        } else {
            // not a disk or nic property, so check at top level.
            if (regex && zone.hasOwnProperty(k) &&
                zone[k].toString().match(target)) {

                found = true;
            } else if (zone.hasOwnProperty(k) && zone[k] &&
                zone[k].toString() === target.toString()) {

                found = true;
            }
        }

        if (!found) {
            return false;
        } else {
            parameters_matched++;
        }
    }

    if (parameters_matched > 0) {
        // we would have returned false from the loop had any parameters not
        // matched and we had at least one that did.
        return true;
    }

    return false;
}

exports.lookup = function (search, options, callback) {
    var results = [];
    var quick_ok = true;
    var transform;

    if (!options) {
        options = {};
    }

    // XXX the 'transform' option is not intended to be public yet and should
    // only be used by tools willing to be rewritten if this is removed or
    // changed.
    if (options.hasOwnProperty('transform')) {
        transform=options.transform;
    }

    for (key in search) {
        if (QUICK_LOOKUP.indexOf(key) === -1) {
            quick_ok = false;
        }
    }

    if (quick_ok) {
        // we *only* need info that comes from getZoneRecords()
        getZoneRecords(null, function (err, zones) {
            var z;
            var match;
            var target;
            var regex;
            var full_results = [];

            if (err) {
                return callback(err);
            }
            for (z in zones) {
                z = zones[z];
                match = true;
                for (key in search) {
                    regex = false;
                    target = search[key];
                    if (target[0] === '~') {
                        target = new RegExp(target.substr(1), 'i');
                        regex = true;
                    }
                    if (regex && !z[key].match(target)) {
                        match = false;
                    } else if (!regex && (z[key] !== search[key])) {
                        match = false;
                    }
                }
                if (match && z.uuid) {
                    results.push(z.uuid);
                }
            }
            if (!options.full) {
                return callback(null, results);
            } else {
                // need to expand these
                function expander(uuid, cb)
                {
                    VM.load(uuid, function (err, obj) {
                        if (err) {
                            return cb(err);
                        }
                        if (transform) {
                            transform(obj);
                        }
                        full_results.push(obj);
                        return cb();
                    });
                }

                // create all the volumes we found that we need.
                async.forEach(results, expander, function (err) {
                    if (err) {
                        VM.logger('ERROR', 'VM.lookup failed to ' +
                            'expand results', err);
                        callback(err);
                    }
                    return callback(null, full_results);
                });
            }
        });
    } else {
        // have to search the hard way
        forEach(
            function (zonename, cb)
            {
                VM.load(zonename, function (error, obj) {
                    if (error) {
                        return cb(error);
                    }
                    if (transform) {
                        transform(obj);
                    }
                    if (matcher(obj, search)) {
                        results.push(obj);
                    }
                    return cb();
                });
            },
            function(err)
            {
                var short_results = [];
                if (err) {
                    return callback(err);
                }
                if (options.full) {
                    return callback(null, results);
                } else {
                    for (r in results) {
                        short_results.push(results[r].uuid);
                    }
                    return callback(null, short_results);
                }
            }
        );
    }
};

// create a random new locally administered MAC address
function generateMAC()
{
    var data;
    var result;

    // time in milliseconds + 3 random digits
    data = ((Date.now() * 1000) +
        (Math.floor(Math.random()*1000) % 1000)).toString(16);

    // split to correct number of characters
    data = data.substr(data.length - 12)

    // set the 'locally administered' bit and don't set the multicast bit.
    // locally administered MAC addresses, won't conflict with OUIs
    data = data.substr(0, 1) + '2' + data.substr(2);

    // turn into MAC format
    result = data.match(/../g).join(':');

    VM.logger('DEBUG', 'Generated new MAC address: ' + result);

    return result;
}

// Ensure we've got all the datasets necessary to create this VM
//
// IMPORTANT:
//
// On SmartOS, we assume a provisioner or some other external entity has already
// loaded the dataset into the system. This function just confirms that the
// dataset actually exists.
//
function checkDatasets(payload, callback)
{
    var checkme = [];
    var d;
    var disk;

    VM.logger('DEBUG', 'Checking for required datasets.');

    // build list of datasets we need to download (downloadme)
    for (disk in payload.disks) {
        if (payload.disks.hasOwnProperty(disk)) {
            d = payload.disks[disk];
            if (d.hasOwnProperty('image_uuid')) {
                checkme.push(payload.zfs_storage_pool_name + '/' + d.image_uuid);
            }
        }
    }

    function checker(dataset, cb)
    {
        zfs(['list', '-o', 'name', '-H', dataset], function (err, fds) {
            if (err) {
                VM.logger('ERROR', 'zfs list ' + dataset + ' exited with' +
                    ' code: ' + err.code + ' stdout: "' + fds.stdout +
                    '" stderr:"' + fds.stderr + '"', err);
                return cb(new Error('unable to find dataset: ' + dataset));
            } else {
                return cb();
            }
        });
    }

    // check that we have all the volumes
    async.forEach(checkme, checker, function (err) {
        if (err) {
            VM.logger('ERROR', 'checkDatasets() failed to find required ' +
                'volumes', err);
            return callback(err);
        }
        // progress(100, 'we have all necessary datasets');
        callback();
    });
}

function lookupConflicts(macs, ips, callback) {
    var match;
    var conflict = false;

    VM.logger('DEBUG', 'checking for conflicts with ' +
        JSON.stringify(macs) + ' and ' + JSON.stringify(ips));

    forEach(function (zonename, cb) {
        VM.load(zonename, function (error, obj) {
            if (error) {
                return cb(error);
            }
            for (ip in ips) {
                if (matcher(obj, {'nic.ip': ips[ip]})) {
                    VM.logger('ERROR', 'Found conflict: ' + obj.uuid +
                        ' already has IP ' + ips[ip]);
                    conflict = true;
                }
            }
            for (mac in macs) {
                if (matcher(obj, {'nic.mac': macs[mac]})) {
                    VM.logger('ERROR', 'Found conflict: ' + obj.uuid +
                        ' already has MAC ' + macs[mac]);
                    conflict = true;
                }
            }
            return cb();
        });
    }, function (err) {
        if (err) {
            return callback(err);
        }
        return callback(null, conflict);
    });
};

// create a new zvol for a VM
function createVolume(volume, callback)
{
    var size;

    VM.logger('DEBUG', 'creating volume ' + JSON.stringify(volume));

    if (volume.hasOwnProperty('image_size')) {
        size = volume.image_size;
    } else if (volume.hasOwnProperty('size')) {
        size = volume.size;
    } else {
        return callback('FATAL: createVolume(' + JSON.stringify(volume) + '): '
            + 'has no size or image_size');
    }

    async.series([
        function (cb)
        {
            var args;
            var snapshot;
            var target;
            var trace_cmd;

            target = volume.zpool + '/' + volume.uuid;
            if (volume.hasOwnProperty('image_uuid')) {
                // This volume is from a template/dataset/image so we create
                // it as a clone of a snapshot of the original.
                snapshot = volume.zpool + '/' + volume.image_uuid +
                    '@' + volume.uuid;

                zfs(['snapshot', snapshot], function (err, fds) {
                    if (err) {
                        return cb(err);
                    }
                    zfs(['clone', snapshot, target], function (err, fds) {
                        if (err) {
                            return cb(err);
                        }
                        volume.path = '/dev/zvol/rdsk/' + target;
                        return cb();
                    });
                });
            } else {
                // This volume is not from a template/dataset/image so we create
                // a blank new zvol for it.
                args = ['create', '-o', 'refreservation=none', '-V', size + 'M',
                    target];

                zfs(args, function (err, fds) {
                    if (err) {
                        return cb(err);
                    }
                    volume.path = '/dev/zvol/rdsk/' + target;
                    return cb();
                });
            }
        }
    ],
    function (err, results)
    {
        return callback(err);
    });
}

// Create all the volumes for a given VM property set
function createVolumes(payload, callback)
{
    var createme = [];
    var d, disk, disk_idx;

    VM.logger('DEBUG', 'creating volumes: ' + JSON.stringify(payload.disks));

    // generate list of volumes we need to create
    disk_idx = 0;
    for (disk in payload.disks) {
        if (payload.disks.hasOwnProperty(disk)) {
            d = payload.disks[disk];
            d.index = disk_idx
            d.uuid = payload.uuid + '-disk' + disk_idx;
            if (!d.hasOwnProperty('zpool')) {
                d.zpool = payload.zfs_storage_pool_name;
            }
            createme.push(d);
            disk_idx ++;
        }
    }

    // create all the volumes we found that we need.
    async.forEach(createme, createVolume, function (err) {
        if (err) {
            callback(err);
        } else {
            callback();
        }
    });
}

// writes a Zone's metadata JSON to /zones/<uuid>/config/metadata.json
// and /zones/<uuid>/config/tags.json.
function updateMetadata(vmobj, payload, callback)
{
    var zonepath = vmobj.zone_path = '/' +
        vmobj.zfs_storage_pool_name + '/' +
        vmobj.zonename;
    var mdata_filename = zonepath + '/config/metadata.json';
    var tags_filename = zonepath + '/config/tags.json';
    var key, mdata = {}, tags = {};

    for (key in vmobj.customer_metadata) {
        if (vmobj.customer_metadata.hasOwnProperty(key)) {
            mdata[key] = vmobj.customer_metadata[key];
            if (payload.hasOwnProperty('remove_customer_metadata') &&
                payload.remove_customer_metadata.indexOf(key) !== -1) {

                // in the remove_* list, don't load it.
                delete mdata[key];
            }
            if (payload.hasOwnProperty('update_customer_metadata') &&
                payload.update_customer_metadata.hasOwnProperty(key)) {

                // in the update_* list, replace with that value.
                mdata[key] = payload.update_customer_metadata[key];
            }
        }
    }

    for (key in payload.add_customer_metadata) {
        if (payload.add_customer_metadata.hasOwnProperty(key)) {
            mdata[key] = payload.add_customer_metadata[key];
        }
    }

    // same thing for tags
    for (key in vmobj.tags) {
        if (vmobj.tags.hasOwnProperty(key)) {
            tags[key] = vmobj.tags[key];
            if (payload.hasOwnProperty('remove_tags') &&
                payload.remove_tags.indexOf(key) !== -1) {

                // in the remove_* list, don't load it.
                delete tags[key];
            }
            if (payload.hasOwnProperty('update_tags') &&
                payload.update_tags.hasOwnProperty(key)) {

                // in the update_* list, replace with that value.
                tags[key] = payload.update_tags[key];
            }
        }
    }

    for (key in payload.add_tags) {
        if (payload.add_tags.hasOwnProperty(key)) {
            tags[key] = payload.add_tags[key];
        }
    }

    mdata = {"customer_metadata": mdata};
    fs.writeFile(mdata_filename, JSON.stringify(mdata, null, 2),
        function (err)
        {
            if (err) {
                return callback(err);
            }
            VM.logger('DEBUG', 'wrote metadata to ' + mdata_filename);
            fs.writeFile(tags_filename, JSON.stringify(tags, null, 2),
                function (err) {
                    if (err) {
                        return callback(err);
                    }
                    VM.logger('DEBUG', 'wrote tags to' + tags_filename);
                    callback();
                }
            );
        }
    );
}

function saveMetadata(payload, callback)
{
    var protovm = {};

    if (!payload.hasOwnProperty('zone_path') ||
        !payload.hasOwnProperty('zfs_storage_pool_name') ||
        !payload.hasOwnProperty('zonename')) {

        return callback(new Error('saveMetadata payload is missing zone ' +
            'properties.'));
    }

    protovm.zone_path = payload.zone_path;
    protovm.zfs_storage_pool_name = payload.zfs_storage_pool_name;
    protovm.zonename = payload.zonename;
    protovm.customer_metadata = {};
    protovm.tags = {};

    if (payload.hasOwnProperty('tags')) {
        payload.add_tags = payload.tags;
        delete payload.tags;
    }
    if (payload.hasOwnProperty('customer_metadata')) {
        payload.add_customer_metadata = payload.customer_metadata;
        delete payload.customer_metadata;
    }

    return updateMetadata(protovm, payload, callback);
}

function createVM(payload, callback)
{
    var d, disk;

    async.series([
        function (cb)
        {
            // progress(2, 'checking required datasets');
            checkDatasets(payload, cb);
        },
        function (cb)
        {
            // progress(29, 'creating volumes');
            createVolumes(payload, cb);
        },
        function (cb)
        {
            // progress(51, 'creating zone container');
            createZone(payload, cb);
        }
    ],
    function (err, results)
    {
        if (err) {
            callback(err);
        } else {
            callback(null, results);
        }
        return callback();
    });
}

// XXX do we still need this?
function writeZoneconfig(payload, callback)
{
    var data;

    if (!payload.hasOwnProperty('hostname')) {
        payload.hostname = payload.zonename;
    }

    data = 'TEMPLATE_VERSION=0.0.1\n' +
        'ZONENAME=' + payload.zonename + '\n' +
        'HOSTNAME=' + payload.hostname + '.' + payload.dns_domain + '\n' +
        'TMPFS=' + payload.tmpfs + 'm\n';

    if (payload.add_nics[0] && payload.add_nics[0].ip != 'dhcp') {
        data = data + 'PUBLIC_IP=' + payload.add_nics[0].ip + '\n';
    }
    if (payload.add_nics[1] && payload.add_nics[1].ip != 'dhcp') {
        data = data + 'PRIVATE_IP=' + payload.add_nics[1].ip + '\n';
    } else if (payload.add_nics[0] && payload.add_nics[0].ip != 'dhcp') {
        // zoneinit uses private_ip for /etc/hosts, we want to
        // make that same as public, if there's no actual private.
        data = data + 'PRIVATE_IP=' + payload.add_nics[0].ip + '\n';
    }

    if (payload.hasOwnProperty('resolvers')) {
        // zoneinit appends to resolv.conf rather than overwriting, so just
        // add to the zoneconfig and let zoneinit handle it
        data = data + 'RESOLVERS="' + payload.resolvers.join(' ') + '"\n';
    }

    nic_idx = 0;
    primary_found = false;
    for (nic in payload.add_nics) {
        if (payload.add_nics.hasOwnProperty(nic)) {
            n = payload.add_nics[nic];
            data = data + 'NET' + nic_idx + '_MAC=' + n.mac + '\n'
                        + 'NET' + nic_idx + '_INTERFACE=NET' + nic_idx + '\n';

            if (n.ip != 'dhcp') {
                fs.writeFileSync(payload.zone_path + '/root/etc/hostname.net' +
                    nic_idx, n.ip + ' netmask ' + n.netmask + ' up' + '\n');
                data = data + 'NET' + nic_idx + '_IP=' + n.ip + '\n'
                            + 'NET' + nic_idx + '_NETMASK=' + n.netmask + '\n';
            }

            if (n.hasOwnProperty('primary') && !primary_found) {
                // only allow one primary network
                primary_found = true;
                if (n.hasOwnProperty('gateway')) {
                    fs.writeFileSync(payload.zone_path + '/root/etc/defaultrouter',
                        n.gateway + '\n');
                }
                if (n.ip == 'dhcp') {
                    fs.writeFileSync(payload.zone_path + '/root/etc/dhcp.net' +
                        nic_idx, '');
                }
            }

            nic_idx++;
        }
    }

    VM.logger('DEBUG', 'writing extra files to zone root');
    fs.writeFileSync(payload.zone_path + '/root/etc/nodename',
        payload.hostname);
    fs.writeFileSync(payload.zone_path +
        '/root/var/svc/log/system-zoneinit:default.log', '');

    VM.logger('DEBUG', 'writing ' + JSON.stringify(data) + ' to /' +
        payload.zfs_storage_pool_name + '/' + payload.zonename);

    fs.writeFile('/' + payload.zfs_storage_pool_name + '/' + payload.zonename +
        '/root/root/zoneconfig', data,
        function (err, result) {
            if (err) {
                return callback(err);
            }
            return callback();
        }
    );
}

function zonecfg(args, callback)
{
    var cmd = '/usr/sbin/zonecfg';

    VM.logger('DEBUG', cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            // TODO log here.
            return callback(error, {'stdout': stdout, 'stderr': stderr});
        }
        return callback(null, {'stdout': stdout, 'stderr': stderr});
    });
}

function zonecfgFile(data, args, callback)
{
    var tmpfile = '/tmp/zonecfg.' + process.pid + '.tmp';

    fs.writeFile(tmpfile, data, function (err, result) {
        if (err) {
            // On failure we don't delete the tmpfile so we can debug it.
            return callback(err);
        }
        args.push('-f');
        args.push(tmpfile);

        zonecfg(args, function (err, fds) {
            if (err) {
                // keep temp file around for investigation
                return callback(err, fds);
            }
            fs.unlink(tmpfile, function () {
                return callback(null, fds);
            });
        });
    });
}

function zoneadm(args, callback)
{
    var cmd = '/usr/sbin/zoneadm';

    VM.logger('DEBUG', cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            return callback(error, {'stdout': stdout, 'stderr': stderr});
        }
        return callback(null, {'stdout': stdout, 'stderr': stderr});
    });
}

function zfs(args, callback)
{
    var cmd = '/usr/sbin/zfs';

    VM.logger('DEBUG', cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            return callback(error, {'stdout': stdout, 'stderr': stderr});
        }
        return callback(null, {'stdout': stdout, 'stderr': stderr});
    });
}

// Call the callback when joyent zone has rebooted.
function waitForJoyentZone(payload, callback)
{
    var chunks;
    var buffer = '';
    var watcher;
    var timeout;
    var timeout_secs = 5 * 60;
    var state = 'running';

    watcher = spawn('/usr/sbin/zonemon', ['-z', payload.zonename],
        {'customFds': [-1, -1, -1]});

    VM.logger('DEBUG', 'zonemon running with pid ' + watcher.pid +
        ' waiting for zoneinit to reboot zone');

    timeout = setTimeout(function () {
        timeout = null;
        watcher.kill();
        watcher = null;
        callback('Timed out waiting for zone to reboot');
    }, timeout_secs * 1000);

    watcher.stdout.on('data', function (data) {
        var chunk;
        var new_state;

        buffer += data.toString();
        chunks = buffer.split('\n');
        while (chunks.length > 1) {
            chunk = chunks.shift().replace(/^\s+/g, '');
            new_state = chunk.split(' ')[0];

            VM.logger('DEBUG', 'zonemon saw state change: ' + chunk);

            if (new_state !== 'running') {
                state = new_state;
            } else {
                // State went from not running to running, we're back up
                if (state != 'running') {
                    clearTimeout(timeout);
                    watcher.kill();
                    callback();
                }
                state = 'running';
            }
        }
        buffer = chunks.pop();
    });

    watcher.on('exit', function (code) {
        // Shouldn't get here. We should callback when zonemon notices reboot.
        if (timeout) {
            // didn't timeout yet.
            clearTimeout(timeout);
            watcher = null;
            callback('zonemon exited prematurely with code: ' + code);
        }
       watcher.stdin.end();
    });
}

function failZone(zonename, callback)
{
    zonecfg(['-z', zonename, 'set autoboot=false'],
        function (err, fds) {
            if (err) {
                VM.log('DEBUG', 'failZone(' + zonename +
                    ') failed to set autoboot, ignoring [' +
                    JSON.stringify(err) + '][' +
                    JSON.stringify(fds.stdout) + '][' +
                    JSON.stringify(fds.stderr) + ']');
            }
            zoneadm(['-z', zonename, 'halt', '-X'],
                function (err, fds) {
                    if (err) {
                        VM.log('DEBUG', 'failZone(' + zonename +
                            ') failed to stop, ignoring [' +
                            JSON.stringify(err) + '][' +
                            JSON.stringify(fds.stdout) + '][' +
                            JSON.stringify(fds.stderr) + ']');
                    }
                    callback();
                }
            );
        }
    );
}

// generate a new UUID if payload doesn't have one (also ensures that this uuid
// does not already belong to a zone).
function createZoneUUID(payload, callback)
{
    var uuid;

    if (payload.hasOwnProperty('uuid')) {
        VM.load(payload.uuid, function (err, obj) {
            if (!err) {
                return callback(new Error('vm with UUID ' + payload.uuid +
                    'already exists.'));
            } else {
                VM.logger('ERROR', 'createZoneUUID() error loading ' +
                    'vm ' + payload.uuid);
            }
            if (!payload.hasOwnProperty('zonename')) {
                payload.zonename = payload.uuid;
            }
            return callback(null, payload.uuid);
        });
    } else {
        VM.logger('DEBUG', '/usr/bin/uuid -v 4');
        execFile('/usr/bin/uuid', ['-v', '4'], function (err, stdout, stderr) {
            if (err) {
                return callback(err);
            }

            // chomp trailing spaces and newlines
            uuid = stdout.toString().replace(/\s+$/g, '');
            payload.uuid = uuid
            VM.logger('INFO', 'createZoneUUID() generated uuid ' + uuid);
            VM.load(payload.uuid, function (err, obj) {
                if (!err) {
                    return callback(new Error('Zone with UUID ' + payload.uuid +
                        'already exists!'));
                }
                if (!payload.hasOwnProperty('zonename')) {
                    payload.zonename = payload.uuid;
                }
                return callback(null, uuid);
            });
        });
    }
}

function applyZoneDefaults(payload)
{
    var nic, n, disk, zvol;

    VM.logger('DEBUG', 'applying zone defaults');

    if (!payload.hasOwnProperty('owner_uuid')) {
        // We assume that this all-zero uuid can be treated as 'admin'
        payload.owner_uuid = '00000000-0000-0000-0000-000000000000';
    }

    if (!payload.hasOwnProperty('autoboot')) {
        payload.autoboot = 'true';
    }

    if (!payload.hasOwnProperty('brand')) {
        payload.brand = 'joyent';
    }

    if (!payload.hasOwnProperty('zfs_storage_pool_name')) {
        payload.zfs_storage_pool_name = 'zones';
    }

    if (!payload.hasOwnProperty('dns_domain')) {
        payload.dns_domain = 'local';
    }

    if (!payload.hasOwnProperty('cpu_shares')) {
        payload.cpu_shares = 100;
    } else {
        if (payload.cpu_shares > 65535) {
            VM.logger('INFO', 'capping cpu_shares at 64k (was: ' +
                payload.cpu_shares + ')');
            payload.cpu_shares = 65535; // max is 64K
        }
    }

    if (!payload.hasOwnProperty('zfs_io_priority')) {
        payload.zfs_io_priority = 100;
    }

    if (!payload.hasOwnProperty('max_lwps')) {
        payload.max_lwps = 2000;
    }

    // We need to set the RAM here because we use it as the default for
    // the max_physical_memory below.
    if (payload.brand === 'kvm' && !payload.hasOwnProperty('ram')) {
        payload.ram = 256;
    }

    // NOTE: We add 1024 to memory limits for 'kvm' brand zones below.
    if (!payload.hasOwnProperty('max_physical_memory')) {
        if (payload.brand === 'kvm') {
            payload.max_physical_memory = payload.ram;
        } else {
            payload.max_physical_memory = 256; // in MiB
        }
    }

    if (!payload.hasOwnProperty('max_locked_memory')) {
        payload.max_locked_memory = payload.max_physical_memory;
    }

    if (!payload.hasOwnProperty('max_swap')) {
        payload.max_swap = payload.max_physical_memory;
    }

    if (payload.brand === 'kvm') {
        // For now we add 1G to the memory caps for KVM zones, this overhead
        // is for the qemu process itself.  Since customers don't have direct
        // access to zone memory, this exists mostly to protect against bugs.
        payload.max_physical_memory = payload.max_physical_memory + 1024;
        payload.max_locked_memory = payload.max_locked_memory + 1024;
        payload.max_swap = payload.max_swap + 1024;

        if (!payload.hasOwnProperty('vcpus')) {
            payload.vcpus = 1;
        }
    } else if (payload.brand === 'joyent') {
        if (!payload.hasOwnProperty('tmpfs')) {
            payload.tmpfs = 256;
        }
        if (!payload.hasOwnProperty('delegate_dataset')) {
            payload.delegate_dataset = false;
        } else {
            // ensure boolean
            payload.delegate_dataset = !!payload.delegate_dataset;
        }
    }

    if (!payload.hasOwnProperty('limit_priv')) {
        // note: the limit privs are going to be added to the brand and
        // shouldn't need to be set here by default when that's done.
        payload.limit_priv = 'default,dtrace_proc,dtrace_user';
    }

    if (!payload.hasOwnProperty('quota')) {
        payload.quota = '10'; // in GiB
    }

    if (!payload.hasOwnProperty('billing_id')) {
        if (payload.hasOwnProperty('dataset_uuid')) {
            payload.billing_id = payload.dataset_uuid;
        } else {
            payload.billing_id = '00000000-0000-0000-0000-000000000000';
        }
    }

    for (disk in payload.disks) {
        if (payload.disks.hasOwnProperty(disk)) {
            zvol = payload.disks[disk];
            if (!zvol.hasOwnProperty('model') &&
                payload.hasOwnProperty('disk_driver')) {

                zvol.model = payload.disk_driver;
            }
        }
    }

    for (nic in payload.nics) {
        if (payload.nics.hasOwnProperty(nic)) {
            n = payload.nics[nic];
            if (!n.hasOwnProperty('model') &&
                payload.hasOwnProperty('nic_driver')) {

                n.model = payload.nic_driver;
            }
        }
    }

    return;
}

function checkProperties(payload, callback)
{
    var disk, zvol, nic, n, macs = [], ips = [];

    if (payload.brand === 'kvm' && payload.hasOwnProperty('available_MiB')) {
        if (payload.available_MiB < payload.ram) {
            return callback("VM 'ram' value: " + payload.ram + ' is less than' +
                ' available memory: ' + payload.available_MiB);
        } else {
            VM.logger('DEBUG', 'checkProperties() memory ok: ' +
                payload.ram + ' requested and have: ' + payload.available_MiB);
        }
    }

    if (payload.max_locked_memory > payload.max_physical_memory) {
        return callback('max_locked_memory must be <= max_physical_memory');
    }
    if (payload.max_swap < payload.max_physical_memory) {
        return callback('max_swap must be >= max_physical_memory');
    }

    for (disk in payload.disks) {
        if (payload.disks.hasOwnProperty(disk)) {
            zvol = payload.disks[disk];

            if (payload.brand === 'kvm' && (!zvol.hasOwnProperty('model') ||
                zvol.model === 'undefined')) {

                return callback('missing .model option for disk: ' +
                    JSON.stringify(zvol));
            }
        }
    }

    for (nic in payload.nics) {
        if (payload.nics.hasOwnProperty(nic)) {
            n = payload.nics[nic];

            if (n.hasOwnProperty('mac')) {
                macs.push(n.mac);
            }

            if (n.hasOwnProperty('ip')) {
                ips.push(n.ip);
            }

            if (payload.brand === 'kvm' && (!n.hasOwnProperty('model') ||
                n.model === 'undefined')) {

                return callback('missing .model option for NIC: ' +
                    JSON.stringify(n));
            }
        }
    }

    // Ensure MACs and IPs are not already used on this vm
    // NOTE: can't check other nodes yet.

    lookupConflicts(macs, ips, function (error, conflict) {
        if (error) {
            return callback(error);
        }

        if (conflict) {
            return callback(new Error('Conflict detected with another ' +
                'vm, please check the MAC and IP'));
        }

        return callback();
    });
}

function addDelegatedDataset(payload, callback)
{
    var dataset;

    if (payload.delegate_dataset) {
        dataset = payload.zone_path.substr(1) + '/data';
        VM.logger('DEBUG', 'adding delegated dataset ' + dataset + 'to ' +
            'vm ' + payload.uuid);

        zfs(['create', '-o', 'compression=on', dataset], function (err, fds) {
            if (err) {
                return callback(err);
            }

            return callback();
        });
    } else {
        return callback();
    }
}

function buildAddRemoveList(vmobj, payload, type, key, updatable)
{
    var newobj, oldobj;
    var remove = [], add = [];
    var plural = type + 's';
    var add_key = 'add_' + plural;
    var update_key = 'update_' + plural;
    var remove_key = 'remove_' + plural;

    // There's no way to update properties on a disk or nic with zonecfg
    // currently.  Yes, really.  So any disks/nics that should be updated, we
    // remove then add with the new properties.
    if (payload.hasOwnProperty(update_key)) {
        for (newobj in payload[update_key]) {
            newobj = payload[update_key][newobj];
            for (oldobj in vmobj[plural]) {
                oldobj = vmobj[plural][oldobj];

                if (oldobj[key] === newobj[key]) {
                    // This is the one to update: remove and add.
                    remove.push(oldobj[key]);

                    // only some fields make sense to update.
                    for (field in updatable) {
                        field = updatable[field];
                        if (newobj.hasOwnProperty(field)) {
                            oldobj[field] = newobj[field];
                        }
                    }

                    add.push(oldobj);
                }
            }
        }
    }

    if (payload.hasOwnProperty(remove_key)) {
        for (newobj in payload[remove_key]) {
            newobj = payload[remove_key][newobj];
            remove.push(newobj);
        }
    }

    if (payload.hasOwnProperty(add_key)) {
        for (newobj in payload[add_key]) {
            newobj = payload[add_key][newobj];
            add.push(newobj);
        }
    }

    return ({"add": add, "remove": remove});
}

function buildDiskZonecfg(vmobj, payload)
{
    var zcfg = '';
    var idx, disk_idx = 0;
    var disk;
    var lists;
    var remove = [], add = [];

    lists = buildAddRemoveList(vmobj, payload, 'disk', 'path', UPDATABLE_DISK_PROPS);
    remove = lists.remove;
    add = lists.add;

    // we've now built the add and remove lists, so figure out what index to
    // start at for disks wiwth no index.
    for (disk in add) {
        disk = add[disk];
        if (disk.hasOwnProperty('index') && disk.index > disk_idx) {
            disk_idx = disk.index + 1;
        }
    }

    // remove is a list of disk paths, add a remove for each now.
    for (disk in remove) {
        disk = remove[disk];
        zcfg = zcfg + 'remove device match=' + disk + '\n';
    }

    for (disk in add) {
        disk = add[disk];

        if (disk.hasOwnProperty('index')) {
            idx = disk.index;
        } else {
            idx = disk_idx;
            disk_idx++;
        }

        zcfg = zcfg + 'add device\n' +
            'set match=' + disk.path + '\n' +
            'add property (name=index, value="' + idx + '")\n' +
            'add property (name=boot, value="' +
                (disk.boot ? 'true' : 'false') + '")\n' +
            'add property (name=model, value="' + disk.model + '")\n';
        if (disk.hasOwnProperty('image_size')) {
            zcfg = zcfg +
                'add property (name=image-size, value="' +
                disk.image_size + '")\n';
        } else if (disk.hasOwnProperty('size')) {
            zcfg = zcfg + 'add property (name=size, value="' +
                disk.size + '")\n';
        }

        if (disk.hasOwnProperty('image_uuid')) {
            zcfg = zcfg +
                'add property (name=image-uuid, value="' +
                disk.image_uuid + '")\n';
        }

        if (disk.hasOwnProperty('image_name')) {
            zcfg = zcfg + 'add property (name=image-name, value="' +
                    disk.image_name + '")\n';
        }

        zcfg = zcfg + 'end\n';
    }

    return zcfg;
}

function buildNicZonecfg(vmobj, payload)
{
    var zcfg = '';
    var nic;
    var lists;
    var remove, add;
    var idx, nic_idx = 0;

    lists = buildAddRemoveList(vmobj, payload, 'nic', 'mac', UPDATABLE_NIC_PROPS);
    remove = lists.remove;
    add = lists.add;

    // we've now built the add and remove lists, so figure out what index to
    // start at for disks wiwth no index.
    for (nic in add) {
        nic = add[nic];
        if (nic.hasOwnProperty('index') && nic.index > nic_idx) {
            nic_idx = nic.index + 1;
        }
    }

    // remove is a list of nic macs, add a remove for each now.
    for (nic in remove) {
        nic = remove[nic];
        zcfg = zcfg + 'remove net mac-addr=' + nic + '\n';
    }

    for (nic in add) {
        nic = add[nic];

        if (nic.hasOwnProperty('index')) {
            idx = nic.index;
        } else {
            idx = nic_idx;
            nic_idx++;
        }

        zcfg = zcfg +
            'add net\n' +
            'set physical=net' + idx + '\n' +
            'set global-nic=' + nic.nic_tag + '\n' +
            'set mac-addr=' + nic.mac + '\n' +
            'add property (name=index, value="' + idx + '")\n' +
            'add property (name=ip, value="' + nic.ip + '")\n';

        if (nic.hasOwnProperty('netmask')) {
            zcfg = zcfg + 'add property (name=netmask, value="' +
                nic.netmask + '")\n';
        }

        if (nic.hasOwnProperty('gateway') && nic.gateway.length > 0) {
            zcfg = zcfg + 'add property (name=gateway, value="' +
                nic.gateway + '")\n';
        }

        if (nic.hasOwnProperty('model')) {
            zcfg = zcfg + 'add property (name=model, value="' +
                nic.model + '")\n';
        }

        if (nic.hasOwnProperty('primary')) {
            zcfg = zcfg + 'add property (name=primary, value="' +
                nic.primary + '")\n';
        }

        if (nic.hasOwnProperty('vlan_id') && (nic.vlan_id !== "0")) {
            zcfg = zcfg + 'set vlan-id=' + nic.vlan_id + '\n';
        }

        if (nic.hasOwnProperty('blocked_outgoing_ports')) {
            zcfg = zcfg +
                'add property (name=blocked-outgoing-ports, value="' +
                nic.blocked_outgoing_ports.join(',') + '")\n';
        }

        zcfg = zcfg + 'end\n';
    }

    return zcfg;
}

function buildZonecfgUpdate(vmobj, payload)
{
    var zcfg = '';

    // Global properties can just be set, no need to clear anything first.
    if (payload.hasOwnProperty('cpu_shares')) {
        zcfg = zcfg + 'set cpu-shares=' + payload.cpu_shares.toString() + '\n';
    }
    if (payload.hasOwnProperty('zfs_io_priority')) {
        zcfg = zcfg + 'set zfs-io-priority=' +
            payload.zfs_io_priority.toString() + '\n';
    }
    if (payload.hasOwnProperty('max_lwps')) {
        zcfg = zcfg + 'set max-lwps=' + payload.max_lwps.toString() + '\n';
    }
    if (payload.hasOwnProperty('limit_priv')) {
        zcfg = zcfg + 'set limitpriv="' + payload.limit_priv + '"\n';
    }
    if (payload.hasOwnProperty('autoboot') && payload.brand === 'joyent') {
        // kvm autoboot is managed by the vm-autoboot attr instead
        zcfg = zcfg + 'set autoboot=' + payload.autoboot + '\n';
    }

    // Capped Memory properties are special
    if (payload.hasOwnProperty('max_physical_memory') ||
        payload.hasOwnProperty('max_locked_memory') ||
        payload.hasOwnProperty('max_swap')) {

        // Capped memory parameters need either an add or select first.
        if (vmobj.hasOwnProperty('max_physical_memory') ||
            vmobj.hasOwnProperty('max_locked_memory') ||
            vmobj.hasOwnProperty('max_swap')) {

            // there's already a capped-memory section, use that.
            zcfg = zcfg + 'select capped-memory; ';
        } else {
            zcfg = zcfg + 'add capped-memory; ';
        }

        if (payload.hasOwnProperty('max_physical_memory')) {
            zcfg = zcfg + 'set physical=' +
                payload.max_physical_memory.toString() + 'm; ';
        }
        if (payload.hasOwnProperty('max_locked_memory')) {
            zcfg = zcfg + 'set locked=' +
                payload.max_locked_memory.toString() + 'm; ';
        }
        if (payload.hasOwnProperty('max_swap')) {
            zcfg = zcfg + 'set swap=' +
                payload.max_swap.toString() + 'm; ';
        }

        zcfg = zcfg + 'end\n';
    }

    // Capped CPU is special
    if (payload.hasOwnProperty('cpu_cap')) {
        if (vmobj.hasOwnProperty('cpu_cap')) {
            zcfg = zcfg + 'select capped-cpu; ';
        } else {
            zcfg = zcfg + 'add capped-cpu; ';
        }

        zcfg = zcfg + 'set ncpus=' +
            (Number(payload.cpu_cap) * 0.01).toString() + '; end\n';
    }

    // Attributes
    function setAttr(attr, attr_name, value)
    {
        if (!value) {
            value = payload[attr_name];
        }

        if (payload.hasOwnProperty(attr_name)) {
            if (vmobj.hasOwnProperty(attr_name)) {
                zcfg = zcfg + 'select attr name=' + attr + '; ';
            } else {
                zcfg = zcfg + 'add attr; set name="' + attr + '"; ' +
                    'set type=string; ';
            }
            zcfg = zcfg + 'set value="' + value.toString() + '"; end\n';
        }
    }
    setAttr('billing-id', 'billing_id');
    setAttr('owner-uuid', 'owner_uuid');
    setAttr('package-name', 'package_name');
    setAttr('package-version', 'package_version');
    setAttr('tmpfs', 'tmpfs');
    setAttr('hostname', 'hostname');
    setAttr('dns-domain', 'dns_domain');
    setAttr('default-gateway', 'default_gateway');

    if (payload.hasOwnProperty('resolvers')) {
        setAttr('resolvers', 'resolvers', payload.resolvers.join(','));
    }
    if (payload.hasOwnProperty('alias')) {
        setAttr('alias', 'alias', new Buffer(payload.alias).toString('base64'));
    }

    // KVM specific attrs
    if (vmobj.brand === 'kvm' || payload.brand === 'kvm') {
        setAttr('vm-autoboot', 'autoboot');
        setAttr('ram', 'ram');
        setAttr('vcpus', 'vcpus');
        setAttr('boot', 'boot');
        setAttr('cpu-type', 'cpu_type');

        // we use base64 here for these next two options, since these can
        // contain characters zonecfg doesn't like.
        if (payload.hasOwnProperty('qemu_opts')) {
            setAttr('qemu-opts', 'qemu_opts',
                new Buffer(payload.qemu_opts).toString('base64'));
        }
        if (payload.hasOwnProperty('qemu_extra_opts')) {
            setAttr('qemu-extra-opts', 'qemu_extra_opts',
                new Buffer(payload.qemu_extra_opts).toString('base64'));
        }

        // Handle disks (VMs only)
        zcfg = zcfg + buildDiskZonecfg(vmobj, payload);
    }

    zcfg = zcfg + buildNicZonecfg(vmobj, payload);

    return zcfg;
}

// create and install a 'joyent' or 'kvm' brand zone.
function createZone(payload, callback)
{
    var zcfg;
    var zone_path;
    var now = new Date;

    if (payload.brand === 'joyent' && !payload.hasOwnProperty('dataset_uuid')) {
        return callback('createZone(): FAILED -- dataset_uuid is required.');
    }

    payload.zone_path = '/' + payload.zfs_storage_pool_name + '/' + payload.zonename;

    // set the properties that can't be updated later here.
    zcfg = 'create -b\n' +
        'set zonepath=' + payload.zone_path + '\n' +
        'set brand=' + payload.brand + '\n' +
        'set ip-type=exclusive\n' +
        'add attr; set name="create-timestamp"; set type=string; set value="' +
            now.toISOString() + '"; end\n';

    if (payload.brand === 'kvm') {
        // we always set autoboot=false for VM zones, since we want vmadmd to
        // boot them and not the zones tools.  Use vm-autoboot to control VMs
        zcfg = zcfg + 'set autoboot=false\n';
    }

    // move disk and NIC properties to add_* so they get added.
    if (payload.hasOwnProperty('disks')) {
        payload.add_disks = payload.disks;
        delete payload.disks;
    }
    if (payload.hasOwnProperty('nics')) {
        payload.add_nics = payload.nics;
        delete payload.nics;
    }

    // Passing an empty first parameter here, tells buildZonecfgUpdate that
    // we're talking about a new machine.
    zcfg = zcfg + buildZonecfgUpdate({}, payload);

    async.series([
        function (cb) {
            // send the zonecfg data we just generated as a file to zonecfg,
            // this will create the zone.
            zonecfgFile(zcfg, ['-z', payload.zonename], function (err, fds) {
                cb(err);
            });
        }, function (cb) {
            // Install the zone.  This will create the dataset and mark the zone
            // 'installed'.
            var args = ['-z', payload.zonename, 'install', '-q',
                payload.quota.toString(), '-U', payload.uuid];

            if (payload.brand === 'joyent') {
                args.push('-t');
                args.push(payload.dataset_uuid);
                args.push('-x');
                args.push('nodataset');
            }

            zoneadm(args, function (err, fds) {
                if (err) {
                    return cb({
                        'failure': 'zoneadm failed to install',
                        'error': error,
                        'stdout': fds.stdout,
                        'stderr': fds.stderr
                    });
                }
                return cb();
            });
        }, function (cb) {
            // Write out the zone's metadata
            saveMetadata(payload, function (err) {
                if (err) {
                    output('failure', 'unable to save metadata',
                        {'error': err});
                    return cb(err);
                }
                return cb();
            });
        }, function (cb) {
            // This writes out the 'zoneconfig' file used by zoneinit to root's
            // home directory in the zone.
            if (payload.brand === 'joyent') {
                writeZoneconfig(payload, function (err, result) {
                    if (err) {
                        return cb(err);
                    }
                    return cb();
                });
            } else {
                return cb();
            }
        }, function (cb) {
            // Joyent branded zones can have an additional 'data' dataset
            // delegated to them for use in the zone.  This will set that up.
            if (payload.brand === 'joyent') {
                addDelegatedDataset(payload, function (err) {
                    if (err) {
                        return cb(err);
                    }
                    return cb();
                });
            } else {
                return cb();
            }
        }, function (cb) {
            // The vm is now ready to start, we'll start if autoboot is set.
            if (payload.autoboot) {
                VM.start(payload.uuid, {}, function(err, res) {
                    if (err) {
                        return cb(err)
                    }
                    return cb();
                });
            } else {
                return cb();
            }
        }, function (cb) {
            // zoneinit runs in joyent branded zones and the zone is not
            // considered provisioned until it's rebooted once.
            if (payload.brand === 'joyent' && !payload.nowait) {
                waitForJoyentZone(payload, function(err, result) {
                    if (err) {
                        VM.logger('WARN', 'zoneinit failed, zone is ' +
                            'being stopped for manual investigation.', err);
                        failZone(payload.zonename, function () {
                            return cb(err);
                        });
                    } else {
                        return cb();
                    }
                });
            } else {
                return cb();
            }
        }], function (error) {
            callback(error);
        }
    );
}

function assignMACs(payload)
{
    var n, nic;

    for (n in payload.nics) {
        if (payload.nics.hasOwnProperty(n)) {
            nic = payload.nics[n];
            if (!nic.hasOwnProperty('mac')) {
                nic.mac = generateMAC();
            }
        }
    }
}

function normalizePayload(payload, callback)
{
    assignMACs(payload);
    applyZoneDefaults(payload);
    system.getProvisionableMemory(function (err, available_MiB) {
        if (err) {
            VM.logger('WARN', 'unable to determine system memory ' +
                'usage, assuming we have sufficient memory.');
            payload.available_MiB = payload.ram;
        } else {
            payload.available_MiB = available_MiB;
        }
        checkProperties(payload, function (err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    });
}

function unsetTransition(m, callback)
{
    zonecfg(['-u', m.uuid, 'remove attr name=transition'], function (err, fds) {
        if (err) {
            VM.logger('ERROR', 'unable to remove transition for zone ' +
                m.uuid + ' stderr: ' + fds.stderr, err);
        }
        // We don't error here because we want to be idempotent.

        if (m.transition_to && m.transition_to === 'start') {
            VM.logger('DEBUG', 'vm was stopping for reboot, ' +
                'transitioning to start.');
            VM.start(m.uuid, {}, function (err) {
                if (err) {
                    VM.logger('ERROR', 'failed to start when clearing ' +
                        'transition', err);
                }
            });
        }

        return callback();
    });
}

function setTransition(m, transition, target, timeout, callback)
{
    if (!timeout) {
        return callback(new Error('setTransition() requires timeout argument.'));
    }

    async.series([
        function (cb) {
            if (m.hasOwnProperty('transition')) {
                unsetTransition(m, cb);
            } else {
                return cb();
            }
        }, function (cb) {
            zonecfg(['-u', m.uuid, 'add attr; set name=transition; set value="'
                + transition + ':' + target + ':' +
                (Date.now() + timeout).toString() +
                '"; set type=string; end'], function () {

                // TODO: handle errors

                VM.logger('DEBUG', 'setting transition=' + transition +
                    ' for vm ' + m.uuid);

                cb();
            });
        }
    ], function (error) {
        callback(error);
    });
}

exports.create = function (payload, callback)
{
    normalizePayload(payload, function (err) {
        if (err) {
            return callback(err);
        }
        if (payload.brand === "kvm") {
            createZoneUUID(payload, function (err, uuid) {
                if (err) {
                    return callback(err);
                }
                createVM(payload, function (err, result) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, {'uuid': payload.uuid,
                        'zonename': payload.zonename});
                });
            });
        } else if (payload.brand === "joyent") {
            createZoneUUID(payload, function (err, uuid) {
                if (err) {
                    return callback(err);
                }
                createZone(payload, function (err, result) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, {'uuid': payload.uuid,
                        'zonename': payload.zonename});
                });
            });
        } else {
            return callback(new Error('Don\'t know how to create a "' +
                payload.brand + '"'));
        }
    });
};

// delete a zvol
function deleteVolume(volume, callback)
{
    var args = ['destroy', '-F', volume.zfs_filesystem];

    zfs(args, function (err, fds) {
        // err will be non-null if something broke
        callback(err);
    });
}

exports.delete = function (uuid, callback)
{
    var zoneobj;
    var zonename;

    VM.logger('DEBUG', 'deleting vm ' + uuid);

    async.series([
        function (cb) {
            VM.load(uuid, function (err, obj) {
                if (err) {
                    cb(err);
                }
                zoneobj = obj;
                zonename = zoneobj.zonename;
                cb();
            });
        }, function (cb) {
            VM.logger('DEBUG', 'setting autoboot=false');
            zonecfg(['-u', uuid, 'set autoboot=false'], function () {
                // TODO: log error?
                cb();
            });
        }, function (cb) {
            VM.logger('DEBUG', 'halting zone');
            zoneadm(['-u', uuid, 'halt', '-X'], function () {
                // TODO: log error?
                cb();
            });
        }, function (cb) {
            VM.logger('DEBUG', 'uninstalling zone');
            zoneadm(['-u', uuid, 'uninstall', '-F'], function () {
                // TODO: log error?
                cb();
            });
        }, function (cb) {
            if (zoneobj && zoneobj.brand === 'kvm') {
                async.forEach(zoneobj.disks, deleteVolume, function (err) {
                    if (err) {
                        VM.logger('ERROR', 'unknown error deleting volumes', err);
                        cb(err);
                    } else {
                        VM.logger('INFO', 'successfully deleted volumes');
                        cb();
                    }
                });
            } else {
                VM.logger('DEBUG', 'skipping volume destruction for ' +
                    'non-VM ' + zoneobj.uuid);
                cb();
            }
        }, function (cb) {
            if (zonename) {
                VM.logger('DEBUG', 'deleting zone');
                // XXX for some reason -u <uuid> doesn't work with delete
                zonecfg(['-z', zonename, 'delete', '-F'], function () {
                    cb();
                });
            } else {
                cb();
            }
        }
    ], function (error) {
        callback(error);
    });
};

function startZone(zoneobj, callback)
{
    var uuid = zoneobj.uuid;
    var set_autoboot = 'set autoboot=true';

    VM.logger('DEBUG', 'startZone booting ' + uuid);

    //
    // We set autoboot (or vm-autoboot) here because we've just intentionally
    // started this vm, so we want it to come up if the host is rebooted.
    //
    if (zoneobj.brand === 'kvm') {
        set_autoboot = 'select attr name=vm-autoboot; set value=true; end';
    }

    zoneadm(['-u', uuid, 'boot'], function (err, fds) {
        if (err) {
            return callback(err);
        }
        zonecfg(['-u', uuid, set_autoboot], function (err, fds) {
           if (err) {
               // The vm is running at this point, erroring out here would
               // do no good, so we just log it.
               VM.logger('ERROR', 'startVM(): Failed to ' + set_autoboot +
                   ' for ' + uuid, err);
           }

           if (zoneobj.never_booted) {
                zonecfg(['-u', uuid, 'remove attr name=never-booted' ],
                    function (err, fds) {
                        // Ignore errors here, because we're started.
                        if (err) {
                            VM.logger('WARN', 'failed to remove ' +
                                'never-booted flag for ' + uuid, err);
                        }
                        callback();
                    }
                );
           } else {
               callback();
           }
        });
    });
}

// build the qemu cmdline and start up a VM
function startVM(vmobj, extra, callback)
{
    var cmd;
    var cmdargs = [];
    var diskargs = '';
    var uuid = vmobj.uuid;
    var qemu_opts = '';
    var disk, disk_idx = 0;
    var nic, nic_idx = 0;
    var proc;
    var working_dir;
    var script;

    VM.logger('DEBUG', 'startVM(' + uuid + ')');

    if (vmobj.hasOwnProperty('state') && vmobj.state !== 'stopped') {
        return callback(new Error('Cannot start VM from state: ' + vmobj.state +
            ', must be "stopped"'));
    }

    // XXX TODO: validate vmobj data is ok to start

    working_dir = vmobj.zonepath + '/root';

    cmdargs.push('-m', vmobj.ram);
    cmdargs.push('-name', vmobj.uuid);
    cmdargs.push('-uuid', vmobj.uuid);

    if (vmobj.hasOwnProperty('cpu_type')) {
        if (vmobj.cpu_type === 'host' &&
            SDC.sysinfo['Product'] === 'VMware Virtual Platform') {

            // Some systems (eg. when running SmartOS in a VM on VMWare)
            // don't support the '-cpu host' option.  On those systems we
            // instead use '-cpu qemu64'
            cmdargs.push('-cpu', 'qemu64');
        } else {
            cmdargs.push('-cpu', vmobj.cpu_type);
        }
    } else {
        cmdargs.push('-cpu', 'qemu64');
    }

    if (vmobj.vcpus > 1) {
        cmdargs.push('-smp', vmobj.vcpus);
    }

    for (disk in vmobj.disks) {
        if (vmobj.disks.hasOwnProperty(disk)) {
            disk = vmobj.disks[disk];
            if (!disk.media) {
                disk.media = "disk";
            }
            diskargs = 'file=' + disk.path + ',if=' + disk.model +
                ',index=' + disk_idx + ',media=' + disk.media;
            if (disk.boot) {
                diskargs = diskargs + ',boot=on';
            }
            cmdargs.push('-drive', diskargs);
            disk_idx++;
        }
    }

    // extra payload can include additional disks that we want to include only
    // on this one boot.  It can also contain a boot parameter to control boot
    // device.  See qemu http://qemu.weilnetz.de/qemu-doc.html for info on
    // -boot options.
    if (extra.hasOwnProperty('disks')) {
        for (disk in extra.disks) {
            if (extra.disks.hasOwnProperty(disk)) {

                // TODO: make sure disk exists in zonecfg so that it's
                // available in the zone.

                disk = extra.disks[disk];
                if (!disk.media) {
                    disk.media = "disk";
                }
                diskargs = 'file=' + disk.path + ',if=' + disk.model +
                    ',index=' + disk_idx + ',media=' + disk.media;
                if (disk.boot) {
                    diskargs = diskargs + ',boot=on';
                }
                cmdargs.push('-drive', diskargs);
                disk_idx++;
            }
        }
    }

    // helpful values:
    // order=nc (network boot, then fallback to disk)
    // once=d (boot on disk once and the fallback to default)
    // order=c,once=d (boot on CDROM this time, but not subsequent boots)
    if (extra.hasOwnProperty('boot')) {
        cmdargs.push('-boot', extra.boot);
    } else if (vmobj.hasOwnProperty('boot')) {
        cmdargs.push('-boot', vmobj.boot);
    } else {
        // order=cd means try harddisk first (c) and cdrom if that fails (d)
        cmdargs.push('-boot', 'order=cd');
    }

    var hostname = vmobj.uuid;
    if (vmobj.hasOwnProperty('hostname')) {
        hostname = vmobj.hostname;
    }

    var defaultgw = '';
    if (vmobj.hasOwnProperty('default-gateway')) {
        defaultgw = vmobj['default-gateway'];
    }

    primary_found = false;
    for (nic in vmobj.nics) {
        if (vmobj.nics.hasOwnProperty(nic)) {
            nic = vmobj.nics[nic];
            cmdargs.push('-net',
                'nic,macaddr=' + nic.mac +
                ',vlan=' + nic_idx +
                ',name=net' + nic_idx +
                ',model=' + nic.model);
            var vnic_opts = 'vnic,name=net' + nic_idx +
                ',vlan=' + nic_idx +
                ',ifname=net' + nic_idx;

            if (nic.ip != 'dhcp') {
                vnic_opts = vnic_opts +
                    ',ip=' + nic.ip +
                    ',netmask=' + nic.netmask;
            }

            // The primary network provides the resolvers, default gateway
            // and hostname to prevent vm from trying to use settings
            // from more than one nic
            if (!primary_found) {
                if (nic.hasOwnProperty('primary') && nic.primary) {
                    if (nic.hasOwnProperty('gateway') && nic.ip != 'dhcp') {
                        vnic_opts += ',gateway_ip=' + nic.gateway;
                    }
                    primary_found = true;
                }
                else if (defaultgw && nic.hasOwnProperty('gateway') && nic.gateway == defaultgw) {
                    if (nic.ip != 'dhcp') {
                        vnic_opts += ',gateway_ip=' + nic.gateway;
                    }
                    primary_found = true;
                }

                if (primary_found && nic.ip != 'dhcp') {
                    if (hostname) {
                        vnic_opts += ',hostname=' + hostname;
                    }
                    if (vmobj.hasOwnProperty('resolvers')) {
                      for (r in vmobj.resolvers) {
                        vnic_opts += ',dns_ip' + r + '=' + vmobj.resolvers[r];
                      }
                    }
                }
            }

            cmdargs.push('-net', vnic_opts);
            nic_idx++;
        }
    }

    cmdargs.push('-smbios', 'type=1,manufacturer=Joyent,' +
        'product=SmartDC HVM,version=6.2012Q1,' +
        'serial=' + vmobj.uuid + ',uuid=' + vmobj.uuid + ',' +
        'sku=001,family=Virtual Machine');

    cmdargs.push('-pidfile', '/tmp/vm.pid');

    cmdargs.push('-chardev',
        'socket,id=qmp,path=/tmp/vm.qmp,server,nowait');
    cmdargs.push('-qmp', 'chardev:qmp');

    // serial0 is for serial console
    cmdargs.push('-chardev',
        'socket,id=serial0,path=/tmp/vm.console,server,nowait');
    cmdargs.push('-serial', 'chardev:serial0');

    // serial1 is used for metadata API
    cmdargs.push('-chardev',
        'socket,id=serial1,path=/tmp/vm.ttyb,server,nowait');
    cmdargs.push('-serial', 'chardev:serial1');

    if (!vmobj.qemu_opts) {
        cmdargs.push('-vnc', 'unix:/tmp/vm.vnc');
        cmdargs.push('-parallel', 'none');
        cmdargs.push('-usb');
        cmdargs.push('-usbdevice', 'tablet');
        cmdargs.push('-k', 'en-us');
        cmdargs.push('-vga', 'cirrus');
    } else {
        qemu_opts = vmobj.qemu_opts.toString();
    }

    if (vmobj.qemu_extra_opts) {
        qemu_opts = qemu_opts + ' ' + vmobj.qemu_extra_opts;
    }

    // This actually creates the qemu process
    script = '#!/usr/bin/bash\n\n' +
        "exec >/tmp/vm.log 2>&1\n\n" +
        "set -o xtrace\n\n" +
        'exec /smartdc/bin/qemu-system-x86_64 "' + cmdargs.join('" "') +
            '" ' + qemu_opts + '\n\n' +
        "exit 1\n";

    fs.writeFileSync(vmobj.zonepath + '/root/startvm', script);
    fs.chmodSync(vmobj.zonepath + '/root/startvm', "0755");

    return startZone(vmobj, callback);
}

exports.start = function (uuid, extra, callback)
{
    var zoneobj;

    VM.load(uuid, function (err, obj) {
        if (err) {
            return callback(err);
        }
        if (obj.state !== 'stopped') {
            return callback(new Error('Cannot to start vm from state "' +
                obj.state + '", must be "stopped".'));
        }
        zoneobj = obj;
        if (zoneobj.hasOwnProperty('brand') && zoneobj.brand === 'joyent') {
            // TODO: warning if 'extra' is non-empty
            return startZone(zoneobj, callback);
        } else if (zoneobj.hasOwnProperty('brand') && zoneobj.brand === 'kvm') {
            return startVM(zoneobj, extra, callback);
        } else {
            return callback('no idea how to start a vm with brand: ' +
                zoneobj.brand);
        }
        return callback();
    });
};

function setRctl(zonename, rctl, value, callback)
{
    var args;

    args = ['-n', rctl, '-v', value.toString(), '-r', '-i', 'zone', zonename];
    VM.logger('DEBUG', '/usr/bin/prctl ' + args.join(' '));
    execFile('/usr/bin/prctl', args, function (error, stdout, stderr) {
        if (error) {
            VM.logger('ERROR', 'setRctl() failed with: ' + stderr, error);
            return callback(error);
        }
        return callback();
    });
}

function applyUpdates(m, payload, callback)
{
    async.series([
        function (cb) {
            if (payload.hasOwnProperty('quota')) {
                setQuota(m.zonepath, payload.quota, cb);
            } else {
                cb();
            }
        }, function (cb) {
            var prop;
            var rctl;
            var factor;
            var rctls = {
                'cpu_shares': ['zone.cpu-shares'],
                'zfs_io_priority': ['zone.zfs-io-priority'],
                'max_lwps': ['zone.max-lwps'],
                'max_physical_memory': ['zone.max-physical-memory', (1024 * 1024)],
                'max_locked_memory': ['zone.max-locked-memory', (1024 * 1024)],
                'max_swap': ['zone.max-swap', (1024 * 1024)],
                'cpu_cap': ['zone.cpu-cap'],
            };

            if (m.brand === 'kvm') {
                // no changing VM rctls while running
                return cb();
            }

            for (prop in rctls) {
                rctl = rctls[prop][0];
                if (rctls[prop][1]) {
                    factor = rctls[prop][1];
                } else {
                    factor = 1;
                }

                // TODO: set these in an async.series and then call cb(), so we
                // make sure they all happen before exit.
                if (m.brand === 'joyent' & payload.hasOwnProperty(prop)) {
                    setRctl(m.zonename, rctl, Number(payload[prop]) * factor,
                        function(err)
                        {
                            if (err) {
                                VM.logger('WARN', 'failed to set rctl: ' +
                                    prop, err);
                            }
                        }
                    );
                }
            }
            cb();
        }
    ], function (err, res) {
        return callback(err);
    });
}

exports.update = function (uuid, payload, callback)
{
    VM.logger('DEBUG', 'updating ' + uuid + ' with payload=' + payload);

    VM.load(uuid, function (err, obj) {
        var zcfg;

        if (err) {
            return callback(err);
        }

        zcfg = buildZonecfgUpdate(obj, payload);

        // send the zonecfg data we just generated as a file to zonecfg to
        // update the zone.
        updateMetadata(obj, payload, function (err) {
            if (err) {
                return callback(err);
            }
            zonecfgFile(zcfg, ['-u', uuid], function (err, fds) {
                applyUpdates(obj, payload, function () {
                    return callback(err);
                });
            });
        });
    });
};

function kill(uuid, callback)
{
    var unset_autoboot = 'set autoboot=false';

    VM.logger('DEBUG', 'killing vm ' + uuid);

    /* We load here to ensure this vm exists. */
    VM.load(uuid, function (err, obj) {
        if (err) {
            return callback(err);
        }
        if (obj.brand === 'kvm') {
            unset_autoboot = 'select attr name=vm-autoboot; set value=false; end';
        }

        zoneadm(['-u', uuid, 'halt', '-X'], function (err, fds) {
            var msg = trim(fds.stderr);
            if (msg.match(/zone is already halted$/)) {
                // remove transition marker, since vm is not running now.
                unsetTransition(obj, function() {
                    return callback(null, 'vm is not running');
                });
            }
            if (err) {
                VM.logger('ERROR', 'failed to kill ' + uuid + ': ' + fds.stderr, err);
                return callback(err, msg);
            }

            zonecfg(['-u', uuid, unset_autoboot], function (e, fds) {
                if (err) {
                    // The vm is dead at this point, erroring out here would
                    // do no good, so we just log it.
                    VM.logger('ERROR', 'killVM(): Failed to ' +
                        unset_autoboot + ' for ' + uuid);
                }
                if (obj.state === 'stopping') {
                    // remove transition marker
                    unsetTransition(obj, function() {
                        return callback(null, msg);
                    });
                } else {
                    return callback(null, msg);
                }
            });
        });
    });
};

function postVmadmd(uuid, action, args, callback)
{
    var append = '';
    var path = '/vm/' + uuid + '?action=' + action;

    if (args) {
        for (arg in args) {
            if (args.hasOwnProperty(arg)) {
                path = path + '&' + arg + '=' + args[arg];
            }
        }
    }

    VM.logger('DEBUG', 'HTTP POST ' + path);
    req = httpu.request({ method: 'POST', socketPath: VMADMD_SOCK, path: path }, function(res) {
        VM.logger('DEBUG', 'HTTP STATUS: ' + res.statusCode);
        VM.logger('DEBUG', 'HTTP HEADERS: ' + JSON.stringify(res.headers));
        res.setEncoding('utf8');
        res.on('data', function (chunk) {
            VM.logger('DEBUG', 'HTTP BODY: ' + chunk);
        });
        res.on('end', function () {
            VM.logger('DEBUG', 'HTTP conversation has completed.');
        });
    });
    req.on('error', function(e) {
        VM.logger('ERROR', 'HTTP error', e);
    });
    req.end();
}

exports.stop = function (uuid, options, callback)
{
    var unset_autoboot = 'set autoboot=false';

    VM.logger('DEBUG', 'stopping ' + uuid);

    if (!options) {
        options = {};
    }
    if (options.force) {
        return kill(uuid, callback);
    }
    if (!options.timeout) {
        options.timeout = 180;
    }
    if (!options.transition_to) {
        options.transition_to = 'stopped';
    }

    /* We load here to ensure this vm exists. */
    VM.load(uuid, function (err, obj) {
        var args;

        if (err) {
            return callback(err);
        }

        if (obj.brand === 'kvm') {
            setTransition(obj, 'stopping', options.transition_to,
                (options.timeout * 1000),
                function (err)
                {
                    unset_autoboot = 'select attr name=vm-autoboot; ' +
                        'set value=false; end';

                    postVmadmd(obj.uuid, 'stop', {'timeout': options.timeout},
                        function (err)
                        {
                            if (err) {
                                return callback('Unable to post "stop" to vmadmd');
                            }
                            zonecfg(['-u', uuid, unset_autoboot], function (e, fds) {
                                if (err) {
                                    // The vm is dead at this point, erroring out
                                    // here would do no good, so we just log it.
                                    VM.logger('ERROR', 'stop(): Failed to '
                                        + unset_autoboot + ' for ' + uuid, err);
                                }
                                return callback();
                            });
                        }
                    );
                }
            );
        } else {
            args = [obj.zonename, '/usr/sbin/shutdown', '-y', '-g', '0',
                '-i', '5'];
            VM.logger('DEBUG', '/usr/sbin/zlogin ' + args.join(' '));
            execFile('/usr/sbin/zlogin', args, function (err, stdout, stderr) {
                if (err) {
                    VM.logger('ERROR', 'zlogin for ' + obj.zonename +
                        ' exited with code' + err.code + ' stdout: "' +
                        stdout + '" stderr:"' + stderr + '"', err);
                    return callback(err);
                }

                zonecfg(['-u', uuid, unset_autoboot], function (e, fds) {
                    if (e) {
                        // The vm is dead at this point, erroring out here would
                        // do no good, so we just log it.
                        VM.logger('ERROR', 'stop(): Failed to ' + unset_autoboot
                            + ' for ' + uuid, e);
                    }
                    return callback(null);
                });
            });
        }
    });
};

// sends several query-* commands to QMP to get details for a VM
exports.info = function (uuid, types, callback)
{
    var res = {};

    // load to ensure we're a VM
    VM.load(uuid, function (err, obj) {
        if (err) {
            return callback('error loading VM: ' + JSON.stringify(err));
        }

        if (obj.brand !== 'kvm') {
            return callback(new Error('the info command is only supported for' +
                ' VMs'));
        }

        if (obj.state !== 'running' && obj.state !== 'stopping') {
            return callback(new Error('Unable to get info for vm from ' +
                'state "' + obj.state + '", must be "running" or "stopping".'));
        }

        if (!types) {
            types = ['all'];
        }

        for (type in types) {
            type = types[type];
            if (VM.INFO_TYPES.indexOf(type) === -1) {
                return callback(new Error('unknown info type: ' + type));
            }
        }

        httpu.get({ socketPath: VMADMD_SOCK, path: '/vm/' + uuid + '?types=' + types.join(',') }, function(res) {
            data = '';
            if (res.statusCode !== 200) {
                return callback(new Error('Unable to get info from vmadmd, query returned ' + res.statusCode + '.'));
            }
            res.on('data', function(d) {
                data = data + d.toString();
            });
            res.on('end', function(d) {
                return callback(null, JSON.parse(data));
            });
        }).on('error', function(e) {
            console.error(e);
        });
    });
};

function reset(uuid, callback)
{
    VM.logger('DEBUG', 'reset(' + uuid + ')');

    /* We load here to ensure this vm exists. */
    VM.load(uuid, function (err, obj) {
        if (err) {
            return callback(err);
        }

        if (obj.state !== 'running') {
            return callback(new Error('Cannot reset vm from state "' +
                obj.state + '", must be "running".'));
        }

        if (obj.brand === 'kvm') {
            postVmadmd(obj.uuid, 'reset', {}, function (err) {
                if (err) {
                    return callback('Unable to post "reset" to vmadmd');
                }
                return callback();
            });
        } else {
            zoneadm(['-u', obj.uuid, 'reboot', '-X'], function (err, fds) {
                if (err) {
                    return callback(rtrim(fds.stderr));
                }

                return callback();
            });
        }
    });
};

exports.reboot = function (uuid, options, callback)
{
    if (!options) {
        options = {};
    }

    if (options.force) {
        return reset(uuid, callback);
    }

    VM.load(uuid, function (err, m) {
        var args;

        if (err) {
            return callback(err);
        }

        if (m.state !== 'running') {
            return callback(new Error('Cannot reboot vm from state "' +
                m.state + '", must be "running"'));
        }

        if (m.brand === 'kvm') {
            options.transition_to = 'start';
            VM.stop(uuid, options, function (err) {
                if (err) {
                    return callback(err);
                }
                return callback();
            });
        } else {
            // joyent branded zones
            args = [m.zonename, '/usr/sbin/shutdown', '-y', '-g', '0',
                '-i', '6'];
            VM.logger('DEBUG', '/usr/sbin/zlogin ' + args.join(' '));
            execFile('/usr/sbin/zlogin', args, function (err, stdout, stderr) {
                if (err) {
                    VM.logger('ERROR', 'zlogin for ' + m.zonename +
                        ' exited with code' + err.code + ' stdout: "' +
                        stdout + '" stderr:"' + stderr + '"', err);
                    return callback(err);
                }

                return callback();
            });
        }
    });
};

exports.sysrq = function(uuid, req, options, callback)
{
    VM.logger('DEBUG','sysrq(' + uuid + ',' + req + ')');

    /* We load here to ensure this vm exists. */
    VM.load(uuid, function (err, obj) {
        if (err) {
            return callback(err);
        }

        if (obj.state !== 'running' && obj.state !== 'stopping') {
            return callback(new Error('Unable to send request to vm from "'
                + 'state "' + obj.state + '", must be "running" or "stopping".'));
        }

        if (obj.brand !== 'kvm') {
            return callback(new Error('The sysrq command is only supported for'
                + ' VMs.'));
        }

        if (VM.SYSRQ_TYPES.indexOf(req) === -1) {
            return callback(new Error('Invalid sysrq "' + req + '" valid values: '
                + '"' + VM.SYSRQ_TYPES.join('","') + '".'));
        }

        postVmadmd(obj.uuid, 'sysrq', {'request': req}, function (err) {
            if (err) {
                return callback('Unable to post "sysrq" to vmadmd');
            }
            return callback();
        });
    });
};

exports.console = function(uuid, callback)
{
    VM.load(uuid, function (err, obj) {
        var child;
        var cmd;
        var args;
        var stty;

        if (err) {
            return callback(err);
        }
        if (obj.state !== 'running') {
            return callback(new Error('cannot connect to console when state is '
                + '"' + obj.state + '" must be "running".'));
        }

        if (obj.brand === 'joyent') {
            cmd = '/usr/sbin/zlogin';
            args = ['-C', '-e', "\\035", obj.zonename];

            VM.logger('DEBUG', cmd + ' ' + args.join(' '));
            child = spawn(cmd, args, {customFds: [process.stdin, process.stdout, process.stderr]});
            child.on('exit', function (code) {
                VM.logger('DEBUG', 'zlogin process exited with code ' + code);
                return callback();
            });
        } else if (obj.brand === 'kvm') {
            async.series([
                function (cb)
                {
                    cmd = '/usr/bin/stty';
                    args = ['-g'];
                    stty = '';

                    VM.logger('DEBUG', cmd + ' ' + args.join(' '));
                    child = spawn(cmd, args, {customFds: [process.stdin, -1, -1]});
                    child.stdout.on('data', function (data) {
                        //VM.logger('DEBUG', 'data: ' + data.toString());
                        stty = data.toString();
                    });
                    child.on('exit', function (code) {
                        VM.logger('DEBUG', 'stty process exited with code ' + code);
                        return cb();
                    });
                },
                function (cb)
                {
                    cmd = '/usr/bin/socat';
                    args = ['unix-client:' + obj.zonepath + '/root/tmp/vm.console',
                        '-,raw,echo=0,escape=0x1d']

                    VM.logger('DEBUG', cmd + ' ' + args.join(' '));
                    child = spawn(cmd, args, {customFds: [process.stdin, process.stdout, process.stderr]});
                    child.on('exit', function (code) {
                        VM.logger('DEBUG', 'zlogin process exited with code ' + code);
                        return cb();
                    });
                },
                function (cb)
                {
                    cmd = '/usr/bin/stty';
                    args = [stty];

                    VM.logger('DEBUG', cmd + ' ' + args.join(' '));
                    child = spawn(cmd, args, {customFds: [process.stdin, -1, -1]});
                    child.on('exit', function (code) {
                        VM.logger('DEBUG', 'stty process exited with code ' + code);
                        return cb();
                    });
                }
            ],
            function (err, results)
            {
                return callback(err);
            });
        } else {
            return callback(new Error('Cannot get console for brand: ' +
                obj.brand));
        }
    });
};
