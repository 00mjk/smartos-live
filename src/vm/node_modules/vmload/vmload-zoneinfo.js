/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

// Ensure we're using the platform's node
// XXX TODO update this when it's been moved.
// require('/usr/node/node_modules/platform_node_version').assert();

var assert = require('assert');
var cp = require('child_process');
var props = require('/usr/vm/node_modules/props');
var spawn = cp.spawn;
var utils = require('utils');

// utils
var isUUID = utils.isUUID;
var rtrim = utils.rtrim;

var ZONEINFO_FIELDS = props.ZONEINFO_FIELDS;
var ZONEINFO_PROPERTIES = props.ZONEINFO_PROPERTIES;

var mdb;
var mdb_pid;
var buffer;
var index = 0;
var requests = {};
var pending_index;

function spawnMdb(log)
{
    var cmd = '/usr/bin/mdb';
    var args = ['-k'];

    log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing mdb');
    mdb = spawn(cmd, args, {stdio: 'pipe'});
    log.debug('mdb[' + mdb.pid + '] running');
    mdb_pid = mdb.pid;

    mdb.on('close', function (code) {
        log.debug('mdb[' + mdb_pid + '] exited with code: ' + code);

        mdb = undefined;
        mdb_pid = undefined;
    });

    mdb.stderr.on('data', function (data) {
        if (pending_index) {
            requests[pending_index].stderr += data.toString();
        }
    });

    mdb.stdout.on('data', function (data) {
        var lines;
        var line;
        var matches;
        var start_re = /start\.(\d+)/;
        var end_re = /end\.(\d+)/;

        buffer += data.toString();
        lines = buffer.split('\n');

        while (lines.length > 1) {
            line = lines.shift();
            if (start_re.test(line)) {
                matches = start_re.exec(line);
                pending_index = matches[1];
            } else if (end_re.test(line)) {
                matches = end_re.exec(line);
                pending_index = undefined;
                processResponse(matches[1]);
            } else {
                if (requests.hasOwnProperty(pending_index)) {
                    requests[pending_index].lines.push(line);
                }
            }
        }
        buffer = lines.pop();
    });
}

function submitRequest(index)
{
    var mdb_cmd;
    var format = '%s';

    Object.keys(ZONEINFO_PROPERTIES).forEach(function (k) {
        var fmt = ZONEINFO_PROPERTIES[k].format;

        assert(fmt.length > 0, 'invalid format string for ' + k);

        if (ZONEINFO_PROPERTIES[k]) {
            format = format + ' ' + fmt;
        }
    });

    mdb_cmd = '!echo start.' + index + '; ' + '::walk zone | ::printf "'
        + format + '\\n" zone_t zone_name '
        + Object.keys(ZONEINFO_PROPERTIES).join(' ')
        + '; !echo end.' + index + '\n';

    mdb.stdin.write(mdb_cmd);
}

function processResponse(index)
{
    var req = requests[index];
    var res = {};
    var log = req.log;
    var uuid = req.uuid;
    var callback = req.callback;

    req.lines.forEach(function (line) {
        var field_idx;
        var fields = rtrim(line).split(' ');

        if (fields.length ===
            (1 + Object.keys(ZONEINFO_PROPERTIES).length)) {

            obj = {
                'zonename': fields[0]
            };

            if (uuid && (obj.zonename != uuid)) {
                return;
            }

            field_idx = 1;
            Object.keys(ZONEINFO_PROPERTIES).forEach(function (k) {
                var field = ZONEINFO_PROPERTIES[k].field;
                var value = fields[field_idx++];

                if (ZONEINFO_PROPERTIES[k].loadValueTranslator) {
                    value
                        = ZONEINFO_PROPERTIES[k].loadValueTranslator(value);
                }

                obj[field] = value;
            });

            log.trace({object: obj}, 'loaded zoneinfo object');

            if (obj.zonename && obj.zonename.length === 36
                && isUUID(obj.zonename)) {

                res[obj.zonename] = obj;
            } else if (obj.zonename !== 'global') {
                log.error({object: obj},
                    'zoneinfo object is missing zonename');
            }
        } else if (line.replace(/ /g, '').length > 0) {
            log.debug('getZoneinfo(' + uuid + ') ignoring: ' + line);
        }
    });

    delete requests[index];

    if (req.stderr.length === 0) {
        callback(null, res);
    } else {
        errmsg = rtrim(req.stderr);
        new_err = new Error(errmsg);
        log.error({err: new_err, stderr: req.stderr},
            'getZoneinfo() mdb[' + mdb.pid + '] "'
            + args.join(',') + '" failed');
        callback(new_err);
    }

    if (!req.keepalive) {
        mdb.stdin.end();
    }
}

function nextIndex()
{
    if (index < 4294967295) {
        index++;
    } else {
        index = 1;
    }

    return (index);
}

/*
 * getZoneinfo() takes a uuid|zonename|null as the first option and
 * attempts to gather information from mdb -k for zones on the system using:
 *
 *   ::walk zone | ::printf "<format>\n" zone_t zone_name ...
 *
 * where the <format> and ... (fields of zone_t) are defined from proptable.js.
 *
 * The passed in callback function will be called with:
 *
 *   callback(err, results)
 *
 * with err being set (will be an Error object) only on error and results being
 * an object keyed by uuid of the data found for the system's zones.
 *
 * NOTE: as this data comes from the kernel, it is only available for running
 * zones.
 *
 */
function getZoneinfo(uuid, options, callback)
{
    var log;
    var keepalive;
    var index;

    assert(options.log, 'no logger passed to getZoneinfo()');
    log = options.log;

    if (options.hasOwnProperty('keepalive')) {
        keepalive = options.keepalive;
    } else {
        keepalive = false;
    }

    // // Shortcut case for tests, allows us to mock out actual call to zoneadm
    // if (options.mdb_stdout) {
    //     log.trace('mdb_stdout passed in as option, not spawning mdb');

    //     _processMdbData(options.mdb_stdout);
    //     mdb = {pid: 'debug'};
    //     if (options.mdb_stderr) {
    //         mdb_stderr = options.mdb_stderr;
    //     }
    //     _finishMdb(options.mdb_code ? options.mdb_code : 0);

    //     return; // don't actually spawn
    // }

    if (!mdb) {
        spawnMdb(log);
    }

    index = nextIndex();

    requests[index] = {
        uuid: uuid,
        log: log,
        options: options,
        keepalive: keepalive,
        callback: callback,
        lines: [],
        stderr: ''
    };

    submitRequest(index);
}

module.exports = {
    getZoneinfo: getZoneinfo
};

// now available via kstat
// kstat -c zone_misc -n $(echo 50b80e21-7990-49de-ab91-76b3902cd6ce | cut -c1-30)