/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2017, Joyent, Inc.
 *
 * Substitute for 'zoneevent.c' that uses Vminfod as an event source
 *
 */

var EventEmitter = require('events').EventEmitter;
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var bunyan = require('/usr/node/node_modules/bunyan');
var vminfod = require('/usr/vm/node_modules/vminfod/client');

module.exports.ZoneWatcher = ZoneWatcher;

var log = bunyan.createLogger({
    level: 'debug',
    name: 'vminfod/zonewatcher',
    stream: process.stderr,
    serializers: bunyan.stdSerializers
});

/*
 * ZoneWatcher class
 */
function ZoneWatcher(opts) {
    var self = this;

    assert(self instanceof ZoneWatcher, 'must be called with "new"');

    EventEmitter.call(self);

    opts = opts || {};
    if (typeof (opts) === 'string')
        opts = {name: opts};

    assert.object(opts, 'opts');
    assert.string(opts.name, 'opts.name');
    assert.optionalObject(opts.log, 'opts.log');

    var _log = opts.log || log;

    self.zw_name = opts.name;
    self.zw_logger = _log.child({client: self.zw_name});

    self.zw_vs = new vminfod.VminfodEventStream({
        name: self.zw_name,
        log: self.zw_logger
    });

    self.zw_vs.once('ready', function (ready_ev) {
        self.zw_logger.debug('ZoneWatcher ready');
        self.emit('ready');
    });

    self.zw_vs.on('readable', function () {
        var ev;
        while ((ev = self.zw_vs.read())) {
            self._handle_event(ev);
        }
    });
}
util.inherits(ZoneWatcher, EventEmitter);

/*
 * Handle an incoming vminfod update
 */
ZoneWatcher.prototype._handle_event = function _handle_event(ev) {
    var self = this;

    assert.object(ev, 'ev');
    assert.string(ev.type, 'ev.type');
    assert.string(ev.zonename, 'ev.zonename');

    self.zw_logger.trace({ev: ev}, 'processing vminfod event');

    var zoneupdated = false;

    var sysev = {
        data: {
            when: ev.ts,
            zonename: ev.zonename
        }
    };
    switch (ev.type) {
    case 'create':
        sysev.data.oldstate = '';
        sysev.data.newstate = ev.vm.zone_state;
        self.zw_logger.debug({ev: sysev}, 'zone watcher create event');
        zoneupdated = true;
        break;
    case 'delete':
        sysev.data.newstate = '';
        self.zw_logger.debug({ev: sysev}, 'zone watcher delete event');
        zoneupdated = true;
        break;
    case 'modify':
        assert.array(ev.changes, 'ev.changes');
        for (var i = 0; i < ev.changes.length; i++) {
            var change = ev.changes[i];
            if (change.path.length === 1
                && change.path[0] === 'zone_state') {

                sysev.data.oldstate = change.from;
                sysev.data.newstate = change.to;
                self.zw_logger.debug({ev: sysev}, 'zone watcher modify event');
                zoneupdated = true;
                break;
            }
        }
        break;
    default:
        assert(false, 'unknown vminfod event type: ' + ev.type);
        break;
    }

    if (zoneupdated) {
        /*
         * There is some discrepency with vminfod and sysevents, so we
         * translate the vminfod events to match what is expected by sysevent
         */
        if (sysev.data.newstate === 'installed') {
            sysev.data.newstate = 'uninitialized';
        }
        if (sysev.data.oldstate === 'installed') {
            sysev.data.oldstate = 'uninitialized';
        }
        self.emit('event', sysev);
    }
};

/*
 * stop the watcher
 */
ZoneWatcher.prototype.stop = function vminfod_watcher_stop() {
    var self = this;

    self.zw_vs.stop();
};

/*
 * if called directly just hook a vminfo stream to stdout
 */
if (require.main === module) {
    var zw = new ZoneWatcher('Module Run Directly');
    zw.on('event', function (sysev) {
        console.log(JSON.stringify(sysev));
    });
}
