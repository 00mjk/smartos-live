#!/bin/bash
#
# Copyright (c) 2010,2011 Joyent Inc., All rights reserved.
#
# Output some info representing the system.  Default: JSON
#
# IMPORTANT:
#
#  - Don't use anything here that you don't include in the live image!
#
#  - This data gets cached in /tmp/.sysinfo.* and *DOES NOT* automatically
#    have the cache refreshed.  If you change something where the change
#    needs to be visible to sysinfo, make sure you run this with either
#    the -f or -u flag after changing the system's state.
#

#set -o xtrace

PATH=/bin:/usr/bin:/sbin:/usr/sbin:/smartdc/bin:/opt/local/bin:/opt/local/sbin

CACHE_FILE_PARSABLE="/tmp/.sysinfo.parsable"
CACHE_FILE_JSON="/tmp/.sysinfo.json"
CACHE="true"
UNAME_S=$(uname -s)
DETECT_NICS=
FORCE=
PARSABLE=
UPDATE_ONLY=
while getopts fnpu? name
do
    case $name in
    f)
        # Force re-running commands (don't read the cached values)
        FORCE="true"
        ;;
    n)
        # Doing network discovery, in this mode we can't use the
        # cached values.  *And* we don't want to cache the output
        # we create since its non-standard.
        CACHE=
        FORCE="true"
        DETECT_NICS="true"
        ;;
    p)
        # Output key=value format, not json
        PARSABLE="true"
        ;;
    u)
        # Update cache *only*, do not output.
        FORCE="true"
        UPDATE_ONLY="true"
        ;;
    ?)
        printf "Usage: %s: [-f] [-n] [-p] [-u]\n"  $0
        exit 2
    ;;
    esac
done

if [[ ${UNAME_S} == "SunOS" && $(zonename) != "global" ]]; then
    echo "This program is for use in the global zone only."
    exit 1
fi

if [[ ${EUID} != 0 ]]; then
    echo "This program can only be run as root."
    exit 1
fi

# If we're not forcing update and we have a cached version, use that!
if [[ -z ${FORCE} ]]; then
    if [[ -z ${PARSABLE} && -s ${CACHE_FILE_JSON} ]]; then
        exec cat ${CACHE_FILE_JSON}
        exit 3
    elif [[ -s ${CACHE_FILE_PARSABLE} ]]; then
        exec cat ${CACHE_FILE_PARSABLE}
        exit 3
    fi
fi

if [[ ${UNAME_S} == "SunOS" ]]; then
    configfile="$(svcprop -p 'joyentfs/usb_copy_path' svc:/system/filesystem/smartdc:default 2>/dev/null)/config"
    if [[ ! -f ${configfile} ]]; then
        configfile="/mnt/$(svcprop -p 'joyentfs/usb_mountpoint' svc:/system/filesystem/smartdc:default 2>/dev/null)/config"
    fi
else
    configfile="/opt/smartdc/config/node.config"
fi

# helper to set global "normalized" to the expanded version of MAC ($1)
function normalize_mac()
{
    local mac=$1
    if [ -z "${mac}" ]; then
        echo "FATAL: unable to normalize empty mac!"
        exit 1
    fi

    normalized=`echo ${mac} | awk -F':' '{ print $1, $2, $3, $4, $5, $6 }' | { read o1 o2 o3 o4 o5 o6 junk
        printf "%02x:%02x:%02x:%02x:%02x:%02x" 0x${o1} 0x${o2} 0x${o3} 0x${o4} 0x${o5} 0x${o6}
    }`

    # ensure results are 'normal'
    echo "${normalized}" | grep "[a-fA-F0-9]\{2\}\:[a-fA-F0-9]\{2\}\:[a-fA-F0-9]\{2\}\:[a-fA-F0-9]\{2\}\:[a-fA-F0-9]\{2\}\:[a-fA-F0-9]\{2\}" >/dev/null 2>&1
    if [ "$?" != "0" ]; then
        echo "FATAL: failed to normalize MAC '${mac}'"
        exit 1
    fi
}

function get_smbios_system_info()
{
    # This puts the variables we're pulling out into the local environment
    eval $(smbios -t SMB_TYPE_SYSTEM \
        | egrep "Manufacturer: |Product: |Serial Number: |UUID: " \
        | sed -e 's/^ *//' \
        | sed -e 's/: /="/' \
        | sed -e 's/ *$/"/' \
        | sed -e 's/Serial Number/Serial_Number/')

    # overwrite UUID if config dictates otherwise
    tmp_uuid=$(/usr/bin/bootparams | grep "^override_uuid=" | cut -f2 -d'=')
    if [[ -n $tmp_uuid ]]; then
        UUID=$tmp_uuid
    fi
    #echo "${UUID}"
    #echo "${Product}"
    #echo "${Serial_Number}"
    #echo "${Manufacturer}"
}

function get_dmidecode_system_info()
{
    # This puts the variables we're pulling out into the local environment
    eval $(dmidecode -t 1 \
        | egrep "Manufacturer: |Product Name: |Serial Number: |UUID: " \
        | sed -e 's/^ *//' \
        | sed -e 's/: /="/' \
        | sed -e 's/ *$/"/' \
        | sed -e 's/Product Name/Product/' \
        | sed -e 's/Serial Number/Serial_Number/')

    if [[ -z ${Manufacturer} && -z ${Product} && -z ${Serial_Number} ]]; then
        # If we didn't get Manufacturer and stuff, try from Motherboard
        eval $(dmidecode -t 2 \
            | egrep "Manufacturer: |Product Name: |Serial Number: " \
            | sed -e 's/^ *//' \
            | sed -e 's/: /="/' \
            | sed -e 's/ *$/"/' \
            | sed -e 's/Product Name/Product/' \
            | sed -e 's/Serial Number/Serial_Number/')
    fi

    # overwrite UUID if config dictates otherwise
    tmp_uuid=$(/usr/bin/bootparams | grep "^override_uuid=" | cut -f2 -d'=')
    if [[ -n ${tmp_uuid} ]]; then
        UUID=${tmp_uuid}
    fi

    # On Solaris the UUID comes back lower case, so MAPI expects that.
    UUID=$(echo ${UUID} | tr [:upper:] [:lower:])

    #echo "${UUID}"
    #echo "${Product}"
    #echo "${Serial_Number}"
    #echo "${Manufacturer}"
}

function get_memory_mib()
{
    if [[ ${UNAME_S} == "SunOS" ]]; then
        # Get (misnamed in prtconf) memory size in Mebibytes
        Memory_in_MiB=`prtconf \
            | grep "Memory size: [0-9]* Megabytes" \
            | cut -d' ' -f3`
    else
        Memory_in_MiB=$(($(cat /proc/meminfo \
            | grep "^MemTotal:" \
            | tr -s ' ' \
            | cut -d ' ' -f2) \
            / 1024))
    fi

    #echo "${Memory_in_MiB}"
}

function get_smartos_cpu_info()
{
    CPU_Version=`smbios -t SMB_TYPE_PROCESSOR | grep -v "Version: 0000000000" \
        | grep "Version: " \
        | head -n1 \
        | tr -s ' ' \
        | sed -e 's/^ *Version: //' \
        | sed -e 's/ *$//'`

    CPU_Count=`smbios -t SMB_TYPE_PROCESSOR | grep -v "Version: 0000000000" \
        | grep "Version: " \
        | wc -l \
        | tr -d ' '`

    CPU_Cores=`psrinfo \
        | grep "^[0-9]" \
        | wc -l \
        | tr -d ' '`

    if [[ -x /smartdc/bin/has_hvx ]]; then
        CPU_Virtualization=$(/smartdc/bin/has_hvx)
    else
        CPU_Virtualization="unknown"
    fi

    #echo "${CPU_Version}"
    #echo "${CPU_Count}"
    #echo "${CPU_Cores}"
}

function get_linux_cpu_info()
{
    CPU_Version=$(grep "^model name" /proc/cpuinfo \
        | cut -d ':' -f2 \
        | tr -s ' ' \
        | sed -e "s/^ //" \
        | head -n1)

    CPU_Cores=$(grep "^processor	" /proc/cpuinfo \
        | wc -l \
        | tr -d ' ')

    CPU_Count=$(grep "^core id	.*: 0$" /proc/cpuinfo \
        | wc -l \
        | tr -d ' ')

    if [[ ${CPU_Count} -eq 0 ]]; then
        CPU_Count=${CPU_Cores}
    fi

    CPU_Virtualization=$(egrep -m 1 -o "(vmx|svm)" /proc/cpuinfo)
    if [[ -z ${CPU_Virtualization} ]]; then
        CPU_Virtualization="none"
    fi

    #echo "${CPU_Version}"
    #echo "${CPU_Count}"
    #echo "${CPU_Cores}"
}

function get_live_image_buildstamp()
{
    # Add joyent buildstamp to SYSTEM_INFO
    if [[ ${UNAME_S} == "SunOS" ]]; then
        Live_Image=$(uname -v | sed -e "s/.*_//")
    else
        Live_Image=HVM-$(cat /etc/sdc.buildstamp)
    fi
    #echo "${Live_Image}"
}

function get_system_type()
{
    Uname_System=${UNAME_S}
}

function get_hostname()
{
    Hostname=$(hostname)
}

function get_disks()
{
    if [[ ${UNAME_S} == "SunOS" ]]; then
        ORIGIFS=$IFS

        # set $IFS to end-of-line
        IFS=`echo -en "\n\b"`

        count=1
        for line in $(/usr/bin/disklist -s 2>/dev/null); do
            Disks[${count}]=${line}
            ((count++))
        done

        # set $IFS back
        IFS=$ORIGIFS
    else
        count=1
        for line in $(sfdisk -s | grep "^\/dev\/" | tr -d ' ' | sed -e "s/\/dev\///"); do
            dev=$(echo ${line} | cut -d ':' -f1 | tr -- '-' '_')
            size=$(echo ${line} | cut -d ':' -f2)
            size=$((${size} * 1024))
            Disks[${count}]="${dev}=${size}"
            ((count++))
        done
    fi

    #for entry in "${Disks[@]}"
    #do
    #    fields=(${entry//=/ })
    #    disk=${fields[0]}
    #    size=${fields[1]}
    #    echo "disk: ${disk} size: ${size}"
    #done
}

function get_nic_mappings()
{
    admin_nic=`/usr/bin/bootparams 2>/dev/null | grep "admin_nic" | cut -d '=' -f2-`
    if [[ -z ${admin_nic} ]] && [[ -f ${configfile} ]]; then
        admin_nic=`grep "^admin_nic=" ${configfile} | cut -f2- -d'='`
    fi
    if [[ -n ${admin_nic} ]]; then
        normalize_mac ${admin_nic}
        ADMIN_NIC=${normalized}
    fi
    external_nic=`/usr/bin/bootparams 2>/dev/null | grep "external_nic" | cut -d '=' -f2-`
    if [[ -z ${external_nic} ]] && [[ -f ${configfile} ]]; then
        external_nic=`grep "^external_nic=" ${configfile} | cut -f2- -d'='`
    fi
    if [[ -n ${external_nic} ]]; then
        normalize_mac ${external_nic}
        EXTERNAL_NIC=${normalized}
    fi
    internal_nic=`/usr/bin/bootparams 2>/dev/null | grep "internal_nic" | cut -d '=' -f2-`
    if [[ -z ${internal_nic} ]] && [[ -f ${configfile} ]]; then
        internal_nic=`grep "^internal_nic=" ${configfile} | cut -f2- -d'='`
    fi
    if [[ -n ${internal_nic} ]]; then
        normalize_mac ${internal_nic}
        INTERNAL_NIC=${normalized}
    fi

    #echo "${ADMIN_NIC}"
    #echo "${EXTERNAL_NIC}"
    #echo "${INTERNAL_NIC}"
}

function get_smartos_network_interfaces()
{
    count=1
    nic_tag_count=1
    NicTagList="admin"
    seen_nic_tag_admin="true"

    # ignore 'LINK SLOT ADDRESS INUSE CLIENT' line
    for line in $(pfexec /sbin/dladm show-phys -m \
        | grep -v "^LINK " | awk '{ print $1,$3 }' | tr ' ' '='); do

        nicnames=
        fields=(${line//=/ })
        iface=${fields[0]}
        normalize_mac ${fields[1]}
        mac=${normalized}
        ip4addr=$(ifconfig ${iface} 2>/dev/null \
            | grep "inet " | awk '{ print $2 }')

        if [[ -n "${ADMIN_NIC}" ]] && [[ "${ADMIN_NIC}" == "${mac}" ]]; then
            nicnames="admin"
            NIC_admin=${iface}
        fi
        if [[ -n "${EXTERNAL_NIC}" ]] && [[ "${EXTERNAL_NIC}" == "${mac}" ]]; then
            [[ -n ${nicnames} ]] && nicnames="${nicnames},"
            nicnames="${nicnames}external"
            NicTagList="${NicTagList},external"
            NIC_external=${iface}
        fi
        if [[ -n "${INTERNAL_NIC}" ]] && [[ "${INTERNAL_NIC}" == "${mac}" ]]; then
            [[ -n ${nicnames} ]] && nicnames="${nicnames},"
            nicnames="${nicnames}internal"
            NicTagList="${NicTagList},internal"
            NIC_internal=${iface}
        fi

        for tag in "${NicTagsMacs[@]}"; do
            tag_fields=(${tag//=/ })
            tag_name=${tag_fields[0]}
            normalize_mac ${tag_fields[1]}
            tag_mac=${normalized}
            if [[ "${tag_mac}" == "${mac}" ]]; then
                [[ -n ${nicnames} ]] && nicnames="${nicnames},"
                nicnames="${nicnames}${tag_name}"
                NicTags[${nic_tag_count}]="${tag_name}=${iface}"
                ((nic_tag_count++))
            fi

            # Build up the list of tags
            eval "seen_nic_tag=\${seen_nic_tag_${tag_name}}"
            if [[ -z "${seen_nic_tag}" ]]; then
                NicTagList="${NicTagList},${tag_name}"
                eval "seen_nic_tag_${tag_name}=true"
            fi
        done

        NetworkInterfaces[${count}]=${iface}
        eval "Network_Interface_${iface}_MAC_Address=${mac}"
        eval "Network_Interface_${iface}_IPv4_Address=${ip4addr}"
        if [[ -n ${nicnames} ]]; then
            eval "Network_Interface_${iface}_NIC_Names=${nicnames}"
        fi
        ((count++))
    done

    for line in $(dladm show-phys -p -olink,state); do
        fields=(${line//:/ })
        iface=${fields[0]}
        link_status=${fields[1]}
        eval "Network_Interface_${iface}_Link_Status=${link_status}"

    done

    #echo "${NIC_admin}"
    #echo "${NIC_external}"
    #echo "${NIC_internal}"
    #for iface in "${NetworkInterfaces[@]}"
    #do
    #  eval "mac=\${Network_Interface_${iface}_MAC_Address}"
    #  eval "ipv4=\${Network_Interface_${iface}_IPv4_Address}"
    #  eval "nicnames=\${Network_Interface_${iface}_NIC_Names}"
    #  echo "mac: ${mac} ---- ${ipv4} ---- ${nicnames}"
    #done
}

function get_linux_network_interfaces()
{
    count=1
    nic_tag_count=1
    NicTagList="admin"
    seen_nic_tag_admin="true"

    for iface in $(ifconfig -a | grep "^eth" | grep -v "\.[0-9]" | cut -d ' ' -f1); do
        nicnames=
        iface_info=$(ifconfig ${iface})
        mac=$(echo ${iface_info} | grep -o "HWaddr \([0-9a-z\:]*\)" | cut -d' ' -f2)
        normalize_mac ${mac}
        mac=${normalized}
        ip4addr=$(echo ${iface_info} | grep -o "inet addr:\([0-9\.]*\)" | cut -d':' -f2)

        if [[ -n "${ADMIN_NIC}" ]] && [[ "${ADMIN_NIC}" == "${mac}" ]]; then
            nicnames="admin"
            NIC_admin=${iface}
        fi
        if [[ -n "${EXTERNAL_NIC}" ]] && [[ "${EXTERNAL_NIC}" == "${mac}" ]]; then
            [[ -n ${nicnames} ]] && nicnames="${nicnames},"
            nicnames="${nicnames}external"
            NicTagList="${NicTagList},external"
            NIC_external=${iface}
        fi
        if [[ -n "${INTERNAL_NIC}" ]] && [[ "${INTERNAL_NIC}" == "${mac}" ]]; then
            [[ -n ${nicnames} ]] && nicnames="${nicnames},"
            nicnames="${nicnames}internal"
            NicTagList="${NicTagList},internal"
            NIC_internal=${iface}
        fi

        for tag in "${NicTagsMacs[@]}"; do
            tag_fields=(${tag//=/ })
            tag_name=${tag_fields[0]}
            normalize_mac ${tag_fields[1]}
            tag_mac=${normalized}
            if [[ "${tag_mac}" == "${mac}" ]]; then
                [[ -n ${nicnames} ]] && nicnames="${nicnames},"
                nicnames="${nicnames}${tag_name}"
                NicTags[${nic_tag_count}]="${tag_name}=${iface}"
                ((nic_tag_count++))
            fi

            # Build up the list of tags
            eval "seen_nic_tag=\${seen_nic_tag_${tag_name}}"
            if [[ -z "${seen_nic_tag}" ]]; then
                NicTagList="${NicTagList},${tag_name}"
                eval "seen_nic_tag_${tag_name}=true"
            fi
        done

        NetworkInterfaces[${count}]=${iface}
        eval "Network_Interface_${iface}_MAC_Address=${mac}"
        eval "Network_Interface_${iface}_IPv4_Address=${ip4addr}"
        if [[ -n ${nicnames} ]]; then
            eval "Network_Interface_${iface}_NIC_Names=${nicnames}"
        fi

        link_status=$(ethtool ${iface} | grep -o "Link detected: .*" | cut -d' ' -f3-)
        case ${link_status} in
            yes)
                link_status="up"
                ;;
            *)
                link_status="unknown"
                ;;
        esac
        eval "Network_Interface_${iface}_Link_Status=${link_status}"
        ((count++))
    done

    #echo "${NIC_admin}"
    #echo "${NIC_external}"
    #echo "${NIC_internal}"
    #for iface in "${NetworkInterfaces[@]}"
    #do
      #eval "mac=\${Network_Interface_${iface}_MAC_Address}"
      #eval "ipv4=\${Network_Interface_${iface}_IPv4_Address}"
      #eval "nicnames=\${Network_Interface_${iface}_NIC_Names}"
      #echo "mac: ${mac} ---- ${ipv4} ---- ${nicnames}"
    #done
}

function get_nic_tags()
{
    count=1
    for line in $(/usr/bin/bootparams 2>/dev/null \
        | grep "^[a-zA-Z0-9_]*_nic=" \
        ; grep "^[a-zA-Z0-9_]*_nic=" ${configfile} 2>/dev/null); do
        fields=(${line//=/ })
        key=${fields[0]}
        if [[ $key != "admin_nic" ]] \
            && [[ $key != "external_nic" ]] \
            && [[ $key != "internal_nic" ]]; then

            NicTagsMacs[${count}]=$(echo ${line} | sed -e 's/_nic//')
            ((count++))
        fi
    done
}

function detect_nic_tags() {
    for iface in "${NetworkInterfaces[@]}"; do
        eval "link_status=\${Network_Interface_${iface}_Link_Status}"
        if [[ "${link_status}" != "up" ]]; then
            # polo needs the interface to be plumbed to work
            /usr/sbin/ifconfig ${iface} plumb
        fi

        # Leave it at the 30 second timeout for now
        detected_tag=$(/smartdc/bin/polo ${iface})

        if [[ "${link_status}" != "up" ]]; then
            /usr/sbin/ifconfig ${iface} unplumb
        fi
        if [[ -n "${detected_tag}" ]]; then
            eval "Network_Interface_${iface}_Detected_Nic_Tag=${detected_tag}"
        fi
    done
}

function get_bootparams()
{
    WHICH_GREP="/usr/xpg4/bin/grep"

    if [[ ${UNAME_S} == "Linux" ]]; then
        WHICH_GREP=grep
    fi

    count=1
    for line in $(/usr/bin/bootparams); do
        fields=(${line//=/ })
        key=$(echo ${fields[0]} | sed -e "s/\-/\_/g")
        if ! (echo "${key}" | ${WHICH_GREP} \
          -e "^tty" \
          -e "^atapi" \
          -e "^ata_dma" \
          -e "^keyboard_" \
          -e "^bios_boot_device" \
          -e "^lba_access_" \
          -e "^boot_ncpus" \
          -e "^boot_file" \
          -e "^whoami" \
          -e "^mfg_name" \
          -e "^impl_arch_name" \
          -e "_max_ncpus$" \
          >/dev/null); then
            Bootparams[${count}]=${line}
            ((count++))
    fi
    done
}

function output_parsable()
{
    cat <<END
Live_Image='${Live_Image}'
System_Type='${Uname_System}'
Manufacturer='${Manufacturer}'
Product='${Product}'
Serial_Number='${Serial_Number}'
UUID='${UUID}'
Hostname='${Hostname}'
CPU_Type='${CPU_Version}'
CPU_Virtualization='${CPU_Virtualization}'
CPU_Physical_Cores=${CPU_Count}
CPU_Total_Cores=${CPU_Cores}
MiB_of_Memory=${Memory_in_MiB}
Nic_Tags=${NicTagList}
END

    for entry in "${Disks[@]}"; do
        fields=(${entry//=/ })
        disk=${fields[0]}
        size=${fields[1]}
        gb_size=$((${size} / 1000000000))
        echo "Disk_${disk}_size_in_GB=${gb_size}"
    done

    [[ -n ${NIC_admin} ]] && echo "NIC_admin='${NIC_admin}'"
    [[ -n ${NIC_external} ]] && echo "NIC_external='${NIC_external}'"
    [[ -n ${NIC_internal} ]] && echo "NIC_internal='${NIC_internal}'"

    for tag in "${NicTags[@]}"; do
        tag_fields=(${tag//=/ })
        tag_name=${tag_fields[0]}
        int=${tag_fields[1]}
        echo "NIC_${tag_name}='${int}'"
    done

    for iface in "${NetworkInterfaces[@]}"; do
        mac_var="Network_Interface_${iface}_MAC_Address"
        ipv4_var="Network_Interface_${iface}_IPv4_Address"
        nicnames_var="Network_Interface_${iface}_NIC_Names"
        link_status_var="Network_Interface_${iface}_Link_Status"
        detected_tag_var="Network_Interface_${iface}_Detected_Nic_Tag"

        eval "mac=\${${mac_var}}"
        eval "ipv4=\${${ipv4_var}}"
        eval "nicnames=\${${nicnames_var}}"
        link_status="unknown"
        eval "link_status=\${${link_status_var}}"
        eval "detected_tag=\${${detected_tag_var}}"

        echo "${mac_var}='${mac}'"
        echo "${ipv4_var}='${ipv4}'"
        echo "${nicnames_var}='${nicnames}'"
        echo "${link_status_var}='${link_status}'"
        if [[ -n "${detected_tag}" ]] ; then
            echo "${detected_tag_var}='${detected_tag}'"
        fi
    done

    for entry in "${Bootparams[@]}"; do
        fields=(${entry//=/ })
        key=$(echo ${fields[0]} | sed -e "s/\-/\_/g")
        val=${fields[1]}
        echo "Bootparam_${key}='${val}'"
    done
}

function output_json()
{
    cat <<END
{
  "Live Image": "${Live_Image}",
  "System Type": "${Uname_System}",
  "Manufacturer": "${Manufacturer}",
  "Product": "${Product}",
  "Serial Number": "${Serial_Number}",
  "UUID": "${UUID}",
  "Hostname": "${Hostname}",
  "CPU Type": "${CPU_Version}",
  "CPU Virtualization": "${CPU_Virtualization}",
  "CPU Physical Cores": ${CPU_Count},
  "CPU Total Cores": ${CPU_Cores},
  "MiB of Memory": "${Memory_in_MiB}",
  "Disks": {
END

    printed=0
    for entry in "${Disks[@]}"; do
        fields=(${entry//=/ })
        disk=${fields[0]}
        size=${fields[1]}
        gb_size=$((${size} / 1000000000))
        ((printed++))
        trailing_comma=","
        [[ ${printed} -eq ${#Disks[*]} ]] && trailing_comma=''
        echo "    \"${disk}\": {\"Size in GB\": ${gb_size}}${trailing_comma}"
    done

    cat <<END
  },
  "Boot Parameters": {
END
    printed=0
    for entry in "${Bootparams[@]}"; do
        fields=(${entry//=/ })
        key=$(echo ${fields[0]} | sed -e "s/\-/\_/g")
        val=${fields[1]}
        ((printed++))
        trailing_comma=","
        [[ ${printed} -eq ${#Bootparams[*]} ]] && trailing_comma=''
        echo "    \"${key}\": \"$val\"${trailing_comma}"
    done
    cat <<END
  },
  "Network Interfaces": {
END

    printed=0
    for iface in "${NetworkInterfaces[@]}"; do
        mac_var="Network_Interface_${iface}_MAC_Address"
        ipv4_var="Network_Interface_${iface}_IPv4_Address"
        nicnames_var="Network_Interface_${iface}_NIC_Names"
        link_status_var="Network_Interface_${iface}_Link_Status"
        detected_tag_var="Network_Interface_${iface}_Detected_Nic_Tag"
        nic_names_fmt=
        detected_fmt=

        eval "mac=\${${mac_var}}"
        eval "ipv4=\${${ipv4_var}}"
        eval "nicnames=\${${nicnames_var}}"
        eval "link_status=\${${link_status_var}}"
        eval "detected_tag=\${${detected_tag_var}}"

        if [[ -n "${detected_tag}" ]] ; then
            detected_fmt="\"Detected NIC Name\": \"${detected_tag}\", "
        fi

        nic_names_array=$(echo "${nicnames}" | sed -e "s/,/\", \"/g")
        if [[ -n ${nic_names_array} ]]; then
            nic_names_fmt="\"${nic_names_array}\""
        fi

        ((printed++))
        trailing_comma=","
        [[ ${printed} -eq ${#NetworkInterfaces[*]} ]] && trailing_comma=''
        echo -n "    \"${iface}\": {"
        echo -n "\"MAC Address\": \"${mac}\", "
        echo -n "\"ip4addr\": \"${ipv4}\", "
        echo -n "\"Link Status\": \"${link_status}\", "
        echo -n "${detected_fmt}"
        echo -n "\"NIC Names\": [${nic_names_fmt}]}"
        echo "${trailing_comma}"
    done

    cat <<END
  }
}
END
}

if [[ ${UNAME_S} == "SunOS" ]]; then
    get_smbios_system_info
else
    get_dmidecode_system_info
fi
get_memory_mib
if [[ ${UNAME_S} == "SunOS" ]]; then
    get_smartos_cpu_info
else
    get_linux_cpu_info
fi
get_live_image_buildstamp
get_system_type
get_disks
get_hostname
get_nic_mappings
get_nic_tags
if [[ ${UNAME_S} == "SunOS" ]]; then
    get_smartos_network_interfaces
else
    get_linux_network_interfaces
fi
if [[ ${UNAME_S} == "SunOS" && ${DETECT_NICS} == "true" ]]; then
    detect_nic_tags
fi
get_bootparams

# whenever we update the cache, update both
if [[ ${CACHE} == "true" ]]; then
    output_parsable >> ${CACHE_FILE_PARSABLE}.new.$$ \
        && chmod 600 ${CACHE_FILE_PARSABLE}.new.$$ \
        && mv ${CACHE_FILE_PARSABLE}.new.$$ ${CACHE_FILE_PARSABLE}
    output_json >> ${CACHE_FILE_JSON}.new.$$ \
        && chmod 600 ${CACHE_FILE_JSON}.new.$$ \
        && mv ${CACHE_FILE_JSON}.new.$$ ${CACHE_FILE_JSON}
fi

# if we also want output, give it now
if [[ -z ${UPDATE_ONLY} ]]; then
    if [[ ${PARSABLE} == "true" ]]; then
        if [[ -z ${CACHE} ]]; then
            # We shouldn't read/write cache
            output_parsable
        else
            cat ${CACHE_FILE_PARSABLE} \
                || output_parsable
        fi
    else
        if [[ -z ${CACHE} ]]; then
            # We shouldn't read/write cache
            output_json
        else
            cat ${CACHE_FILE_JSON} \
                || output_json
        fi
    fi
fi

exit 0
