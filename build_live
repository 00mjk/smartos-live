#!/bin/bash
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

# Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
# Copyright 2010 Joyent, Inc.  All rights reserved.
# Use is subject to license terms.

ROOT=`pwd`/../illumos-joyent/proto/root_i386
MAN_DIR=`pwd`/../opensolaris-man
ALT_ROOT=`pwd`/proto
OUT_DIR=`pwd`/output
CUSTOMIZE_SCRIPT=`pwd`/customize
SCANNER=`pwd`/scanner
ERROR=0
PLATFORM=i86pc
ISA=i386
ARCH64=amd64
MANIFEST=
SIZE=700000
BOOT_ARCHIVE_64=platform/$PLATFORM/$ARCH64/boot_archive
KERNEL_64=platform/$PLATFORM/kernel/$ARCH64/unix
compress=no

export PATH=/usr/sbin:/usr/bin:/sbin
export GZIP_CMD=/usr/bin/gzip

usage() {
    echo "This tool is for building a live boot_archive amd64."
    echo ""
    echo "Usage: ${0##*/}: [-R <root>] [-A <altroot>] [-o <outdir>] <manifest>"
    exit 1
}

#
# Parse options
#
while [ "$1" != "" ]
do
    case $1 in
        -R|-r) 
            shift
            ROOT="$1"
        ;;
        -a|-A)
            shift
            ALT_ROOT="$1"
        ;;
        -o)
            shift
            OUT_DIR="$1"
        ;;
        -?|-h)
            usage
        ;;
        *)
            if [ -z "${MANIFEST}" ]; then
                MANIFEST=$1
            else
                # We already had manifest on cmdline, this is a usage problem
                usage
            fi
        ;;
    esac
    shift
done

# We need the manifest file
if [ -z "${MANIFEST}" ] || [ ! -f "${MANIFEST}" ]; then
    echo "FATAL: manifest file required"
    usage
fi

# We need the ROOT dir
if [ -z "${ROOT}" ] || [ ! -d "${ROOT}" ]; then
    echo "FATAL: root ${ROOT} required (Specify with -R <root>)"
    usage
fi

# If we have an ALT_ROOT specified, it must exist
if [ ! -z "${ALT_ROOT}" ]; then 
    if [ ! -d "${ALT_ROOT}" ]; then
        echo "FATAL: ${ALT_ROOT} does not exist."
        usage
    fi
else
    echo "WARNING: no -A <altroot> specified, files will only come from ${ROOT}"
fi

if [ ! -d "${OUT_DIR}" ]; then
    mkdir -p ${OUT_DIR}
    if [ ! -d "${OUT_DIR}" ]; then
        echo "FATAL: Tried to create OUT_DIR: ${OUT_DIR} but failed."
        exit 1
    fi
fi

echo "=== Options/ ==="
echo "ROOT ...... ${ROOT}"
echo "ALT_ROOT .. ${ALT_ROOT}"
echo "OUTPUT .... ${OUT_DIR}"
echo "MANIFEST . ${MANIFEST}"
echo "=== /Options ==="


function copy_files
{
    while read line
    do
        # Squeeze multiple spaces/tabs into one space
        line=`echo "${line}" | sed -e "s/	/ /" | tr -s ' '`
    
        # Remove leading/trailing spaces
        line=`echo "${line}" | sed -e "s/ +$//" | sed -e "s/^ +//"`
    
        if [ ! -z "${line}" ] && [ `echo "${line}" | cut -c1` != "#" ]; then
            echo "${line}" | { read e_type e_target e_mode e_owner e_group e_guard
                result="OK"
                case ${e_type} in
                    d)
                        pfexec install -s -d -m ${e_mode} -u ${e_owner} -g ${e_group} ${rdmnt}/${e_target}
                        [ -d "${rdmnt}/${e_target}" ] || result="*FAILED*"
                        echo "${result} - DIR: ${e_target}"
                    ;;
                    r)
                        [ -d "${rdmnt}/${e_target}" ] || pfexec mkdir -p "${rdmnt}/${e_target}"
                        if [ -d ${ROOT}/${e_target} ]; then
                            (cd ${ROOT}/${e_target} && pfexec tar -cpf - ./) \
                                | (cd ${rdmnt}/${e_target}; pfexec tar -xpf -)
                        fi
                        if [ -d ${ALT_ROOT}/${e_target} ]; then
                            (cd ${ALT_ROOT}/${e_target} && pfexec tar -cpf - ./) \
                                | (cd ${rdmnt}/${e_target}; pfexec tar -xpf -)
                        fi
                        #pfexec cp -pPR ${ALT_ROOT}/${e_target}/* ${rdmnt}/${e_target} 2>/dev/null \
                          #|| pfexec cp -pPR ${ROOT}/${e_target}/* ${rdmnt}/${e_target} 
                        echo "${result} - RECURSIVE: ${e_target}"
                    ;;
                    f)
                        pfexec cp -p ${ALT_ROOT}/${e_target} ${rdmnt}/${e_target} 2>/dev/null \
                          || pfexec cp -p ${ROOT}/${e_target} ${rdmnt}/${e_target} 2>/dev/null

                        # copy man pages from MAN_DIR if they've not been overriden
                        if [ "x$?" != "x0" ] && echo "${e_target}" | grep "^usr\/share\/man\/" >/dev/null 2>&1; then
                            man_file=`echo "${e_target}" | sed -e "s/^usr\/share\/man\///"`
                            pfexec cp -p ${MAN_DIR}/${man_file} ${rdmnt}/${e_target} 2>/dev/null
                        fi

                        if [ -f "${rdmnt}/${e_target}" ]; then
                            pfexec chmod ${e_mode} ${rdmnt}/${e_target}
                            pfexec chown ${e_owner}:${e_group} ${rdmnt}/${e_target}
                        else
                            result="*FAILED*"
                        fi
                        echo "${result} - FILE: ${e_target}"
                    ;;
                    s)
                        target=`echo ${e_target} | cut -d'=' -f2`
                        source=`echo ${e_target} | cut -d'=' -f1`
                        (cd ${rdmnt} ; \
                            pfexec ln -s ${target} ${source} ; \
                        )
                        echo "${result} - SYMLINK: ${target} -> ${source}"
                    ;;
                    h)
                        target=`echo ${e_target} | cut -d'=' -f2`
                        source=`echo ${e_target} | cut -d'=' -f1`
                        (cd ${rdmnt} ; \
                            pfexec ln ${target} ${source} ; \
                        )
                        echo "${result} - LINK: ${target} -> ${source}"
                    ;;
                    *)
                        echo "FATAL: UNKNOWN TYPE: ${line}"
                        exit 1
                    ;;
                esac
            } 
        else
            # Ignore comments and blank lines
            /bin/true
            #echo "IGNORE: ${line}"
        fi
    done <"${MANIFEST}"
}

function cleanup
{
    pfexec umount -f "${rdmnt}" 2>/dev/null
    pfexec lofiadm -d "${rdfile}" 2>/dev/null
    [ -n "${rddir}" ] && pfexec rm -fr "${rddir}" 2> /dev/null
}

function create_ufs
{
    archive=$1
    lofidev=$2

    pfexec newfs ${lofidev} < /dev/null 2> /dev/null
    pfexec mkdir "${rdmnt}"
    pfexec mount -F ufs -o nologging ${lofidev} "${rdmnt}"

    # do the actual copy
    copy_files
    ${CUSTOMIZE_SCRIPT} ${rdmnt} ${ALT_ROOT}

    echo "Writing manifest.."
    INCLUDE_MD5SUM=1 pfexec ${SCANNER} ${rdmnt} . | pfexec tee ${rdmnt}/var/log/manifest >/dev/null
    pfexec cp ${rdmnt}/var/log/manifest ${archive}.manifest

    pfexec umount -f "$rdmnt"
    pfexec rmdir "$rdmnt"
    pfexec gzip "$rdfile" && pfexec mv "${rdfile}.gz" "${archive}-new"

    if [ $? -ne 0 ] ; then
        pfexec rm -f "${archive}-new"
        pfexec rm -f "${archive}.manifest"
    fi
}

function create_archive
{
    archive=$1
    lofidev=$2

    echo "creating ${archive} (${lofidev})"
    pfexec mkdir -p `dirname ${archive}`

    create_ufs "$archive" "$lofidev"

    # sanity check the archive before moving it into place
    #
    ARCHIVE_SIZE=`ls -l "${archive}-new" 2> /dev/null | nawk '{ print $5 }'`
    if [ $compress = yes ]; then
        #
        # 'file' will report "English text" for uncompressed
        # boot_archives.  Checking for that doesn't seem stable,
        # so we just check that the file exists.
        #
        ls "${archive}-new" >/dev/null 2>&1
    else
        #
        # the file type check also establishes that the
        # file exists at all
        #
        LC_MESSAGES=C file "${archive}-new" | grep gzip > /dev/null
    fi

    if [ $? = 1 ] && [ -x $GZIP_CMD ] || [ "$ARCHIVE_SIZE" -lt 10000 ]
    then
        #
        # Two of these functions may be run in parallel.  We
        # need to allow the other to clean up, so we can't
        # exit immediately.  Instead, we set a flag.
        #
        echo "update of $archive failed"
        ERROR=1
    else
        lockfs -f "/$OUT_DIR" 2>/dev/null
        pfexec mv "${archive}-new" "$archive"
        lockfs -f "/$OUT_DIR" 2>/dev/null
    fi

}

function fatal_error
{
    print -u2 $*
    exit 1
}

# Create tmp dir to do the work in
rddir="/var/tmp/create_ramdisk.$$.tmp"
pfexec rm -rf "$rddir"
pfexec mkdir "$rddir" || fatal_error "Could not create temporary directory $rddir"

# Clean up upon exit.
trap 'cleanup' EXIT

rdfile="$rddir/rd.file.32"
rdmnt="$rddir/rd.mnt.32"
lofidev=""

echo "Creating ${SIZE}k ramdisk image: ${rdfile}" 
pfexec mkfile ${SIZE}k "${rdfile}"
pfexec chown ${USER} ${rdfile}
lofidev32=`pfexec lofiadm -a "${rdfile}"`
create_archive "${OUT_DIR}/${BOOT_ARCHIVE_64}" $lofidev32
pfexec mkdir -p `dirname ${OUT_DIR}/${KERNEL_64}`
pfexec cp ${ROOT}/${KERNEL_64} ${OUT_DIR}/${KERNEL_64}
pfexec lofiadm -d "$rdfile32" 2>/dev/null
pfexec chmod 0644 ${OUT_DIR}/${BOOT_ARCHIVE_64}

if [ $ERROR = 1 ]; then
    cleanup
    exit 1
fi
