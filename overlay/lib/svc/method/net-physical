#!/usr/bin/ksh93
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
#
# Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All rights reserved.
# Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
# Copyright (c) 2010, 2011 Joyent Inc., All rights reserved.
#

. /lib/svc/share/smf_include.sh
. /lib/sdc/config.sh
. /lib/sdc/network.sh

set -o errexit
set -o xtrace

#
# In a shared-IP zone we need this service to be up, but all of the work
# it tries to do is irrelevant (and will actually lead to the service
# failing if we try to do it), so just bail out.
# In the global zone and exclusive-IP zones we proceed.
#
smf_configure_ip || exit ${SMF_EXIT_OK}

# Make sure that the libraries essential to this stage of booting can be found.
LD_LIBRARY_PATH=/lib; export LD_LIBRARY_PATH

smf_netstrategy

if smf_is_globalzone; then

    dladm init-phys

    #
    # Use the MAC address to sort the NICs and rename any that are out of
    # order so that we always get a consistent name for each NIC.
    #
    dladm show-phys -m -o ADDRESS,LINK | sort | nawk '{
    if ($1 == "ADDRESS")
        next

    l = length($2)

    pos = match($2, "[0-9]+$")
    if (pos == 0)
        next

    nm = substr($2, 1, pos - 1)
    id = substr($2, pos)

    i = idx[nm]++;
    if (id == i)
        next

    new_name = nm i
    tmp_name = "tmp_" nm i

    cmd = "dladm rename-link " $2 " " tmp_name
    cleanup[tmp_name] = new_name
    system(cmd)
    }
    END {
    for (i in cleanup) {
        cmd = "dladm rename-link " i " " cleanup[i]
        system(cmd)
    }
    }'

    # Load sysinfo variables with SYSINFO_ prefix
    load_sdc_sysinfo
    # Load config variables with CONFIG_ prefix, and sets the headnode variable
    load_sdc_config

    # Setup admin NIC
    if [[ -n ${SYSINFO_NIC_admin} ]]; then
        ifconfig ${SYSINFO_NIC_admin} plumb
        if [[ ${headnode} == "true" ]]; then
            if [[ -n ${CONFIG_admin_ip} ]] && [[ -n ${CONFIG_admin_netmask} ]]; then
                ifconfig ${SYSINFO_NIC_admin} inet ${CONFIG_admin_ip} netmask ${CONFIG_admin_netmask} up
                ADMIN_NIC_UP=true

                # also setup resolv.conf if we can
                if [[ -n ${CONFIG_dns_domain} ]] && [[ -n ${CONFIG_dns_resolvers} ]]; then
                    echo "search ${CONFIG_dns_domain}" > /etc/resolv.conf
                    for serv in $(echo "${CONFIG_dns_resolvers}" | sed -e "s/,/ /g"); do
                        echo "nameserver ${serv}" >> /etc/resolv.conf
                    done
                fi
            else
                echo "WARNING: headnode but no admin_{ip,netmask} in config, not bringing up admin network."
            fi
        else
            ifconfig ${SYSINFO_NIC_admin} dhcp
            ADMIN_NIC_UP=true
        fi
        # If on VMWare, create a bridge which allows traffic to flow correctly to the host-only network
        if [[ "${ADMIN_NIC_UP}" == "true" ]] && [[ ${SYSINFO_Product} == "VMware Virtual Platform" ]]; then
            dladm create-bridge -l ${SYSINFO_NIC_admin} vmwarebr
        fi
    fi

    # Setup external NIC -- only headnode because non-headnodes don't assign
    # IP to external in GZ.
    if [[ -n ${SYSINFO_NIC_external} ]]; then
        if [[ -n "${CONFIG_external_ip}" ]]; then
            iface=${SYSINFO_NIC_external}
            if [[ -n ${CONFIG_external_vlan_id} ]]; then
                dladm create-vnic -l ${iface} -v ${CONFIG_external_vlan_id} global0
                iface="global0"
            fi
            ifconfig ${iface} plumb
            if [[ ${CONFIG_external_ip} == "dhcp" ]]; then
                ifconfig ${iface} dhcp primary
            else
                ifconfig ${iface} inet ${CONFIG_external_ip} netmask ${CONFIG_external_netmask} up
                if [[ -n "${CONFIG_external_gateway}" ]]; then
                    echo "${CONFIG_external_gateway}" > /etc/defaultrouter
                fi
            fi

            # Set up the GZ to NAT for Coal
            if [[ "${CONFIG_headnode_nat}" == "true" ]]; then
                # Convert the admin IP and netmask to CIDR notation
                CIDR=$(ip_netmask_to_cidr ${CONFIG_admin_ip} ${CONFIG_admin_netmask})

                # Allow zones to reach the internet using the global zone as a router
                if [[ -n ${CONFIG_external_vlan_id} ]]; then
                    IPNAT_NIC="global0"
                else
                    IPNAT_NIC=${SYSINFO_NIC_external}
                fi
                cat >> /etc/ipf/ipnat.conf <<IPNAT
map ${IPNAT_NIC} ${CIDR} -> 0.0.0.0/32
map ${IPNAT_NIC} ${CIDR} -> 0.0.0.0/32 portmap tcp/udp auto
IPNAT
            fi
            # If any of the headnode zones are configured to use public IPs, create a bridge on the external
            # interface so vnics on the external interface work as well
            if [[ "${headnode}" == "true" ]] && [[ "$(sdc_config_keys_contain public_ip)" == "true" ]]; then
                create_vmware_external_bridge
            fi
        fi
    fi

    # Now the zone vnics. They only need to be defined
    ZONES=`zoneadm list -pi | grep -v "global" | grep installed | cut -d ":" -f 2`
    for zone in ${ZONES}; do
        for vnic in `zonecfg -z ${zone} info net | grep 'physical:' | awk '{ print $2 }'`; do

            # Get options from zfs {admin|internal|external} attach to ${nic}_phys if that is set
            nic=$(zfs get -H smartdc.network:${vnic}.nic zones/${zone} | awk '{ print $3 }')
            [[ ${nic} == '-' ]] && nic=
            vlan=$(zfs get -H smartdc.network:${vnic}.vlan_id zones/${zone} | awk '{ print $3 }')
            [[ ${vlan} == '-' ]] && vlan=
            vnic_mac=$(zfs get -H smartdc.network:${vnic}.mac zones/${zone} | awk '{ print $3 }')
            [[ ${vnic_mac} == '-' ]] && vnic_mac=
            zone_phys=
            if [[ -n ${nic} ]]; then
                zone_phys=$(eval "echo \${SYSINFO_NIC_${nic}}")
            fi

            # If on VMWare and we have external IPs, create a bridge to allow zones to reach the external gateway
            if [[ "${headnode}" == "true" ]] && [[ ${nic} == "external" ]]; then
                create_vmware_external_bridge
            fi

            # We used to assume vnics that end with 0 should be attached to
            # admin_nic and all other vnics should be attached to external_nic
            # Now we can tell from the metadata attached to the zone dataset.
            if [[ -n ${zone_phys} ]]; then
                vnic_opts=
                if [[ -n ${vlan} ]] && [[ "${vlan}" != "0" ]]; then
                    vnic_opts="-v ${vlan}"
                fi
                if [[ -n ${vnic_mac} ]]; then
                    vnic_opts="-m ${vnic_mac} ${vnic_opts}"
                fi
                dladm create-vnic -l ${zone_phys} ${vnic_opts} ${vnic}
                if [[ -z ${vnic_mac} ]]; then
                    # if we didn't already know the MAC, we just created one, save that
                    vnic_mac=$(dladm show-vnic -p -o MACADDRESS ${vnic})
                    [[ -n ${vnic_mac} ]] && /usr/sbin/zfs set smartdc.network:${vnic}.mac=${vnic_mac} zones/${zone}
                fi
            else
                echo "WARNING: not bringing up vnic '${vnic}' for zone '${zone}' due to misconfiguration."
            fi
        done
    done

else
    # Non-global zones
    for iface in `dladm show-vnic -p -o link`; do
        ifconfig ${iface} plumb
        if [[ -f /etc/dhcp.${iface} || ! -f /etc/hostname.${iface} ]]; then
            ifconfig ${iface} dhcp
        else
            ifconfig ${iface} inet `cat /etc/hostname.${iface}` up
        fi
    done
fi

# Any non-loopback IPv4 interfaces with usable addresses up?
if [[ -n "`/sbin/ifconfig -a4u`" ]]; then
    /sbin/ifconfig -a4u | while read intf addr rest; do
        [[ ${intf} == "inet" ]] && [[ ${addr} != "127.0.0.1" ]] &&
        [[ ${addr} != "0.0.0.0" ]] && exit ${SMF_EXIT_OK}
    done && exit ${SMF_EXIT_OK}
fi

# Any DHCP interfaces started?
[[ -n "`/sbin/ifconfig -a4 dhcp status 2>/dev/null`" ]] && exit ${SMF_EXIT_OK}

# Any non-loopback IPv6 interfaces up?
if [[ -n "`/sbin/ifconfig -au6`" ]]; then
    /sbin/ifconfig -au6 | while read intf addr rest; do
        [[ ${intf} = "inet6" ]] && [[ ${addr} != "::1/128" ]] && exit ${SMF_EXIT_OK}
    done && exit ${SMF_EXIT_OK}
fi

# This service was supposed to configure something yet didn't.  Exit
# with config error.
exit ${SMF_EXIT_ERR_CONFIG}
