#!/bin/bash
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

# Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
# Copyright 2010 Joyent, Inc.  All rights reserved.
# Use is subject to license terms.

ROOT=`pwd`
MAN_DIR=${ROOT}/projects/opensolaris-man
CUSTOMIZE_SCRIPT=${ROOT}/tools/customize
SMF_IMPORTER=${ROOT}/tools/smf_import
BUILDER=${ROOT}/tools/builder/builder
SCANNER=${ROOT}/tools/scanner
PWGEN=${ROOT}/tools/pwgen
BUILDSTAMP=`TZ=UTC date "+%Y%m%dT%H%M%SZ"`; export BUILDSTAMP 
LOGFILE="${ROOT}/log/build_live.${BUILDSTAMP}.log"
ERROR=0
PLATFORM=i86pc
ISA=i386
ARCH64=amd64
SIZE=750000
BOOT_ARCHIVE_64=platform-${BUILDSTAMP}/$PLATFORM/$ARCH64/boot_archive
OUT_KERNEL_64=platform-${BUILDSTAMP}/$PLATFORM/kernel/$ARCH64/unix
KERNEL_64=platform/$PLATFORM/kernel/$ARCH64/unix
PREFIX=platform-${BUILDSTAMP}
compress=no

if [ "$(id -u)" != "0" ]; then
  echo "You must have euid 0 to run this tool."
  exit 1
fi

# Send a copy of stdout and stderr to LOGFILE
exec > >(tee ${LOGFILE}) 2>&1

export PATH=/usr/sbin:/usr/bin:/sbin
export GZIP_CMD=/usr/bin/gzip

usage() {
    echo "This tool is for building a live boot_archive amd64."
    echo ""
    echo "Usage: ${0##*/}: <manifest> <outdir> <dir> [<dir> <dir> ...]"
    exit 1
}

MANIFEST=$1
shift
OUT_DIR=$1
shift
IN_DIRS=$*

# We need the manifest file
if [ -z "${MANIFEST}" ] || [ ! -f "${MANIFEST}" ]; then
    echo "FATAL: <manifest> file required"
    usage
else
    # translate to abs path
    NEW_MANIFEST=$(cd $(dirname ${MANIFEST}) && pwd)/$(basename ${MANIFEST})
    MANIFEST=${NEW_MANIFEST}
fi

if [ -z "${OUT_DIR}" ]; then
    echo "FATAL: <outdir> required."
    usage
fi

if [ -z "${IN_DIRS}" ]; then
    echo "FATAL: at least one <dir> required."
    usage
fi

if [ ! -d "${OUT_DIR}" ]; then
    mkdir -p ${OUT_DIR}
    if [ ! -d "${OUT_DIR}" ]; then
        echo "FATAL: Tried to create OUT_DIR: ${OUT_DIR} but failed."
        exit 1
    fi
fi

num=0
echo "=== Options/ ==="
echo "MANIFEST .. ${MANIFEST}"
echo "OUTPUT .... ${OUT_DIR}"
for dir in ${IN_DIRS}; do
  num=$((${num} + 1))
  echo "DIR[$(printf '%02d' ${num})] ... ${dir}"
done
echo "=== /Options ==="


function cleanup
{
    umount -f "${rdmnt}" 2>/dev/null
    lofiadm -d "${rdfile}" 2>/dev/null
    [ -n "${rddir}" ] && rm -fr "${rddir}" 2> /dev/null
}

function create_ufs
{
    archive=$1
    lofidev=$2

    newfs ${lofidev} < /dev/null 2> /dev/null
    mkdir "${rdmnt}"
    mount -F ufs -o nologging ${lofidev} "${rdmnt}"

    # do the actual copy
    ${BUILDER} ${MANIFEST} ${rdmnt} ${IN_DIRS}
    ${CUSTOMIZE_SCRIPT} ${rdmnt}
    ${SMF_IMPORTER} ${rdmnt}

    echo "Setting root password..."
    create_password "${rdmnt}"

    echo "Writing md5sum manifest..."
    (cd ${rdmnt} && find . -type f | sort | xargs md5sum) > ${rdmnt}/var/log/manifest
    #INCLUDE_MD5SUM=1 ${SCANNER} ${rdmnt} . | tee ${rdmnt}/var/log/manifest >/dev/null
    cp ${rdmnt}/var/log/manifest ${archive}.manifest

    # make sure the kernel we copy over matches our boot archive by copying from there.
    mkdir -p `dirname ${OUT_DIR}/${OUT_KERNEL_64}`
    cp ${rdmnt}/${KERNEL_64} ${OUT_DIR}/${OUT_KERNEL_64}

    umount -f "$rdmnt"
    rmdir "$rdmnt"
    gzip "$rdfile" && mv "${rdfile}.gz" "${archive}-new"

    if [ $? -ne 0 ] ; then
        rm -f "${archive}-new"
        rm -f "${archive}.manifest"
    fi
}

function create_archive
{
    archive=$1
    lofidev=$2

    echo "creating ${archive} (${lofidev})"
    mkdir -p `dirname ${archive}`

    create_ufs "$archive" "$lofidev"

    # sanity check the archive before moving it into place
    #
    ARCHIVE_SIZE=`ls -l "${archive}-new" 2> /dev/null | nawk '{ print $5 }'`
    if [ $compress = yes ]; then
        #
        # 'file' will report "English text" for uncompressed
        # boot_archives.  Checking for that doesn't seem stable,
        # so we just check that the file exists.
        #
        ls "${archive}-new" >/dev/null 2>&1
    else
        #
        # the file type check also establishes that the
        # file exists at all
        #
        LC_MESSAGES=C file "${archive}-new" | grep gzip > /dev/null
    fi

    if [ $? = 1 ] && [ -x $GZIP_CMD ] || [ "$ARCHIVE_SIZE" -lt 10000 ]
    then
        #
        # Two of these functions may be run in parallel.  We
        # need to allow the other to clean up, so we can't
        # exit immediately.  Instead, we set a flag.
        #
        echo "update of $archive failed"
        ERROR=1
    else
        lockfs -f "/$OUT_DIR" 2>/dev/null
        mv "${archive}-new" "$archive"
        lockfs -f "/$OUT_DIR" 2>/dev/null
    fi

}

function create_password
{
    rdmnt=$1

    password="$(${PWGEN} -B -c -n 16 1)"
    if [[ -z ${password} ]]; then
        fatal_error "Unable to generate password."
    fi

    # actually write password into ${rdmnt}/etc/shadow
    enc_password="$(${ROOT}/tools/cryptpass "${password}")"
    if [[ -z ${enc_password} ]]; then
        fatal_error "Unable to generate encrypted password."
    fi
    gsed -i -e "s|^root:[^\:]*:|root:${enc_password}:|" ${rdmnt}/etc/shadow

    # write in plaintext to platform so we can find it later if we need it
    echo "${password}" > ${OUT_DIR}/${PREFIX}/root.password
}

function fatal_error
{
    print -u2 $*
    exit 1
}

# Create tmp dir to do the work in
rddir="/tmp/create_ramdisk.$$.tmp"
rm -rf "$rddir"
mkdir "$rddir" || fatal_error "Could not create temporary directory $rddir"

# Clean up upon exit.
trap 'cleanup' EXIT

rdfile="$rddir/rd.file.32"
rdmnt="$rddir/rd.mnt.32"
lofidev=""

echo "Creating ${SIZE}k ramdisk image: ${rdfile}" 
mkfile ${SIZE}k "${rdfile}"
chown ${USER} ${rdfile}
lofidev32=`lofiadm -a "${rdfile}"`
create_archive "${OUT_DIR}/${BOOT_ARCHIVE_64}" $lofidev32
lofiadm -d "$rdfile32" 2>/dev/null
chmod 0644 ${OUT_DIR}/${BOOT_ARCHIVE_64}
(cd ${OUT_DIR} && gtar -zcf ${PREFIX}.tgz ${PREFIX})

if [ $ERROR = 1 ]; then
    cleanup
    exit 1
fi
